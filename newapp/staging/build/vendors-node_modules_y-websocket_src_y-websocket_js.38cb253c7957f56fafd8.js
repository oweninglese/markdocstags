(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_y-websocket_src_y-websocket_js"],{

/***/ "./node_modules/lib0/broadcastchannel.js":
/*!***********************************************!*\
  !*** ./node_modules/lib0/broadcastchannel.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subscribe": () => (/* binding */ subscribe),
/* harmony export */   "unsubscribe": () => (/* binding */ unsubscribe),
/* harmony export */   "publish": () => (/* binding */ publish)
/* harmony export */ });
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ "./node_modules/lib0/map.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/lib0/buffer.js");
/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage.js */ "./node_modules/lib0/storage.js");
/* eslint-env browser */

/**
 * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.
 *
 * ```js
 * // In browser window A:
 * broadcastchannel.subscribe('my events', data => console.log(data))
 * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab
 *
 * // In browser window B:
 * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'
 * ```
 *
 * @module broadcastchannel
 */

// @todo before next major: use Uint8Array instead as buffer object





/**
 * @typedef {Object} Channel
 * @property {Set<Function>} Channel.subs
 * @property {any} Channel.bc
 */

/**
 * @type {Map<string, Channel>}
 */
const channels = new Map()

class LocalStoragePolyfill {
  /**
   * @param {string} room
   */
  constructor (room) {
    this.room = room
    /**
     * @type {null|function({data:ArrayBuffer}):void}
     */
    this.onmessage = null
    _storage_js__WEBPACK_IMPORTED_MODULE_0__.onChange(e => e.key === room && this.onmessage !== null && this.onmessage({ data: _buffer_js__WEBPACK_IMPORTED_MODULE_1__.fromBase64(e.newValue || '') }))
  }

  /**
   * @param {ArrayBuffer} buf
   */
  postMessage (buf) {
    _storage_js__WEBPACK_IMPORTED_MODULE_0__.varStorage.setItem(this.room, _buffer_js__WEBPACK_IMPORTED_MODULE_1__.toBase64(_buffer_js__WEBPACK_IMPORTED_MODULE_1__.createUint8ArrayFromArrayBuffer(buf)))
  }
}

// Use BroadcastChannel or Polyfill
const BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel

/**
 * @param {string} room
 * @return {Channel}
 */
const getChannel = room =>
  _map_js__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(channels, room, () => {
    const subs = new Set()
    const bc = new BC(room)
    /**
     * @param {{data:ArrayBuffer}} e
     */
    bc.onmessage = e => subs.forEach(sub => sub(e.data))
    return {
      bc, subs
    }
  })

/**
 * Subscribe to global `publish` events.
 *
 * @function
 * @param {string} room
 * @param {function(any):any} f
 */
const subscribe = (room, f) => getChannel(room).subs.add(f)

/**
 * Unsubscribe from `publish` global events.
 *
 * @function
 * @param {string} room
 * @param {function(any):any} f
 */
const unsubscribe = (room, f) => getChannel(room).subs.delete(f)

/**
 * Publish data to all subscribers (including subscribers on this tab)
 *
 * @function
 * @param {string} room
 * @param {any} data
 */
const publish = (room, data) => {
  const c = getChannel(room)
  c.bc.postMessage(data)
  c.subs.forEach(sub => sub(data))
}


/***/ }),

/***/ "./node_modules/lib0/mutex.js":
/*!************************************!*\
  !*** ./node_modules/lib0/mutex.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMutex": () => (/* binding */ createMutex)
/* harmony export */ });
/**
 * Mutual exclude for JavaScript.
 *
 * @module mutex
 */

/**
 * @callback mutex
 * @param {function():void} cb Only executed when this mutex is not in the current stack
 * @param {function():void} [elseCb] Executed when this mutex is in the current stack
 */

/**
 * Creates a mutual exclude function with the following property:
 *
 * ```js
 * const mutex = createMutex()
 * mutex(() => {
 *   // This function is immediately executed
 *   mutex(() => {
 *     // This function is not executed, as the mutex is already active.
 *   })
 * })
 * ```
 *
 * @return {mutex} A mutual exclude function
 * @public
 */
const createMutex = () => {
  let token = true
  return (f, g) => {
    if (token) {
      token = false
      try {
        f()
      } finally {
        token = true
      }
    } else if (g !== undefined) {
      g()
    }
  }
}


/***/ }),

/***/ "./node_modules/lib0/url.js":
/*!**********************************!*\
  !*** ./node_modules/lib0/url.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeQueryParams": () => (/* binding */ decodeQueryParams),
/* harmony export */   "encodeQueryParams": () => (/* binding */ encodeQueryParams)
/* harmony export */ });
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object.js */ "./node_modules/lib0/object.js");
/**
 * Utility module to work with urls.
 *
 * @module url
 */



/**
 * Parse query parameters from an url.
 *
 * @param {string} url
 * @return {Object<string,string>}
 */
const decodeQueryParams = url => {
  /**
   * @type {Object<string,string>}
   */
  const query = {}
  const urlQuerySplit = url.split('?')
  const pairs = urlQuerySplit[urlQuerySplit.length - 1].split('&')
  for (var i = 0; i < pairs.length; i++) {
    const item = pairs[i]
    if (item.length > 0) {
      const pair = item.split('=')
      query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '')
    }
  }
  return query
}

/**
 * @param {Object<string,string>} params
 * @return {string}
 */
const encodeQueryParams = params =>
  _object_js__WEBPACK_IMPORTED_MODULE_0__.map(params, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join('&')


/***/ }),

/***/ "./node_modules/y-protocols/auth.js":
/*!******************************************!*\
  !*** ./node_modules/y-protocols/auth.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "messagePermissionDenied": () => (/* binding */ messagePermissionDenied),
/* harmony export */   "writePermissionDenied": () => (/* binding */ writePermissionDenied),
/* harmony export */   "readAuthMessage": () => (/* binding */ readAuthMessage)
/* harmony export */ });
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/encoding */ "./node_modules/lib0/encoding.js");
/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/decoding */ "./node_modules/lib0/decoding.js");

 // eslint-disable-line



const messagePermissionDenied = 0

/**
 * @param {encoding.Encoder} encoder
 * @param {string} reason
 */
const writePermissionDenied = (encoder, reason) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint(encoder, messagePermissionDenied)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarString(encoder, reason)
}

/**
 * @callback PermissionDeniedHandler
 * @param {any} y
 * @param {string} reason
 */

/**
 *
 * @param {decoding.Decoder} decoder
 * @param {Y.Doc} y
 * @param {PermissionDeniedHandler} permissionDeniedHandler
 */
const readAuthMessage = (decoder, y, permissionDeniedHandler) => {
  switch (lib0_decoding__WEBPACK_IMPORTED_MODULE_2__.readVarUint(decoder)) {
    case messagePermissionDenied: permissionDeniedHandler(y, lib0_decoding__WEBPACK_IMPORTED_MODULE_2__.readVarString(decoder))
  }
}


/***/ }),

/***/ "./node_modules/y-protocols/awareness.js":
/*!***********************************************!*\
  !*** ./node_modules/y-protocols/awareness.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "outdatedTimeout": () => (/* binding */ outdatedTimeout),
/* harmony export */   "Awareness": () => (/* binding */ Awareness),
/* harmony export */   "removeAwarenessStates": () => (/* binding */ removeAwarenessStates),
/* harmony export */   "encodeAwarenessUpdate": () => (/* binding */ encodeAwarenessUpdate),
/* harmony export */   "modifyAwarenessUpdate": () => (/* binding */ modifyAwarenessUpdate),
/* harmony export */   "applyAwarenessUpdate": () => (/* binding */ applyAwarenessUpdate)
/* harmony export */ });
/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/encoding */ "./node_modules/lib0/encoding.js");
/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/decoding */ "./node_modules/lib0/decoding.js");
/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/time */ "./node_modules/lib0/time.js");
/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/math */ "./node_modules/lib0/math.js");
/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/observable */ "./node_modules/lib0/observable.js");
/* harmony import */ var lib0_function__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/function */ "./node_modules/lib0/function.js");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @module awareness-protocol
 */







 // eslint-disable-line

const outdatedTimeout = 30000

/**
 * @typedef {Object} MetaClientState
 * @property {number} MetaClientState.clock
 * @property {number} MetaClientState.lastUpdated unix timestamp
 */

/**
 * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information
 * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of
 * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.
 *
 * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override
 * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is
 * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that
 * a remote client is offline, it may propagate a message with
 * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a
 * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.
 *
 * Before a client disconnects, it should propagate a `null` state with an updated clock.
 *
 * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.
 *
 * @extends {Observable<string>}
 */
class Awareness extends lib0_observable__WEBPACK_IMPORTED_MODULE_1__.Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor (doc) {
    super()
    this.doc = doc
    /**
     * @type {number}
     */
    this.clientID = doc.clientID
    /**
     * Maps from client id to client state
     * @type {Map<number, Object<string, any>>}
     */
    this.states = new Map()
    /**
     * @type {Map<number, MetaClientState>}
     */
    this.meta = new Map()
    this._checkInterval = /** @type {any} */ (setInterval(() => {
      const now = lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {
        // renew local clock
        this.setLocalState(this.getLocalState())
      }
      /**
       * @type {Array<number>}
       */
      const remove = []
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid)
        }
      })
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, 'timeout')
      }
    }, lib0_math__WEBPACK_IMPORTED_MODULE_3__.floor(outdatedTimeout / 10)))
    doc.on('destroy', () => {
      this.destroy()
    })
    this.setLocalState({})
  }

  destroy () {
    this.emit('destroy', [this])
    this.setLocalState(null)
    super.destroy()
    clearInterval(this._checkInterval)
  }

  /**
   * @return {Object<string,any>|null}
   */
  getLocalState () {
    return this.states.get(this.clientID) || null
  }

  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState (state) {
    const clientID = this.clientID
    const currLocalMeta = this.meta.get(clientID)
    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1
    const prevState = this.states.get(clientID)
    if (state === null) {
      this.states.delete(clientID)
    } else {
      this.states.set(clientID, state)
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
    })
    const added = []
    const updated = []
    const filteredUpdated = []
    const removed = []
    if (state === null) {
      removed.push(clientID)
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID)
      }
    } else {
      updated.push(clientID)
      if (!lib0_function__WEBPACK_IMPORTED_MODULE_4__.equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID)
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])
    }
    this.emit('update', [{ added, updated, removed }, 'local'])
  }

  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField (field, value) {
    const state = this.getLocalState()
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      })
    }
  }

  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates () {
    return this.states
  }
}

/**
 * Mark (remote) clients as inactive and remove them from the list of active peers.
 * This change will be propagated to remote clients.
 *
 * @param {Awareness} awareness
 * @param {Array<number>} clients
 * @param {any} origin
 */
const removeAwarenessStates = (awareness, clients, origin) => {
  const removed = []
  for (let i = 0; i < clients.length; i++) {
    const clientID = clients[i]
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID)
      if (clientID === awareness.clientID) {
        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
        })
      }
      removed.push(clientID)
    }
  }
  if (removed.length > 0) {
    awareness.emit('change', [{ added: [], updated: [], removed }, origin])
    awareness.emit('update', [{ added: [], updated: [], removed }, origin])
  }
}

/**
 * @param {Awareness} awareness
 * @param {Array<number>} clients
 * @return {Uint8Array}
 */
const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length
  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.createEncoder()
  lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, len)
  for (let i = 0; i < len; i++) {
    const clientID = clients[i]
    const state = states.get(clientID) || null
    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clientID)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clock)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarString(encoder, JSON.stringify(state))
  }
  return lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.toUint8Array(encoder)
}

/**
 * Modify the content of an awareness update before re-encoding it to an awareness update.
 *
 * This might be useful when you have a central server that wants to ensure that clients
 * cant hijack somebody elses identity.
 *
 * @param {Uint8Array} update
 * @param {function(any):any} modify
 * @return {Uint8Array}
 */
const modifyAwarenessUpdate = (update, modify) => {
  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.createDecoder(update)
  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.createEncoder()
  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, len)
  for (let i = 0; i < len; i++) {
    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarString(decoder))
    const modifiedState = modify(state)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clientID)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clock)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarString(encoder, JSON.stringify(modifiedState))
  }
  return lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.toUint8Array(encoder)
}

/**
 * @param {Awareness} awareness
 * @param {Uint8Array} update
 * @param {any} origin This will be added to the emitted change event
 */
const applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.createDecoder(update)
  const timestamp = lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
  const added = []
  const updated = []
  const filteredUpdated = []
  const removed = []
  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
  for (let i = 0; i < len; i++) {
    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarString(decoder))
    const clientMeta = awareness.meta.get(clientID)
    const prevState = awareness.states.get(clientID)
    const currClock = clientMeta === undefined ? 0 : clientMeta.clock
    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {
      if (state === null) {
        // never let a remote client remove this local state
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          // remote client removed the local state. Do not remote state. Broadcast a message indicating
          // that this client still exists by increasing the clock
          clock++
        } else {
          awareness.states.delete(clientID)
        }
      } else {
        awareness.states.set(clientID, state)
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      })
      if (clientMeta === undefined && state !== null) {
        added.push(clientID)
      } else if (clientMeta !== undefined && state === null) {
        removed.push(clientID)
      } else if (state !== null) {
        if (!lib0_function__WEBPACK_IMPORTED_MODULE_4__.equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID)
        }
        updated.push(clientID)
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit('change', [{
      added, updated: filteredUpdated, removed
    }, origin])
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit('update', [{
      added, updated, removed
    }, origin])
  }
}


/***/ }),

/***/ "./node_modules/y-protocols/sync.js":
/*!******************************************!*\
  !*** ./node_modules/y-protocols/sync.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "messageYjsSyncStep1": () => (/* binding */ messageYjsSyncStep1),
/* harmony export */   "messageYjsSyncStep2": () => (/* binding */ messageYjsSyncStep2),
/* harmony export */   "messageYjsUpdate": () => (/* binding */ messageYjsUpdate),
/* harmony export */   "writeSyncStep1": () => (/* binding */ writeSyncStep1),
/* harmony export */   "writeSyncStep2": () => (/* binding */ writeSyncStep2),
/* harmony export */   "readSyncStep1": () => (/* binding */ readSyncStep1),
/* harmony export */   "readSyncStep2": () => (/* binding */ readSyncStep2),
/* harmony export */   "writeUpdate": () => (/* binding */ writeUpdate),
/* harmony export */   "readUpdate": () => (/* binding */ readUpdate),
/* harmony export */   "readSyncMessage": () => (/* binding */ readSyncMessage)
/* harmony export */ });
/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/encoding */ "./node_modules/lib0/encoding.js");
/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/decoding */ "./node_modules/lib0/decoding.js");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @module sync-protocol
 */





/**
 * @typedef {Map<number, number>} StateMap
 */

/**
 * Core Yjs defines two message types:
 * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.
 * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it
 *   received all information from the remote client.
 *
 * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection
 * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both
 * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.
 *
 * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.
 * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies
 * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the
 * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can
 * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.
 * Therefore it is necesarry that the client initiates the sync.
 *
 * Construction of a message:
 * [messageType : varUint, message definition..]
 *
 * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!
 *
 * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)
 */

const messageYjsSyncStep1 = 0
const messageYjsSyncStep2 = 1
const messageYjsUpdate = 2

/**
 * Create a sync step 1 message based on the state of the current shared document.
 *
 * @param {encoding.Encoder} encoder
 * @param {Y.Doc} doc
 */
const writeSyncStep1 = (encoder, doc) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint(encoder, messageYjsSyncStep1)
  const sv = yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateVector(doc)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint8Array(encoder, sv)
}

/**
 * @param {encoding.Encoder} encoder
 * @param {Y.Doc} doc
 * @param {Uint8Array} [encodedStateVector]
 */
const writeSyncStep2 = (encoder, doc, encodedStateVector) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint(encoder, messageYjsSyncStep2)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint8Array(encoder, yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateAsUpdate(doc, encodedStateVector))
}

/**
 * Read SyncStep1 message and reply with SyncStep2.
 *
 * @param {decoding.Decoder} decoder The reply to the received message
 * @param {encoding.Encoder} encoder The received message
 * @param {Y.Doc} doc
 */
const readSyncStep1 = (decoder, encoder, doc) =>
  writeSyncStep2(encoder, doc, lib0_decoding__WEBPACK_IMPORTED_MODULE_2__.readVarUint8Array(decoder))

/**
 * Read and apply Structs and then DeleteStore to a y instance.
 *
 * @param {decoding.Decoder} decoder
 * @param {Y.Doc} doc
 * @param {any} transactionOrigin
 */
const readSyncStep2 = (decoder, doc, transactionOrigin) => {
  try {
    yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdate(doc, lib0_decoding__WEBPACK_IMPORTED_MODULE_2__.readVarUint8Array(decoder), transactionOrigin)
  } catch (error) {
    // This catches errors that are thrown by event handlers
    console.error('Caught error while handling a Yjs update', error)
  }
}

/**
 * @param {encoding.Encoder} encoder
 * @param {Uint8Array} update
 */
const writeUpdate = (encoder, update) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint(encoder, messageYjsUpdate)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint8Array(encoder, update)
}

/**
 * Read and apply Structs and then DeleteStore to a y instance.
 *
 * @param {decoding.Decoder} decoder
 * @param {Y.Doc} doc
 * @param {any} transactionOrigin
 */
const readUpdate = readSyncStep2

/**
 * @param {decoding.Decoder} decoder A message received from another client
 * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.
 * @param {Y.Doc} doc
 * @param {any} transactionOrigin
 */
const readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {
  const messageType = lib0_decoding__WEBPACK_IMPORTED_MODULE_2__.readVarUint(decoder)
  switch (messageType) {
    case messageYjsSyncStep1:
      readSyncStep1(decoder, encoder, doc)
      break
    case messageYjsSyncStep2:
      readSyncStep2(decoder, doc, transactionOrigin)
      break
    case messageYjsUpdate:
      readUpdate(decoder, doc, transactionOrigin)
      break
    default:
      throw new Error('Unknown message type')
  }
  return messageType
}


/***/ }),

/***/ "./node_modules/y-websocket/src/y-websocket.js":
/*!*****************************************************!*\
  !*** ./node_modules/y-websocket/src/y-websocket.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebsocketProvider": () => (/* binding */ WebsocketProvider)
/* harmony export */ });
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/broadcastchannel */ "./node_modules/lib0/broadcastchannel.js");
/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/time */ "./node_modules/lib0/time.js");
/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding */ "./node_modules/lib0/encoding.js");
/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding */ "./node_modules/lib0/decoding.js");
/* harmony import */ var y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! y-protocols/sync */ "./node_modules/y-protocols/sync.js");
/* harmony import */ var y_protocols_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/auth */ "./node_modules/y-protocols/auth.js");
/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! y-protocols/awareness */ "./node_modules/y-protocols/awareness.js");
/* harmony import */ var lib0_mutex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/mutex */ "./node_modules/lib0/mutex.js");
/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/observable */ "./node_modules/lib0/observable.js");
/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/math */ "./node_modules/lib0/math.js");
/* harmony import */ var lib0_url__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/url */ "./node_modules/lib0/url.js");
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
/*
Unlike stated in the LICENSE file, it is not necessary to include the copyright notice and permission notice when you copy code from this file.
*/

/**
 * @module provider/websocket
 */

/* eslint-env browser */

 // eslint-disable-line












const messageSync = 0
const messageQueryAwareness = 3
const messageAwareness = 1
const messageAuth = 2

/**
 *                       encoder,          decoder,          provider,          emitSynced, messageType
 * @type {Array<function(encoding.Encoder, decoding.Decoder, WebsocketProvider, boolean,    number):void>}
 */
const messageHandlers = []

messageHandlers[messageSync] = (encoder, decoder, provider, emitSynced, messageType) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)
  const syncMessageType = y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.readSyncMessage(decoder, encoder, provider.doc, provider)
  if (emitSynced && syncMessageType === y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.messageYjsSyncStep2 && !provider.synced) {
    provider.synced = true
  }
}

messageHandlers[messageQueryAwareness] = (encoder, decoder, provider, emitSynced, messageType) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageAwareness)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())))
}

messageHandlers[messageAwareness] = (encoder, decoder, provider, emitSynced, messageType) => {
  y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.applyAwarenessUpdate(provider.awareness, lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), provider)
}

messageHandlers[messageAuth] = (encoder, decoder, provider, emitSynced, messageType) => {
  y_protocols_auth__WEBPACK_IMPORTED_MODULE_2__.readAuthMessage(decoder, provider.doc, permissionDeniedHandler)
}

const reconnectTimeoutBase = 1200
const maxReconnectTimeout = 2500
// @todo - this should depend on awareness.outdatedTime
const messageReconnectTimeout = 30000

/**
 * @param {WebsocketProvider} provider
 * @param {string} reason
 */
const permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.\n${reason}`)

/**
 * @param {WebsocketProvider} provider
 * @param {Uint8Array} buf
 * @param {boolean} emitSynced
 * @return {encoding.Encoder}
 */
const readMessage = (provider, buf, emitSynced) => {
  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf)
  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
  const messageType = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)
  const messageHandler = provider.messageHandlers[messageType]
  if (/** @type {any} */ (messageHandler)) {
    messageHandler(encoder, decoder, provider, emitSynced, messageType)
  } else {
    console.error('Unable to compute message')
  }
  return encoder
}

/**
 * @param {WebsocketProvider} provider
 */
const setupWS = provider => {
  if (provider.shouldConnect && provider.ws === null) {
    const websocket = new provider._WS(provider.url)
    websocket.binaryType = 'arraybuffer'
    provider.ws = websocket
    provider.wsconnecting = true
    provider.wsconnected = false
    provider.synced = false

    websocket.onmessage = event => {
      provider.wsLastMessageReceived = lib0_time__WEBPACK_IMPORTED_MODULE_6__.getUnixTime()
      const encoder = readMessage(provider, new Uint8Array(event.data), true)
      if (lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.length(encoder) > 1) {
        websocket.send(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
      }
    }
    websocket.onclose = () => {
      provider.ws = null
      provider.wsconnecting = false
      if (provider.wsconnected) {
        provider.wsconnected = false
        provider.synced = false
        // update awareness (all users except local left)
        y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()).filter(client => client !== provider.doc.clientID), provider)
        provider.emit('status', [{
          status: 'disconnected'
        }])
      } else {
        provider.wsUnsuccessfulReconnects++
      }
      // Start with no reconnect timeout and increase timeout by
      // log10(wsUnsuccessfulReconnects).
      // The idea is to increase reconnect timeout slowly and have no reconnect
      // timeout at the beginning (log(1) = 0)
      setTimeout(setupWS, lib0_math__WEBPACK_IMPORTED_MODULE_7__.min(lib0_math__WEBPACK_IMPORTED_MODULE_7__.log10(provider.wsUnsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), provider)
    }
    websocket.onopen = () => {
      provider.wsLastMessageReceived = lib0_time__WEBPACK_IMPORTED_MODULE_6__.getUnixTime()
      provider.wsconnecting = false
      provider.wsconnected = true
      provider.wsUnsuccessfulReconnects = 0
      provider.emit('status', [{
        status: 'connected'
      }])
      // always send sync step 1 when connected
      const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)
      y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.writeSyncStep1(encoder, provider.doc)
      websocket.send(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
      // broadcast local awareness state
      if (provider.awareness.getLocalState() !== null) {
        const encoderAwarenessState = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderAwarenessState, messageAwareness)
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoderAwarenessState, y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.encodeAwarenessUpdate(provider.awareness, [provider.doc.clientID]))
        websocket.send(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderAwarenessState))
      }
    }

    provider.emit('status', [{
      status: 'connecting'
    }])
  }
}

/**
 * @param {WebsocketProvider} provider
 * @param {ArrayBuffer} buf
 */
const broadcastMessage = (provider, buf) => {
  if (provider.wsconnected) {
    /** @type {WebSocket} */ (provider.ws).send(buf)
  }
  if (provider.bcconnected) {
    provider.mux(() => {
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(provider.bcChannel, buf)
    })
  }
}

/**
 * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.
 * The document name is attached to the provided url. I.e. the following example
 * creates a websocket connection to http://localhost:1234/my-document-name
 *
 * @example
 *   import * as Y from 'yjs'
 *   import { WebsocketProvider } from 'y-websocket'
 *   const doc = new Y.Doc()
 *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)
 *
 * @extends {Observable<string>}
 */
class WebsocketProvider extends lib0_observable__WEBPACK_IMPORTED_MODULE_9__.Observable {
  /**
   * @param {string} serverUrl
   * @param {string} roomname
   * @param {Y.Doc} doc
   * @param {object} [opts]
   * @param {boolean} [opts.connect]
   * @param {awarenessProtocol.Awareness} [opts.awareness]
   * @param {Object<string,string>} [opts.params]
   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill
   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds
   */
  constructor (serverUrl, roomname, doc, { connect = true, awareness = new y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.Awareness(doc), params = {}, WebSocketPolyfill = WebSocket, resyncInterval = -1 } = {}) {
    super()
    // ensure that url is always ends with /
    while (serverUrl[serverUrl.length - 1] === '/') {
      serverUrl = serverUrl.slice(0, serverUrl.length - 1)
    }
    const encodedParams = lib0_url__WEBPACK_IMPORTED_MODULE_10__.encodeQueryParams(params)
    this.bcChannel = serverUrl + '/' + roomname
    this.url = serverUrl + '/' + roomname + (encodedParams.length === 0 ? '' : '?' + encodedParams)
    this.roomname = roomname
    this.doc = doc
    this._WS = WebSocketPolyfill
    this.awareness = awareness
    this.wsconnected = false
    this.wsconnecting = false
    this.bcconnected = false
    this.wsUnsuccessfulReconnects = 0
    this.messageHandlers = messageHandlers.slice()
    this.mux = lib0_mutex__WEBPACK_IMPORTED_MODULE_11__.createMutex()
    /**
     * @type {boolean}
     */
    this._synced = false
    /**
     * @type {WebSocket?}
     */
    this.ws = null
    this.wsLastMessageReceived = 0
    /**
     * Whether to connect to other peers or not
     * @type {boolean}
     */
    this.shouldConnect = connect

    /**
     * @type {number}
     */
    this._resyncInterval = 0
    if (resyncInterval > 0) {
      this._resyncInterval = /** @type {any} */ (setInterval(() => {
        if (this.ws) {
          // resend sync step 1
          const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)
          y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.writeSyncStep1(encoder, doc)
          this.ws.send(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
        }
      }, resyncInterval))
    }

    /**
     * @param {ArrayBuffer} data
     */
    this._bcSubscriber = data => {
      this.mux(() => {
        const encoder = readMessage(this, new Uint8Array(data), false)
        if (lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.length(encoder) > 1) {
          lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(this.bcChannel, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
        }
      })
    }
    /**
     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)
     * @param {Uint8Array} update
     * @param {any} origin
     */
    this._updateHandler = (update, origin) => {
      if (origin !== this) {
        const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)
        y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.writeUpdate(encoder, update)
        broadcastMessage(this, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
      }
    }
    this.doc.on('update', this._updateHandler)
    /**
     * @param {any} changed
     * @param {any} origin
     */
    this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {
      const changedClients = added.concat(updated).concat(removed)
      const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageAwareness)
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.encodeAwarenessUpdate(awareness, changedClients))
      broadcastMessage(this, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
    }
    this._beforeUnloadHandler = () => {
      y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload')
    }
    if (typeof window !== 'undefined') {
      window.addEventListener('beforeunload', this._beforeUnloadHandler)
    } else if (typeof process !== 'undefined') {
      process.on('exit', () => this._beforeUnloadHandler)
    }
    awareness.on('update', this._awarenessUpdateHandler)
    this._checkInterval = /** @type {any} */ (setInterval(() => {
      if (this.wsconnected && messageReconnectTimeout < lib0_time__WEBPACK_IMPORTED_MODULE_6__.getUnixTime() - this.wsLastMessageReceived) {
        // no message received in a long time - not even your own awareness
        // updates (which are updated every 15 seconds)
        /** @type {WebSocket} */ (this.ws).close()
      }
    }, messageReconnectTimeout / 10))
    if (connect) {
      this.connect()
    }
  }

  /**
   * @type {boolean}
   */
  get synced () {
    return this._synced
  }

  set synced (state) {
    if (this._synced !== state) {
      this._synced = state
      this.emit('synced', [state])
      this.emit('sync', [state])
    }
  }

  destroy () {
    if (this._resyncInterval !== 0) {
      clearInterval(this._resyncInterval)
    }
    clearInterval(this._checkInterval)
    this.disconnect()
    if (typeof window !== 'undefined') {
      window.removeEventListener('beforeunload', this._beforeUnloadHandler)
    } else if (typeof process !== 'undefined') {
      process.off('exit', () => this._beforeUnloadHandler)
    }
    this.awareness.off('update', this._awarenessUpdateHandler)
    this.doc.off('update', this._updateHandler)
    super.destroy()
  }

  connectBc () {
    if (!this.bcconnected) {
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.subscribe(this.bcChannel, this._bcSubscriber)
      this.bcconnected = true
    }
    // send sync step1 to bc
    this.mux(() => {
      // write sync step 1
      const encoderSync = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderSync, messageSync)
      y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.writeSyncStep1(encoderSync, this.doc)
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(this.bcChannel, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderSync))
      // broadcast local state
      const encoderState = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderState, messageSync)
      y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.writeSyncStep2(encoderState, this.doc)
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(this.bcChannel, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderState))
      // write queryAwareness
      const encoderAwarenessQuery = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderAwarenessQuery, messageQueryAwareness)
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(this.bcChannel, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderAwarenessQuery))
      // broadcast local awareness state
      const encoderAwarenessState = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderAwarenessState, messageAwareness)
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoderAwarenessState, y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]))
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(this.bcChannel, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderAwarenessState))
    })
  }

  disconnectBc () {
    // broadcast message with local awareness state set to null (indicating disconnect)
    const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageAwareness)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID], new Map()))
    broadcastMessage(this, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
    if (this.bcconnected) {
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.unsubscribe(this.bcChannel, this._bcSubscriber)
      this.bcconnected = false
    }
  }

  disconnect () {
    this.shouldConnect = false
    this.disconnectBc()
    if (this.ws !== null) {
      this.ws.close()
    }
  }

  connect () {
    this.shouldConnect = true
    if (!this.wsconnected && this.ws === null) {
      setupWS(this)
      this.connectBc()
    }
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGliMC9icm9hZGNhc3RjaGFubmVsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9saWIwL211dGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9saWIwL3VybC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMveS1wcm90b2NvbHMvYXV0aC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMveS1wcm90b2NvbHMvYXdhcmVuZXNzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy95LXByb3RvY29scy9zeW5jLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy95LXdlYnNvY2tldC9zcmMveS13ZWJzb2NrZXQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFK0I7QUFDTTtBQUNFOztBQUV2QztBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLGNBQWM7QUFDNUIsY0FBYyxJQUFJO0FBQ2xCOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZSxpQkFBaUI7QUFDOUM7QUFDQTtBQUNBLElBQUksaURBQWdCLG1FQUFtRSxPQUFPLGtEQUFpQixv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O0FBQ2hEO0FBQ0EsTUFBTSw4REFBYztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJ2ZW5kb3JzLW5vZGVfbW9kdWxlc195LXdlYnNvY2tldF9zcmNfeS13ZWJzb2NrZXRfanMuMzhjYjI1M2M3OTU3ZjU2ZmFmZDguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBIZWxwZXJzIGZvciBjcm9zcy10YWIgY29tbXVuaWNhdGlvbiB1c2luZyBicm9hZGNhc3RjaGFubmVsIHdpdGggTG9jYWxTdG9yYWdlIGZhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBJbiBicm93c2VyIHdpbmRvdyBBOlxuICogYnJvYWRjYXN0Y2hhbm5lbC5zdWJzY3JpYmUoJ215IGV2ZW50cycsIGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSkpXG4gKiBicm9hZGNhc3RjaGFubmVsLnB1Ymxpc2goJ215IGV2ZW50cycsICdIZWxsbyB3b3JsZCEnKSAvLyA9PiBBOiAnSGVsbG8gd29ybGQhJyBmaXJlcyBzeW5jaHJvbm91c2x5IGluIHNhbWUgdGFiXG4gKlxuICogLy8gSW4gYnJvd3NlciB3aW5kb3cgQjpcbiAqIGJyb2FkY2FzdGNoYW5uZWwucHVibGlzaCgnbXkgZXZlbnRzJywgJ2hlbGxvIGZyb20gdGFiIEInKSAvLyA9PiBBOiAnaGVsbG8gZnJvbSB0YWIgQidcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgYnJvYWRjYXN0Y2hhbm5lbFxuICovXG5cbi8vIEB0b2RvIGJlZm9yZSBuZXh0IG1ham9yOiB1c2UgVWludDhBcnJheSBpbnN0ZWFkIGFzIGJ1ZmZlciBvYmplY3RcblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgYnVmZmVyIGZyb20gJy4vYnVmZmVyLmpzJ1xuaW1wb3J0ICogYXMgc3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2hhbm5lbFxuICogQHByb3BlcnR5IHtTZXQ8RnVuY3Rpb24+fSBDaGFubmVsLnN1YnNcbiAqIEBwcm9wZXJ0eSB7YW55fSBDaGFubmVsLmJjXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7TWFwPHN0cmluZywgQ2hhbm5lbD59XG4gKi9cbmNvbnN0IGNoYW5uZWxzID0gbmV3IE1hcCgpXG5cbmNsYXNzIExvY2FsU3RvcmFnZVBvbHlmaWxsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocm9vbSkge1xuICAgIHRoaXMucm9vbSA9IHJvb21cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbHxmdW5jdGlvbih7ZGF0YTpBcnJheUJ1ZmZlcn0pOnZvaWR9XG4gICAgICovXG4gICAgdGhpcy5vbm1lc3NhZ2UgPSBudWxsXG4gICAgc3RvcmFnZS5vbkNoYW5nZShlID0+IGUua2V5ID09PSByb29tICYmIHRoaXMub25tZXNzYWdlICE9PSBudWxsICYmIHRoaXMub25tZXNzYWdlKHsgZGF0YTogYnVmZmVyLmZyb21CYXNlNjQoZS5uZXdWYWx1ZSB8fCAnJykgfSkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmXG4gICAqL1xuICBwb3N0TWVzc2FnZSAoYnVmKSB7XG4gICAgc3RvcmFnZS52YXJTdG9yYWdlLnNldEl0ZW0odGhpcy5yb29tLCBidWZmZXIudG9CYXNlNjQoYnVmZmVyLmNyZWF0ZVVpbnQ4QXJyYXlGcm9tQXJyYXlCdWZmZXIoYnVmKSkpXG4gIH1cbn1cblxuLy8gVXNlIEJyb2FkY2FzdENoYW5uZWwgb3IgUG9seWZpbGxcbmNvbnN0IEJDID0gdHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgPT09ICd1bmRlZmluZWQnID8gTG9jYWxTdG9yYWdlUG9seWZpbGwgOiBCcm9hZGNhc3RDaGFubmVsXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEByZXR1cm4ge0NoYW5uZWx9XG4gKi9cbmNvbnN0IGdldENoYW5uZWwgPSByb29tID0+XG4gIG1hcC5zZXRJZlVuZGVmaW5lZChjaGFubmVscywgcm9vbSwgKCkgPT4ge1xuICAgIGNvbnN0IHN1YnMgPSBuZXcgU2V0KClcbiAgICBjb25zdCBiYyA9IG5ldyBCQyhyb29tKVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7e2RhdGE6QXJyYXlCdWZmZXJ9fSBlXG4gICAgICovXG4gICAgYmMub25tZXNzYWdlID0gZSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1YihlLmRhdGEpKVxuICAgIHJldHVybiB7XG4gICAgICBiYywgc3Vic1xuICAgIH1cbiAgfSlcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gZ2xvYmFsIGBwdWJsaXNoYCBldmVudHMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3Qgc3Vic2NyaWJlID0gKHJvb20sIGYpID0+IGdldENoYW5uZWwocm9vbSkuc3Vicy5hZGQoZilcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIGBwdWJsaXNoYCBnbG9iYWwgZXZlbnRzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IHVuc3Vic2NyaWJlID0gKHJvb20sIGYpID0+IGdldENoYW5uZWwocm9vbSkuc3Vicy5kZWxldGUoZilcblxuLyoqXG4gKiBQdWJsaXNoIGRhdGEgdG8gYWxsIHN1YnNjcmliZXJzIChpbmNsdWRpbmcgc3Vic2NyaWJlcnMgb24gdGhpcyB0YWIpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHthbnl9IGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IHB1Ymxpc2ggPSAocm9vbSwgZGF0YSkgPT4ge1xuICBjb25zdCBjID0gZ2V0Q2hhbm5lbChyb29tKVxuICBjLmJjLnBvc3RNZXNzYWdlKGRhdGEpXG4gIGMuc3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIoZGF0YSkpXG59XG4iLCIvKipcbiAqIE11dHVhbCBleGNsdWRlIGZvciBKYXZhU2NyaXB0LlxuICpcbiAqIEBtb2R1bGUgbXV0ZXhcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBtdXRleFxuICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IGNiIE9ubHkgZXhlY3V0ZWQgd2hlbiB0aGlzIG11dGV4IGlzIG5vdCBpbiB0aGUgY3VycmVudCBzdGFja1xuICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IFtlbHNlQ2JdIEV4ZWN1dGVkIHdoZW4gdGhpcyBtdXRleCBpcyBpbiB0aGUgY3VycmVudCBzdGFja1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG11dHVhbCBleGNsdWRlIGZ1bmN0aW9uIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0eTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbXV0ZXggPSBjcmVhdGVNdXRleCgpXG4gKiBtdXRleCgoKSA9PiB7XG4gKiAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgaW1tZWRpYXRlbHkgZXhlY3V0ZWRcbiAqICAgbXV0ZXgoKCkgPT4ge1xuICogICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IGV4ZWN1dGVkLCBhcyB0aGUgbXV0ZXggaXMgYWxyZWFkeSBhY3RpdmUuXG4gKiAgIH0pXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHJldHVybiB7bXV0ZXh9IEEgbXV0dWFsIGV4Y2x1ZGUgZnVuY3Rpb25cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU11dGV4ID0gKCkgPT4ge1xuICBsZXQgdG9rZW4gPSB0cnVlXG4gIHJldHVybiAoZiwgZykgPT4ge1xuICAgIGlmICh0b2tlbikge1xuICAgICAgdG9rZW4gPSBmYWxzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZigpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0b2tlbiA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZygpXG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCB1cmxzLlxuICpcbiAqIEBtb2R1bGUgdXJsXG4gKi9cblxuaW1wb3J0ICogYXMgb2JqZWN0IGZyb20gJy4vb2JqZWN0LmpzJ1xuXG4vKipcbiAqIFBhcnNlIHF1ZXJ5IHBhcmFtZXRlcnMgZnJvbSBhbiB1cmwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxzdHJpbmc+fVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlUXVlcnlQYXJhbXMgPSB1cmwgPT4ge1xuICAvKipcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsc3RyaW5nPn1cbiAgICovXG4gIGNvbnN0IHF1ZXJ5ID0ge31cbiAgY29uc3QgdXJsUXVlcnlTcGxpdCA9IHVybC5zcGxpdCgnPycpXG4gIGNvbnN0IHBhaXJzID0gdXJsUXVlcnlTcGxpdFt1cmxRdWVyeVNwbGl0Lmxlbmd0aCAtIDFdLnNwbGl0KCcmJylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGl0ZW0gPSBwYWlyc1tpXVxuICAgIGlmIChpdGVtLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHBhaXIgPSBpdGVtLnNwbGl0KCc9JylcbiAgICAgIHF1ZXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSB8fCAnJylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLHN0cmluZz59IHBhcmFtc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlUXVlcnlQYXJhbXMgPSBwYXJhbXMgPT5cbiAgb2JqZWN0Lm1hcChwYXJhbXMsICh2YWwsIGtleSkgPT4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbCl9YCkuam9pbignJicpXG4iLCJcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcblxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VQZXJtaXNzaW9uRGVuaWVkID0gMFxuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVQZXJtaXNzaW9uRGVuaWVkID0gKGVuY29kZXIsIHJlYXNvbikgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVBlcm1pc3Npb25EZW5pZWQpXG4gIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHJlYXNvbilcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgUGVybWlzc2lvbkRlbmllZEhhbmRsZXJcbiAqIEBwYXJhbSB7YW55fSB5XG4gKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSB5XG4gKiBAcGFyYW0ge1Blcm1pc3Npb25EZW5pZWRIYW5kbGVyfSBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEF1dGhNZXNzYWdlID0gKGRlY29kZXIsIHksIHBlcm1pc3Npb25EZW5pZWRIYW5kbGVyKSA9PiB7XG4gIHN3aXRjaCAoZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikpIHtcbiAgICBjYXNlIG1lc3NhZ2VQZXJtaXNzaW9uRGVuaWVkOiBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlcih5LCBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpKVxuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgYXdhcmVuZXNzLXByb3RvY29sXG4gKi9cblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJ2xpYjAvdGltZSdcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcbmltcG9ydCAqIGFzIGYgZnJvbSAnbGliMC9mdW5jdGlvbidcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmV4cG9ydCBjb25zdCBvdXRkYXRlZFRpbWVvdXQgPSAzMDAwMFxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFDbGllbnRTdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5jbG9ja1xuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5sYXN0VXBkYXRlZCB1bml4IHRpbWVzdGFtcFxuICovXG5cbi8qKlxuICogVGhlIEF3YXJlbmVzcyBjbGFzcyBpbXBsZW1lbnRzIGEgc2ltcGxlIHNoYXJlZCBzdGF0ZSBwcm90b2NvbCB0aGF0IGNhbiBiZSB1c2VkIGZvciBub24tcGVyc2lzdGVudCBkYXRhIGxpa2UgYXdhcmVuZXNzIGluZm9ybWF0aW9uXG4gKiAoY3Vyc29yLCB1c2VybmFtZSwgc3RhdHVzLCAuLikuIEVhY2ggY2xpZW50IGNhbiB1cGRhdGUgaXRzIG93biBsb2NhbCBzdGF0ZSBhbmQgbGlzdGVuIHRvIHN0YXRlIGNoYW5nZXMgb2ZcbiAqIHJlbW90ZSBjbGllbnRzLiBFdmVyeSBjbGllbnQgbWF5IHNldCBhIHN0YXRlIG9mIGEgcmVtb3RlIHBlZXIgdG8gYG51bGxgIHRvIG1hcmsgdGhlIGNsaWVudCBhcyBvZmZsaW5lLlxuICpcbiAqIEVhY2ggY2xpZW50IGlzIGlkZW50aWZpZWQgYnkgYSB1bmlxdWUgY2xpZW50IGlkIChzb21ldGhpbmcgd2UgYm9ycm93IGZyb20gYGRvYy5jbGllbnRJRGApLiBBIGNsaWVudCBjYW4gb3ZlcnJpZGVcbiAqIGl0cyBvd24gc3RhdGUgYnkgcHJvcGFnYXRpbmcgYSBtZXNzYWdlIHdpdGggYW4gaW5jcmVhc2luZyB0aW1lc3RhbXAgKGBjbG9ja2ApLiBJZiBzdWNoIGEgbWVzc2FnZSBpcyByZWNlaXZlZCwgaXQgaXNcbiAqIGFwcGxpZWQgaWYgdGhlIGtub3duIHN0YXRlIG9mIHRoYXQgY2xpZW50IGlzIG9sZGVyIHRoYW4gdGhlIG5ldyBzdGF0ZSAoYGNsb2NrIDwgbmV3Q2xvY2tgKS4gSWYgYSBjbGllbnQgdGhpbmtzIHRoYXRcbiAqIGEgcmVtb3RlIGNsaWVudCBpcyBvZmZsaW5lLCBpdCBtYXkgcHJvcGFnYXRlIGEgbWVzc2FnZSB3aXRoXG4gKiBgeyBjbG9jazogY3VycmVudENsaWVudENsb2NrLCBzdGF0ZTogbnVsbCwgY2xpZW50OiByZW1vdGVDbGllbnQgfWAuIElmIHN1Y2ggYVxuICogbWVzc2FnZSBpcyByZWNlaXZlZCwgYW5kIHRoZSBrbm93biBjbG9jayBvZiB0aGF0IGNsaWVudCBlcXVhbHMgdGhlIHJlY2VpdmVkIGNsb2NrLCBpdCB3aWxsIG92ZXJyaWRlIHRoZSBzdGF0ZSB3aXRoIGBudWxsYC5cbiAqXG4gKiBCZWZvcmUgYSBjbGllbnQgZGlzY29ubmVjdHMsIGl0IHNob3VsZCBwcm9wYWdhdGUgYSBgbnVsbGAgc3RhdGUgd2l0aCBhbiB1cGRhdGVkIGNsb2NrLlxuICpcbiAqIEF3YXJlbmVzcyBzdGF0ZXMgbXVzdCBiZSB1cGRhdGVkIGV2ZXJ5IDMwIHNlY29uZHMuIE90aGVyd2lzZSB0aGUgQXdhcmVuZXNzIGluc3RhbmNlIHdpbGwgZGVsZXRlIHRoZSBjbGllbnQgc3RhdGUuXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNsYXNzIEF3YXJlbmVzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudElEID0gZG9jLmNsaWVudElEXG4gICAgLyoqXG4gICAgICogTWFwcyBmcm9tIGNsaWVudCBpZCB0byBjbGllbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgT2JqZWN0PHN0cmluZywgYW55Pj59XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgTWV0YUNsaWVudFN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9jaGVja0ludGVydmFsID0gLyoqIEB0eXBlIHthbnl9ICovIChzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIGlmICh0aGlzLmdldExvY2FsU3RhdGUoKSAhPT0gbnVsbCAmJiAob3V0ZGF0ZWRUaW1lb3V0IC8gMiA8PSBub3cgLSAvKiogQHR5cGUge3tsYXN0VXBkYXRlZDpudW1iZXJ9fSAqLyAodGhpcy5tZXRhLmdldCh0aGlzLmNsaWVudElEKSkubGFzdFVwZGF0ZWQpKSB7XG4gICAgICAgIC8vIHJlbmV3IGxvY2FsIGNsb2NrXG4gICAgICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh0aGlzLmdldExvY2FsU3RhdGUoKSlcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHJlbW92ZSA9IFtdXG4gICAgICB0aGlzLm1ldGEuZm9yRWFjaCgobWV0YSwgY2xpZW50aWQpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudGlkICE9PSB0aGlzLmNsaWVudElEICYmIG91dGRhdGVkVGltZW91dCA8PSBub3cgLSBtZXRhLmxhc3RVcGRhdGVkICYmIHRoaXMuc3RhdGVzLmhhcyhjbGllbnRpZCkpIHtcbiAgICAgICAgICByZW1vdmUucHVzaChjbGllbnRpZClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlmIChyZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICByZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcywgcmVtb3ZlLCAndGltZW91dCcpXG4gICAgICB9XG4gICAgfSwgbWF0aC5mbG9vcihvdXRkYXRlZFRpbWVvdXQgLyAxMCkpKVxuICAgIGRvYy5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgfSlcbiAgICB0aGlzLnNldExvY2FsU3RhdGUoe30pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knLCBbdGhpc10pXG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKG51bGwpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja0ludGVydmFsKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudWxsfVxuICAgKi9cbiAgZ2V0TG9jYWxTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzLmdldCh0aGlzLmNsaWVudElEKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH0gc3RhdGVcbiAgICovXG4gIHNldExvY2FsU3RhdGUgKHN0YXRlKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSB0aGlzLmNsaWVudElEXG4gICAgY29uc3QgY3VyckxvY2FsTWV0YSA9IHRoaXMubWV0YS5nZXQoY2xpZW50SUQpXG4gICAgY29uc3QgY2xvY2sgPSBjdXJyTG9jYWxNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY3VyckxvY2FsTWV0YS5jbG9jayArIDFcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0YXRlcy5nZXQoY2xpZW50SUQpXG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpXG4gICAgfVxuICAgIHRoaXMubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgIGNsb2NrLFxuICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgIH0pXG4gICAgY29uc3QgYWRkZWQgPSBbXVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBbXVxuICAgIGNvbnN0IGZpbHRlcmVkVXBkYXRlZCA9IFtdXG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgfSBlbHNlIGlmIChwcmV2U3RhdGUgPT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgYWRkZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgaWYgKCFmLmVxdWFsaXR5RGVlcChwcmV2U3RhdGUsIHN0YXRlKSkge1xuICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgZmlsdGVyZWRVcGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIFt7IGFkZGVkLCB1cGRhdGVkOiBmaWx0ZXJlZFVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pXG4gICAgfVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKi9cbiAgc2V0TG9jYWxTdGF0ZUZpZWxkIChmaWVsZCwgdmFsdWUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0TG9jYWxTdGF0ZSgpXG4gICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnNldExvY2FsU3RhdGUoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW2ZpZWxkXTogdmFsdWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge01hcDxudW1iZXIsT2JqZWN0PHN0cmluZyxhbnk+Pn1cbiAgICovXG4gIGdldFN0YXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzXG4gIH1cbn1cblxuLyoqXG4gKiBNYXJrIChyZW1vdGUpIGNsaWVudHMgYXMgaW5hY3RpdmUgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIHBlZXJzLlxuICogVGhpcyBjaGFuZ2Ugd2lsbCBiZSBwcm9wYWdhdGVkIHRvIHJlbW90ZSBjbGllbnRzLlxuICpcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xpZW50c1xuICogQHBhcmFtIHthbnl9IG9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzID0gKGF3YXJlbmVzcywgY2xpZW50cywgb3JpZ2luKSA9PiB7XG4gIGNvbnN0IHJlbW92ZWQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV1cbiAgICBpZiAoYXdhcmVuZXNzLnN0YXRlcy5oYXMoY2xpZW50SUQpKSB7XG4gICAgICBhd2FyZW5lc3Muc3RhdGVzLmRlbGV0ZShjbGllbnRJRClcbiAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEKSB7XG4gICAgICAgIGNvbnN0IGN1ck1ldGEgPSAvKiogQHR5cGUge01ldGFDbGllbnRTdGF0ZX0gKi8gKGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRCkpXG4gICAgICAgIGF3YXJlbmVzcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgICAgIGNsb2NrOiBjdXJNZXRhLmNsb2NrICsgMSxcbiAgICAgICAgICBsYXN0VXBkYXRlZDogdGltZS5nZXRVbml4VGltZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKVxuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbeyBhZGRlZDogW10sIHVwZGF0ZWQ6IFtdLCByZW1vdmVkIH0sIG9yaWdpbl0pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVBd2FyZW5lc3NVcGRhdGUgPSAoYXdhcmVuZXNzLCBjbGllbnRzLCBzdGF0ZXMgPSBhd2FyZW5lc3Muc3RhdGVzKSA9PiB7XG4gIGNvbnN0IGxlbiA9IGNsaWVudHMubGVuZ3RoXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gY2xpZW50c1tpXVxuICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldChjbGllbnRJRCkgfHwgbnVsbFxuICAgIGNvbnN0IGNsb2NrID0gLyoqIEB0eXBlIHtNZXRhQ2xpZW50U3RhdGV9ICovIChhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpKS5jbG9ja1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbGllbnRJRClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKVxuICB9XG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBNb2RpZnkgdGhlIGNvbnRlbnQgb2YgYW4gYXdhcmVuZXNzIHVwZGF0ZSBiZWZvcmUgcmUtZW5jb2RpbmcgaXQgdG8gYW4gYXdhcmVuZXNzIHVwZGF0ZS5cbiAqXG4gKiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIGEgY2VudHJhbCBzZXJ2ZXIgdGhhdCB3YW50cyB0byBlbnN1cmUgdGhhdCBjbGllbnRzXG4gKiBjYW50IGhpamFjayBzb21lYm9keSBlbHNlcyBpZGVudGl0eS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOmFueX0gbW9kaWZ5XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgbW9kaWZ5QXdhcmVuZXNzVXBkYXRlID0gKHVwZGF0ZSwgbW9kaWZ5KSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSlcbiAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGNvbnN0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgICBjb25zdCBtb2RpZmllZFN0YXRlID0gbW9kaWZ5KHN0YXRlKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbGllbnRJRClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgSlNPTi5zdHJpbmdpZnkobW9kaWZpZWRTdGF0ZSkpXG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gb3JpZ2luIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgZW1pdHRlZCBjaGFuZ2UgZXZlbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5QXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgdXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKVxuICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgY29uc3QgYWRkZWQgPSBbXVxuICBjb25zdCB1cGRhdGVkID0gW11cbiAgY29uc3QgZmlsdGVyZWRVcGRhdGVkID0gW11cbiAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gIGNvbnN0IGxlbiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgbGV0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgICBjb25zdCBjbGllbnRNZXRhID0gYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IHByZXZTdGF0ZSA9IGF3YXJlbmVzcy5zdGF0ZXMuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IGN1cnJDbG9jayA9IGNsaWVudE1ldGEgPT09IHVuZGVmaW5lZCA/IDAgOiBjbGllbnRNZXRhLmNsb2NrXG4gICAgaWYgKGN1cnJDbG9jayA8IGNsb2NrIHx8IChjdXJyQ2xvY2sgPT09IGNsb2NrICYmIHN0YXRlID09PSBudWxsICYmIGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBuZXZlciBsZXQgYSByZW1vdGUgY2xpZW50IHJlbW92ZSB0aGlzIGxvY2FsIHN0YXRlXG4gICAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEICYmIGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIHJlbW90ZSBjbGllbnQgcmVtb3ZlZCB0aGUgbG9jYWwgc3RhdGUuIERvIG5vdCByZW1vdGUgc3RhdGUuIEJyb2FkY2FzdCBhIG1lc3NhZ2UgaW5kaWNhdGluZ1xuICAgICAgICAgIC8vIHRoYXQgdGhpcyBjbGllbnQgc3RpbGwgZXhpc3RzIGJ5IGluY3JlYXNpbmcgdGhlIGNsb2NrXG4gICAgICAgICAgY2xvY2srK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FyZW5lc3Muc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpXG4gICAgICB9XG4gICAgICBhd2FyZW5lc3MubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgICAgY2xvY2ssXG4gICAgICAgIGxhc3RVcGRhdGVkOiB0aW1lc3RhbXBcbiAgICAgIH0pXG4gICAgICBpZiAoY2xpZW50TWV0YSA9PT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9IGVsc2UgaWYgKGNsaWVudE1ldGEgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghZi5lcXVhbGl0eURlZXAoc3RhdGUsIHByZXZTdGF0ZSkpIHtcbiAgICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IGZpbHRlcmVkVXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCdjaGFuZ2UnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQ6IGZpbHRlcmVkVXBkYXRlZCwgcmVtb3ZlZFxuICAgIH0sIG9yaWdpbl0pXG4gIH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgdXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKVxuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgc3luYy1wcm90b2NvbFxuICovXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5cbi8qKlxuICogQHR5cGVkZWYge01hcDxudW1iZXIsIG51bWJlcj59IFN0YXRlTWFwXG4gKi9cblxuLyoqXG4gKiBDb3JlIFlqcyBkZWZpbmVzIHR3byBtZXNzYWdlIHR5cGVzOlxuICog4oCiIFlqc1N5bmNTdGVwMTogSW5jbHVkZXMgdGhlIFN0YXRlIFNldCBvZiB0aGUgc2VuZGluZyBjbGllbnQuIFdoZW4gcmVjZWl2ZWQsIHRoZSBjbGllbnQgc2hvdWxkIHJlcGx5IHdpdGggWWpzU3luY1N0ZXAyLlxuICog4oCiIFlqc1N5bmNTdGVwMjogSW5jbHVkZXMgYWxsIG1pc3Npbmcgc3RydWN0cyBhbmQgdGhlIGNvbXBsZXRlIGRlbGV0ZSBzZXQuIFdoZW4gcmVjZWl2ZWQsIHRoZSBjbGllbnQgaXMgYXNzdXJlZCB0aGF0IGl0XG4gKiAgIHJlY2VpdmVkIGFsbCBpbmZvcm1hdGlvbiBmcm9tIHRoZSByZW1vdGUgY2xpZW50LlxuICpcbiAqIEluIGEgcGVlci10by1wZWVyIG5ldHdvcmssIHlvdSBtYXkgd2FudCB0byBpbnRyb2R1Y2UgYSBTeW5jRG9uZSBtZXNzYWdlIHR5cGUuIEJvdGggcGFydGllcyBzaG91bGQgaW5pdGlhdGUgdGhlIGNvbm5lY3Rpb25cbiAqIHdpdGggU3luY1N0ZXAxLiBXaGVuIGEgY2xpZW50IHJlY2VpdmVkIFN5bmNTdGVwMiwgaXQgc2hvdWxkIHJlcGx5IHdpdGggU3luY0RvbmUuIFdoZW4gdGhlIGxvY2FsIGNsaWVudCByZWNlaXZlZCBib3RoXG4gKiBTeW5jU3RlcDIgYW5kIFN5bmNEb25lLCBpdCBpcyBhc3N1cmVkIHRoYXQgaXQgaXMgc3luY2VkIHRvIHRoZSByZW1vdGUgY2xpZW50LlxuICpcbiAqIEluIGEgY2xpZW50LXNlcnZlciBtb2RlbCwgeW91IHdhbnQgdG8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHk6IFRoZSBjbGllbnQgc2hvdWxkIGluaXRpYXRlIHRoZSBjb25uZWN0aW9uIHdpdGggU3luY1N0ZXAxLlxuICogV2hlbiB0aGUgc2VydmVyIHJlY2VpdmVzIFN5bmNTdGVwMSwgaXQgc2hvdWxkIHJlcGx5IHdpdGggU3luY1N0ZXAyIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFN5bmNTdGVwMS4gVGhlIGNsaWVudCByZXBsaWVzXG4gKiB3aXRoIFN5bmNTdGVwMiB3aGVuIGl0IHJlY2VpdmVzIFN5bmNTdGVwMS4gT3B0aW9uYWxseSB0aGUgc2VydmVyIG1heSBzZW5kIGEgU3luY0RvbmUgYWZ0ZXIgaXQgcmVjZWl2ZWQgU3luY1N0ZXAyLCBzbyB0aGVcbiAqIGNsaWVudCBrbm93cyB0aGF0IHRoZSBzeW5jIGlzIGZpbmlzaGVkLiAgVGhlcmUgYXJlIHR3byByZWFzb25zIGZvciB0aGlzIG1vcmUgZWxhYm9yYXRlZCBzeW5jIG1vZGVsOiAxLiBUaGlzIHByb3RvY29sIGNhblxuICogZWFzaWx5IGJlIGltcGxlbWVudGVkIG9uIHRvcCBvZiBodHRwIGFuZCB3ZWJzb2NrZXRzLiAyLiBUaGUgc2VydmVyIHNob3VsIG9ubHkgcmVwbHkgdG8gcmVxdWVzdHMsIGFuZCBub3QgaW5pdGlhdGUgdGhlbS5cbiAqIFRoZXJlZm9yZSBpdCBpcyBuZWNlc2FycnkgdGhhdCB0aGUgY2xpZW50IGluaXRpYXRlcyB0aGUgc3luYy5cbiAqXG4gKiBDb25zdHJ1Y3Rpb24gb2YgYSBtZXNzYWdlOlxuICogW21lc3NhZ2VUeXBlIDogdmFyVWludCwgbWVzc2FnZSBkZWZpbml0aW9uLi5dXG4gKlxuICogTm90ZTogQSBtZXNzYWdlIGRvZXMgbm90IGluY2x1ZGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb20gbmFtZS4gVGhpcyBtdXN0IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHVwcGVyIGxheWVyIHByb3RvY29sIVxuICpcbiAqIHN0cmluZ2lmeVttZXNzYWdlVHlwZV0gc3RyaW5naWZpZXMgYSBtZXNzYWdlIGRlZmluaXRpb24gKG1lc3NhZ2VUeXBlIGlzIGFscmVhZHkgcmVhZCBmcm9tIHRoZSBidWZmZmVyKVxuICovXG5cbmV4cG9ydCBjb25zdCBtZXNzYWdlWWpzU3luY1N0ZXAxID0gMFxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VZanNTeW5jU3RlcDIgPSAxXG5leHBvcnQgY29uc3QgbWVzc2FnZVlqc1VwZGF0ZSA9IDJcblxuLyoqXG4gKiBDcmVhdGUgYSBzeW5jIHN0ZXAgMSBtZXNzYWdlIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBzaGFyZWQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlU3luY1N0ZXAxID0gKGVuY29kZXIsIGRvYykgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVlqc1N5bmNTdGVwMSlcbiAgY29uc3Qgc3YgPSBZLmVuY29kZVN0YXRlVmVjdG9yKGRvYylcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHN2KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkU3RhdGVWZWN0b3JdXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVN5bmNTdGVwMiA9IChlbmNvZGVyLCBkb2MsIGVuY29kZWRTdGF0ZVZlY3RvcikgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVlqc1N5bmNTdGVwMilcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIFkuZW5jb2RlU3RhdGVBc1VwZGF0ZShkb2MsIGVuY29kZWRTdGF0ZVZlY3RvcikpXG59XG5cbi8qKlxuICogUmVhZCBTeW5jU3RlcDEgbWVzc2FnZSBhbmQgcmVwbHkgd2l0aCBTeW5jU3RlcDIuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyIFRoZSByZXBseSB0byB0aGUgcmVjZWl2ZWQgbWVzc2FnZVxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyIFRoZSByZWNlaXZlZCBtZXNzYWdlXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRTeW5jU3RlcDEgPSAoZGVjb2RlciwgZW5jb2RlciwgZG9jKSA9PlxuICB3cml0ZVN5bmNTdGVwMihlbmNvZGVyLCBkb2MsIGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IFN0cnVjdHMgYW5kIHRoZW4gRGVsZXRlU3RvcmUgdG8gYSB5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRTeW5jU3RlcDIgPSAoZGVjb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4ge1xuICB0cnkge1xuICAgIFkuYXBwbHlVcGRhdGUoZG9jLCBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgdHJhbnNhY3Rpb25PcmlnaW4pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyB0aGF0IGFyZSB0aHJvd24gYnkgZXZlbnQgaGFuZGxlcnNcbiAgICBjb25zb2xlLmVycm9yKCdDYXVnaHQgZXJyb3Igd2hpbGUgaGFuZGxpbmcgYSBZanMgdXBkYXRlJywgZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVwZGF0ZSA9IChlbmNvZGVyLCB1cGRhdGUpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VZanNVcGRhdGUpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB1cGRhdGUpXG59XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVhZFVwZGF0ZSA9IHJlYWRTeW5jU3RlcDJcblxuLyoqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgQSBtZXNzYWdlIHJlY2VpdmVkIGZyb20gYW5vdGhlciBjbGllbnRcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlciBUaGUgcmVwbHkgbWVzc2FnZS4gV2lsbCBub3QgYmUgc2VudCBpZiBlbXB0eS5cbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHthbnl9IHRyYW5zYWN0aW9uT3JpZ2luXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkU3luY01lc3NhZ2UgPSAoZGVjb2RlciwgZW5jb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4ge1xuICBjb25zdCBtZXNzYWdlVHlwZSA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gIHN3aXRjaCAobWVzc2FnZVR5cGUpIHtcbiAgICBjYXNlIG1lc3NhZ2VZanNTeW5jU3RlcDE6XG4gICAgICByZWFkU3luY1N0ZXAxKGRlY29kZXIsIGVuY29kZXIsIGRvYylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzU3luY1N0ZXAyOlxuICAgICAgcmVhZFN5bmNTdGVwMihkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIG1lc3NhZ2VZanNVcGRhdGU6XG4gICAgICByZWFkVXBkYXRlKGRlY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSB0eXBlJylcbiAgfVxuICByZXR1cm4gbWVzc2FnZVR5cGVcbn1cbiIsIi8qXG5Vbmxpa2Ugc3RhdGVkIGluIHRoZSBMSUNFTlNFIGZpbGUsIGl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gaW5jbHVkZSB0aGUgY29weXJpZ2h0IG5vdGljZSBhbmQgcGVybWlzc2lvbiBub3RpY2Ugd2hlbiB5b3UgY29weSBjb2RlIGZyb20gdGhpcyBmaWxlLlxuKi9cblxuLyoqXG4gKiBAbW9kdWxlIHByb3ZpZGVyL3dlYnNvY2tldFxuICovXG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgYmMgZnJvbSAnbGliMC9icm9hZGNhc3RjaGFubmVsJ1xuaW1wb3J0ICogYXMgdGltZSBmcm9tICdsaWIwL3RpbWUnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCAqIGFzIHN5bmNQcm90b2NvbCBmcm9tICd5LXByb3RvY29scy9zeW5jJ1xuaW1wb3J0ICogYXMgYXV0aFByb3RvY29sIGZyb20gJ3ktcHJvdG9jb2xzL2F1dGgnXG5pbXBvcnQgKiBhcyBhd2FyZW5lc3NQcm90b2NvbCBmcm9tICd5LXByb3RvY29scy9hd2FyZW5lc3MnXG5pbXBvcnQgKiBhcyBtdXRleCBmcm9tICdsaWIwL211dGV4J1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0ICogYXMgdXJsIGZyb20gJ2xpYjAvdXJsJ1xuXG5jb25zdCBtZXNzYWdlU3luYyA9IDBcbmNvbnN0IG1lc3NhZ2VRdWVyeUF3YXJlbmVzcyA9IDNcbmNvbnN0IG1lc3NhZ2VBd2FyZW5lc3MgPSAxXG5jb25zdCBtZXNzYWdlQXV0aCA9IDJcblxuLyoqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlciwgICAgICAgICAgZGVjb2RlciwgICAgICAgICAgcHJvdmlkZXIsICAgICAgICAgIGVtaXRTeW5jZWQsIG1lc3NhZ2VUeXBlXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oZW5jb2RpbmcuRW5jb2RlciwgZGVjb2RpbmcuRGVjb2RlciwgV2Vic29ja2V0UHJvdmlkZXIsIGJvb2xlYW4sICAgIG51bWJlcik6dm9pZD59XG4gKi9cbmNvbnN0IG1lc3NhZ2VIYW5kbGVycyA9IFtdXG5cbm1lc3NhZ2VIYW5kbGVyc1ttZXNzYWdlU3luY10gPSAoZW5jb2RlciwgZGVjb2RlciwgcHJvdmlkZXIsIGVtaXRTeW5jZWQsIG1lc3NhZ2VUeXBlKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlU3luYylcbiAgY29uc3Qgc3luY01lc3NhZ2VUeXBlID0gc3luY1Byb3RvY29sLnJlYWRTeW5jTWVzc2FnZShkZWNvZGVyLCBlbmNvZGVyLCBwcm92aWRlci5kb2MsIHByb3ZpZGVyKVxuICBpZiAoZW1pdFN5bmNlZCAmJiBzeW5jTWVzc2FnZVR5cGUgPT09IHN5bmNQcm90b2NvbC5tZXNzYWdlWWpzU3luY1N0ZXAyICYmICFwcm92aWRlci5zeW5jZWQpIHtcbiAgICBwcm92aWRlci5zeW5jZWQgPSB0cnVlXG4gIH1cbn1cblxubWVzc2FnZUhhbmRsZXJzW21lc3NhZ2VRdWVyeUF3YXJlbmVzc10gPSAoZW5jb2RlciwgZGVjb2RlciwgcHJvdmlkZXIsIGVtaXRTeW5jZWQsIG1lc3NhZ2VUeXBlKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlQXdhcmVuZXNzKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHByb3ZpZGVyLmF3YXJlbmVzcywgQXJyYXkuZnJvbShwcm92aWRlci5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKSkpXG59XG5cbm1lc3NhZ2VIYW5kbGVyc1ttZXNzYWdlQXdhcmVuZXNzXSA9IChlbmNvZGVyLCBkZWNvZGVyLCBwcm92aWRlciwgZW1pdFN5bmNlZCwgbWVzc2FnZVR5cGUpID0+IHtcbiAgYXdhcmVuZXNzUHJvdG9jb2wuYXBwbHlBd2FyZW5lc3NVcGRhdGUocHJvdmlkZXIuYXdhcmVuZXNzLCBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgcHJvdmlkZXIpXG59XG5cbm1lc3NhZ2VIYW5kbGVyc1ttZXNzYWdlQXV0aF0gPSAoZW5jb2RlciwgZGVjb2RlciwgcHJvdmlkZXIsIGVtaXRTeW5jZWQsIG1lc3NhZ2VUeXBlKSA9PiB7XG4gIGF1dGhQcm90b2NvbC5yZWFkQXV0aE1lc3NhZ2UoZGVjb2RlciwgcHJvdmlkZXIuZG9jLCBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlcilcbn1cblxuY29uc3QgcmVjb25uZWN0VGltZW91dEJhc2UgPSAxMjAwXG5jb25zdCBtYXhSZWNvbm5lY3RUaW1lb3V0ID0gMjUwMFxuLy8gQHRvZG8gLSB0aGlzIHNob3VsZCBkZXBlbmQgb24gYXdhcmVuZXNzLm91dGRhdGVkVGltZVxuY29uc3QgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgPSAzMDAwMFxuXG4vKipcbiAqIEBwYXJhbSB7V2Vic29ja2V0UHJvdmlkZXJ9IHByb3ZpZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gKi9cbmNvbnN0IHBlcm1pc3Npb25EZW5pZWRIYW5kbGVyID0gKHByb3ZpZGVyLCByZWFzb24pID0+IGNvbnNvbGUud2FybihgUGVybWlzc2lvbiBkZW5pZWQgdG8gYWNjZXNzICR7cHJvdmlkZXIudXJsfS5cXG4ke3JlYXNvbn1gKVxuXG4vKipcbiAqIEBwYXJhbSB7V2Vic29ja2V0UHJvdmlkZXJ9IHByb3ZpZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHBhcmFtIHtib29sZWFufSBlbWl0U3luY2VkXG4gKiBAcmV0dXJuIHtlbmNvZGluZy5FbmNvZGVyfVxuICovXG5jb25zdCByZWFkTWVzc2FnZSA9IChwcm92aWRlciwgYnVmLCBlbWl0U3luY2VkKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICBjb25zdCBtZXNzYWdlVHlwZSA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gcHJvdmlkZXIubWVzc2FnZUhhbmRsZXJzW21lc3NhZ2VUeXBlXVxuICBpZiAoLyoqIEB0eXBlIHthbnl9ICovIChtZXNzYWdlSGFuZGxlcikpIHtcbiAgICBtZXNzYWdlSGFuZGxlcihlbmNvZGVyLCBkZWNvZGVyLCBwcm92aWRlciwgZW1pdFN5bmNlZCwgbWVzc2FnZVR5cGUpXG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGNvbXB1dGUgbWVzc2FnZScpXG4gIH1cbiAgcmV0dXJuIGVuY29kZXJcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYnNvY2tldFByb3ZpZGVyfSBwcm92aWRlclxuICovXG5jb25zdCBzZXR1cFdTID0gcHJvdmlkZXIgPT4ge1xuICBpZiAocHJvdmlkZXIuc2hvdWxkQ29ubmVjdCAmJiBwcm92aWRlci53cyA9PT0gbnVsbCkge1xuICAgIGNvbnN0IHdlYnNvY2tldCA9IG5ldyBwcm92aWRlci5fV1MocHJvdmlkZXIudXJsKVxuICAgIHdlYnNvY2tldC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgIHByb3ZpZGVyLndzID0gd2Vic29ja2V0XG4gICAgcHJvdmlkZXIud3Njb25uZWN0aW5nID0gdHJ1ZVxuICAgIHByb3ZpZGVyLndzY29ubmVjdGVkID0gZmFsc2VcbiAgICBwcm92aWRlci5zeW5jZWQgPSBmYWxzZVxuXG4gICAgd2Vic29ja2V0Lm9ubWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgIHByb3ZpZGVyLndzTGFzdE1lc3NhZ2VSZWNlaXZlZCA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgY29uc3QgZW5jb2RlciA9IHJlYWRNZXNzYWdlKHByb3ZpZGVyLCBuZXcgVWludDhBcnJheShldmVudC5kYXRhKSwgdHJ1ZSlcbiAgICAgIGlmIChlbmNvZGluZy5sZW5ndGgoZW5jb2RlcikgPiAxKSB7XG4gICAgICAgIHdlYnNvY2tldC5zZW5kKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICAgIH1cbiAgICB9XG4gICAgd2Vic29ja2V0Lm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICBwcm92aWRlci53cyA9IG51bGxcbiAgICAgIHByb3ZpZGVyLndzY29ubmVjdGluZyA9IGZhbHNlXG4gICAgICBpZiAocHJvdmlkZXIud3Njb25uZWN0ZWQpIHtcbiAgICAgICAgcHJvdmlkZXIud3Njb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgICBwcm92aWRlci5zeW5jZWQgPSBmYWxzZVxuICAgICAgICAvLyB1cGRhdGUgYXdhcmVuZXNzIChhbGwgdXNlcnMgZXhjZXB0IGxvY2FsIGxlZnQpXG4gICAgICAgIGF3YXJlbmVzc1Byb3RvY29sLnJlbW92ZUF3YXJlbmVzc1N0YXRlcyhwcm92aWRlci5hd2FyZW5lc3MsIEFycmF5LmZyb20ocHJvdmlkZXIuYXdhcmVuZXNzLmdldFN0YXRlcygpLmtleXMoKSkuZmlsdGVyKGNsaWVudCA9PiBjbGllbnQgIT09IHByb3ZpZGVyLmRvYy5jbGllbnRJRCksIHByb3ZpZGVyKVxuICAgICAgICBwcm92aWRlci5lbWl0KCdzdGF0dXMnLCBbe1xuICAgICAgICAgIHN0YXR1czogJ2Rpc2Nvbm5lY3RlZCdcbiAgICAgICAgfV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm92aWRlci53c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMrK1xuICAgICAgfVxuICAgICAgLy8gU3RhcnQgd2l0aCBubyByZWNvbm5lY3QgdGltZW91dCBhbmQgaW5jcmVhc2UgdGltZW91dCBieVxuICAgICAgLy8gbG9nMTAod3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzKS5cbiAgICAgIC8vIFRoZSBpZGVhIGlzIHRvIGluY3JlYXNlIHJlY29ubmVjdCB0aW1lb3V0IHNsb3dseSBhbmQgaGF2ZSBubyByZWNvbm5lY3RcbiAgICAgIC8vIHRpbWVvdXQgYXQgdGhlIGJlZ2lubmluZyAobG9nKDEpID0gMClcbiAgICAgIHNldFRpbWVvdXQoc2V0dXBXUywgbWF0aC5taW4obWF0aC5sb2cxMChwcm92aWRlci53c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMgKyAxKSAqIHJlY29ubmVjdFRpbWVvdXRCYXNlLCBtYXhSZWNvbm5lY3RUaW1lb3V0KSwgcHJvdmlkZXIpXG4gICAgfVxuICAgIHdlYnNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICBwcm92aWRlci53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIHByb3ZpZGVyLndzY29ubmVjdGluZyA9IGZhbHNlXG4gICAgICBwcm92aWRlci53c2Nvbm5lY3RlZCA9IHRydWVcbiAgICAgIHByb3ZpZGVyLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cyA9IDBcbiAgICAgIHByb3ZpZGVyLmVtaXQoJ3N0YXR1cycsIFt7XG4gICAgICAgIHN0YXR1czogJ2Nvbm5lY3RlZCdcbiAgICAgIH1dKVxuICAgICAgLy8gYWx3YXlzIHNlbmQgc3luYyBzdGVwIDEgd2hlbiBjb25uZWN0ZWRcbiAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlU3luYylcbiAgICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMShlbmNvZGVyLCBwcm92aWRlci5kb2MpXG4gICAgICB3ZWJzb2NrZXQuc2VuZChlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gICAgICAvLyBicm9hZGNhc3QgbG9jYWwgYXdhcmVuZXNzIHN0YXRlXG4gICAgICBpZiAocHJvdmlkZXIuYXdhcmVuZXNzLmdldExvY2FsU3RhdGUoKSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBlbmNvZGVyQXdhcmVuZXNzU3RhdGUgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSwgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHByb3ZpZGVyLmF3YXJlbmVzcywgW3Byb3ZpZGVyLmRvYy5jbGllbnRJRF0pKVxuICAgICAgICB3ZWJzb2NrZXQuc2VuZChlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1N0YXRlKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm92aWRlci5lbWl0KCdzdGF0dXMnLCBbe1xuICAgICAgc3RhdHVzOiAnY29ubmVjdGluZydcbiAgICB9XSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7V2Vic29ja2V0UHJvdmlkZXJ9IHByb3ZpZGVyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZcbiAqL1xuY29uc3QgYnJvYWRjYXN0TWVzc2FnZSA9IChwcm92aWRlciwgYnVmKSA9PiB7XG4gIGlmIChwcm92aWRlci53c2Nvbm5lY3RlZCkge1xuICAgIC8qKiBAdHlwZSB7V2ViU29ja2V0fSAqLyAocHJvdmlkZXIud3MpLnNlbmQoYnVmKVxuICB9XG4gIGlmIChwcm92aWRlci5iY2Nvbm5lY3RlZCkge1xuICAgIHByb3ZpZGVyLm11eCgoKSA9PiB7XG4gICAgICBiYy5wdWJsaXNoKHByb3ZpZGVyLmJjQ2hhbm5lbCwgYnVmKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBXZWJzb2NrZXQgUHJvdmlkZXIgZm9yIFlqcy4gQ3JlYXRlcyBhIHdlYnNvY2tldCBjb25uZWN0aW9uIHRvIHN5bmMgdGhlIHNoYXJlZCBkb2N1bWVudC5cbiAqIFRoZSBkb2N1bWVudCBuYW1lIGlzIGF0dGFjaGVkIHRvIHRoZSBwcm92aWRlZCB1cmwuIEkuZS4gdGhlIGZvbGxvd2luZyBleGFtcGxlXG4gKiBjcmVhdGVzIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gdG8gaHR0cDovL2xvY2FsaG9zdDoxMjM0L215LWRvY3VtZW50LW5hbWVcbiAqXG4gKiBAZXhhbXBsZVxuICogICBpbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbiAqICAgaW1wb3J0IHsgV2Vic29ja2V0UHJvdmlkZXIgfSBmcm9tICd5LXdlYnNvY2tldCdcbiAqICAgY29uc3QgZG9jID0gbmV3IFkuRG9jKClcbiAqICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgV2Vic29ja2V0UHJvdmlkZXIoJ2h0dHA6Ly9sb2NhbGhvc3Q6MTIzNCcsICdteS1kb2N1bWVudC1uYW1lJywgZG9jKVxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPHN0cmluZz59XG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJzb2NrZXRQcm92aWRlciBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclVybFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vbW5hbWVcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5jb25uZWN0XVxuICAgKiBAcGFyYW0ge2F3YXJlbmVzc1Byb3RvY29sLkF3YXJlbmVzc30gW29wdHMuYXdhcmVuZXNzXVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsc3RyaW5nPn0gW29wdHMucGFyYW1zXVxuICAgKiBAcGFyYW0ge3R5cGVvZiBXZWJTb2NrZXR9IFtvcHRzLldlYlNvY2tldFBvbHlmaWxsXSBPcHRpb25hbGwgcHJvdmlkZSBhIFdlYlNvY2tldCBwb2x5ZmlsbFxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMucmVzeW5jSW50ZXJ2YWxdIFJlcXVlc3Qgc2VydmVyIHN0YXRlIGV2ZXJ5IGByZXN5bmNJbnRlcnZhbGAgbWlsbGlzZWNvbmRzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc2VydmVyVXJsLCByb29tbmFtZSwgZG9jLCB7IGNvbm5lY3QgPSB0cnVlLCBhd2FyZW5lc3MgPSBuZXcgYXdhcmVuZXNzUHJvdG9jb2wuQXdhcmVuZXNzKGRvYyksIHBhcmFtcyA9IHt9LCBXZWJTb2NrZXRQb2x5ZmlsbCA9IFdlYlNvY2tldCwgcmVzeW5jSW50ZXJ2YWwgPSAtMSB9ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgLy8gZW5zdXJlIHRoYXQgdXJsIGlzIGFsd2F5cyBlbmRzIHdpdGggL1xuICAgIHdoaWxlIChzZXJ2ZXJVcmxbc2VydmVyVXJsLmxlbmd0aCAtIDFdID09PSAnLycpIHtcbiAgICAgIHNlcnZlclVybCA9IHNlcnZlclVybC5zbGljZSgwLCBzZXJ2ZXJVcmwubGVuZ3RoIC0gMSlcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlZFBhcmFtcyA9IHVybC5lbmNvZGVRdWVyeVBhcmFtcyhwYXJhbXMpXG4gICAgdGhpcy5iY0NoYW5uZWwgPSBzZXJ2ZXJVcmwgKyAnLycgKyByb29tbmFtZVxuICAgIHRoaXMudXJsID0gc2VydmVyVXJsICsgJy8nICsgcm9vbW5hbWUgKyAoZW5jb2RlZFBhcmFtcy5sZW5ndGggPT09IDAgPyAnJyA6ICc/JyArIGVuY29kZWRQYXJhbXMpXG4gICAgdGhpcy5yb29tbmFtZSA9IHJvb21uYW1lXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICB0aGlzLl9XUyA9IFdlYlNvY2tldFBvbHlmaWxsXG4gICAgdGhpcy5hd2FyZW5lc3MgPSBhd2FyZW5lc3NcbiAgICB0aGlzLndzY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLndzY29ubmVjdGluZyA9IGZhbHNlXG4gICAgdGhpcy5iY2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy53c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMgPSAwXG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMgPSBtZXNzYWdlSGFuZGxlcnMuc2xpY2UoKVxuICAgIHRoaXMubXV4ID0gbXV0ZXguY3JlYXRlTXV0ZXgoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX3N5bmNlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQHR5cGUge1dlYlNvY2tldD99XG4gICAgICovXG4gICAgdGhpcy53cyA9IG51bGxcbiAgICB0aGlzLndzTGFzdE1lc3NhZ2VSZWNlaXZlZCA9IDBcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGNvbm5lY3QgdG8gb3RoZXIgcGVlcnMgb3Igbm90XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gY29ubmVjdFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9yZXN5bmNJbnRlcnZhbCA9IDBcbiAgICBpZiAocmVzeW5jSW50ZXJ2YWwgPiAwKSB7XG4gICAgICB0aGlzLl9yZXN5bmNJbnRlcnZhbCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgIC8vIHJlc2VuZCBzeW5jIHN0ZXAgMVxuICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gICAgICAgICAgc3luY1Byb3RvY29sLndyaXRlU3luY1N0ZXAxKGVuY29kZXIsIGRvYylcbiAgICAgICAgICB0aGlzLndzLnNlbmQoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgICAgICB9XG4gICAgICB9LCByZXN5bmNJbnRlcnZhbCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMuX2JjU3Vic2NyaWJlciA9IGRhdGEgPT4ge1xuICAgICAgdGhpcy5tdXgoKCkgPT4ge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gcmVhZE1lc3NhZ2UodGhpcywgbmV3IFVpbnQ4QXJyYXkoZGF0YSksIGZhbHNlKVxuICAgICAgICBpZiAoZW5jb2RpbmcubGVuZ3RoKGVuY29kZXIpID4gMSkge1xuICAgICAgICAgIGJjLnB1Ymxpc2godGhpcy5iY0NoYW5uZWwsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdGVucyB0byBZanMgdXBkYXRlcyBhbmQgc2VuZHMgdGhlbSB0byByZW1vdGUgcGVlcnMgKHdzIGFuZCBicm9hZGNhc3RjaGFubmVsKVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gICAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgICAqL1xuICAgIHRoaXMuX3VwZGF0ZUhhbmRsZXIgPSAodXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgICAgIGlmIChvcmlnaW4gIT09IHRoaXMpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gICAgICAgIHN5bmNQcm90b2NvbC53cml0ZVVwZGF0ZShlbmNvZGVyLCB1cGRhdGUpXG4gICAgICAgIGJyb2FkY2FzdE1lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRvYy5vbigndXBkYXRlJywgdGhpcy5fdXBkYXRlSGFuZGxlcilcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICAgKi9cbiAgICB0aGlzLl9hd2FyZW5lc3NVcGRhdGVIYW5kbGVyID0gKHsgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgb3JpZ2luKSA9PiB7XG4gICAgICBjb25zdCBjaGFuZ2VkQ2xpZW50cyA9IGFkZGVkLmNvbmNhdCh1cGRhdGVkKS5jb25jYXQocmVtb3ZlZClcbiAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZShhd2FyZW5lc3MsIGNoYW5nZWRDbGllbnRzKSlcbiAgICAgIGJyb2FkY2FzdE1lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgIH1cbiAgICB0aGlzLl9iZWZvcmVVbmxvYWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgYXdhcmVuZXNzUHJvdG9jb2wucmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHRoaXMuYXdhcmVuZXNzLCBbZG9jLmNsaWVudElEXSwgJ3dpbmRvdyB1bmxvYWQnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLl9iZWZvcmVVbmxvYWRIYW5kbGVyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwcm9jZXNzLm9uKCdleGl0JywgKCkgPT4gdGhpcy5fYmVmb3JlVW5sb2FkSGFuZGxlcilcbiAgICB9XG4gICAgYXdhcmVuZXNzLm9uKCd1cGRhdGUnLCB0aGlzLl9hd2FyZW5lc3NVcGRhdGVIYW5kbGVyKVxuICAgIHRoaXMuX2NoZWNrSW50ZXJ2YWwgPSAvKiogQHR5cGUge2FueX0gKi8gKHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLndzY29ubmVjdGVkICYmIG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IDwgdGltZS5nZXRVbml4VGltZSgpIC0gdGhpcy53c0xhc3RNZXNzYWdlUmVjZWl2ZWQpIHtcbiAgICAgICAgLy8gbm8gbWVzc2FnZSByZWNlaXZlZCBpbiBhIGxvbmcgdGltZSAtIG5vdCBldmVuIHlvdXIgb3duIGF3YXJlbmVzc1xuICAgICAgICAvLyB1cGRhdGVzICh3aGljaCBhcmUgdXBkYXRlZCBldmVyeSAxNSBzZWNvbmRzKVxuICAgICAgICAvKiogQHR5cGUge1dlYlNvY2tldH0gKi8gKHRoaXMud3MpLmNsb3NlKClcbiAgICAgIH1cbiAgICB9LCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCAvIDEwKSlcbiAgICBpZiAoY29ubmVjdCkge1xuICAgICAgdGhpcy5jb25uZWN0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc3luY2VkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY2VkXG4gIH1cblxuICBzZXQgc3luY2VkIChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9zeW5jZWQgIT09IHN0YXRlKSB7XG4gICAgICB0aGlzLl9zeW5jZWQgPSBzdGF0ZVxuICAgICAgdGhpcy5lbWl0KCdzeW5jZWQnLCBbc3RhdGVdKVxuICAgICAgdGhpcy5lbWl0KCdzeW5jJywgW3N0YXRlXSlcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5fcmVzeW5jSW50ZXJ2YWwgIT09IDApIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcmVzeW5jSW50ZXJ2YWwpXG4gICAgfVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tJbnRlcnZhbClcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMuX2JlZm9yZVVubG9hZEhhbmRsZXIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHByb2Nlc3Mub2ZmKCdleGl0JywgKCkgPT4gdGhpcy5fYmVmb3JlVW5sb2FkSGFuZGxlcilcbiAgICB9XG4gICAgdGhpcy5hd2FyZW5lc3Mub2ZmKCd1cGRhdGUnLCB0aGlzLl9hd2FyZW5lc3NVcGRhdGVIYW5kbGVyKVxuICAgIHRoaXMuZG9jLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlSGFuZGxlcilcbiAgICBzdXBlci5kZXN0cm95KClcbiAgfVxuXG4gIGNvbm5lY3RCYyAoKSB7XG4gICAgaWYgKCF0aGlzLmJjY29ubmVjdGVkKSB7XG4gICAgICBiYy5zdWJzY3JpYmUodGhpcy5iY0NoYW5uZWwsIHRoaXMuX2JjU3Vic2NyaWJlcilcbiAgICAgIHRoaXMuYmNjb25uZWN0ZWQgPSB0cnVlXG4gICAgfVxuICAgIC8vIHNlbmQgc3luYyBzdGVwMSB0byBiY1xuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIC8vIHdyaXRlIHN5bmMgc3RlcCAxXG4gICAgICBjb25zdCBlbmNvZGVyU3luYyA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJTeW5jLCBtZXNzYWdlU3luYylcbiAgICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMShlbmNvZGVyU3luYywgdGhpcy5kb2MpXG4gICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlclN5bmMpKVxuICAgICAgLy8gYnJvYWRjYXN0IGxvY2FsIHN0YXRlXG4gICAgICBjb25zdCBlbmNvZGVyU3RhdGUgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyU3RhdGUsIG1lc3NhZ2VTeW5jKVxuICAgICAgc3luY1Byb3RvY29sLndyaXRlU3luY1N0ZXAyKGVuY29kZXJTdGF0ZSwgdGhpcy5kb2MpXG4gICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlclN0YXRlKSlcbiAgICAgIC8vIHdyaXRlIHF1ZXJ5QXdhcmVuZXNzXG4gICAgICBjb25zdCBlbmNvZGVyQXdhcmVuZXNzUXVlcnkgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyQXdhcmVuZXNzUXVlcnksIG1lc3NhZ2VRdWVyeUF3YXJlbmVzcylcbiAgICAgIGJjLnB1Ymxpc2godGhpcy5iY0NoYW5uZWwsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzUXVlcnkpKVxuICAgICAgLy8gYnJvYWRjYXN0IGxvY2FsIGF3YXJlbmVzcyBzdGF0ZVxuICAgICAgY29uc3QgZW5jb2RlckF3YXJlbmVzc1N0YXRlID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlckF3YXJlbmVzc1N0YXRlLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSwgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHRoaXMuYXdhcmVuZXNzLCBbdGhpcy5kb2MuY2xpZW50SURdKSlcbiAgICAgIGJjLnB1Ymxpc2godGhpcy5iY0NoYW5uZWwsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUpKVxuICAgIH0pXG4gIH1cblxuICBkaXNjb25uZWN0QmMgKCkge1xuICAgIC8vIGJyb2FkY2FzdCBtZXNzYWdlIHdpdGggbG9jYWwgYXdhcmVuZXNzIHN0YXRlIHNldCB0byBudWxsIChpbmRpY2F0aW5nIGRpc2Nvbm5lY3QpXG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBhd2FyZW5lc3NQcm90b2NvbC5lbmNvZGVBd2FyZW5lc3NVcGRhdGUodGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvYy5jbGllbnRJRF0sIG5ldyBNYXAoKSkpXG4gICAgYnJvYWRjYXN0TWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gICAgaWYgKHRoaXMuYmNjb25uZWN0ZWQpIHtcbiAgICAgIGJjLnVuc3Vic2NyaWJlKHRoaXMuYmNDaGFubmVsLCB0aGlzLl9iY1N1YnNjcmliZXIpXG4gICAgICB0aGlzLmJjY29ubmVjdGVkID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ICgpIHtcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZVxuICAgIHRoaXMuZGlzY29ubmVjdEJjKClcbiAgICBpZiAodGhpcy53cyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy53cy5jbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgY29ubmVjdCAoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gdHJ1ZVxuICAgIGlmICghdGhpcy53c2Nvbm5lY3RlZCAmJiB0aGlzLndzID09PSBudWxsKSB7XG4gICAgICBzZXR1cFdTKHRoaXMpXG4gICAgICB0aGlzLmNvbm5lY3RCYygpXG4gICAgfVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9