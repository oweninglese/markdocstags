(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_keymap_vim_js"],{

/***/ "./node_modules/codemirror/keymap/vim.js":
/*!***********************************************!*\
  !*** ./node_modules/codemirror/keymap/vim.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/**
 * Supported keybindings:
 *   Too many to list. Refer to defaultKeymap below.
 *
 * Supported Ex commands:
 *   Refer to defaultExCommandMap below.
 *
 * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9
 *   (Does not respect the special case for number registers when delete
 *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )
 *   TODO: Implement the remaining registers.
 *
 * Marks: a-z, A-Z, and 0-9
 *   TODO: Implement the remaining special marks. They have more complex
 *       behavior.
 *
 * Events:
 *  'vim-mode-change' - raised on the editor anytime the current mode changes,
 *                      Event object: {mode: "visual", subMode: "linewise"}
 *
 * Code structure:
 *  1. Default keymap
 *  2. Variable declarations and short basic helpers
 *  3. Instance (External API) implementation
 *  4. Internal state tracking objects (input state, counter) implementation
 *     and instantiation
 *  5. Key handler (the main command dispatcher) implementation
 *  6. Motion, operator, and action implementations
 *  7. Helper functions for the key handler, motions, operators, and actions
 *  8. Set up Vim to work as a keymap for CodeMirror.
 *  9. Ex command implementations.
 */

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__(/*! ../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"), __webpack_require__(/*! ../addon/search/searchcursor */ "./node_modules/codemirror/addon/search/searchcursor.js"), __webpack_require__(/*! ../addon/dialog/dialog */ "./node_modules/codemirror/addon/dialog/dialog.js"), __webpack_require__(/*! ../addon/edit/matchbrackets.js */ "./node_modules/codemirror/addon/edit/matchbrackets.js"));
  else {}
})(function(CodeMirror) {
  'use strict';

  var defaultKeymap = [
    // Key to key mapping. This goes first to make it possible to override
    // existing mappings.
    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },
    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },
    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },
    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },
    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },
    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},
    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},
    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },
    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },
    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },
    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },
    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },
    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },
    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },
    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },
    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },
    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },
    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },
    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},
    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },
    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },
    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },
    { keys: '<End>', type: 'keyToKey', toKeys: '$' },
    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },
    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },
    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },
    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },
    // Motions
    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},
    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},
    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},
    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},
    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},
    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},
    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},
    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},
    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},
    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},
    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},
    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},
    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},
    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},
    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},
    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},
    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},
    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},
    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},
    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},
    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},
    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},
    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},
    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},
    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},
    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},
    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},
    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },
    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },
    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},
    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},
    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},
    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},
    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},
    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},
    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},
    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},
    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},
    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},
    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},
    { keys: '\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},
    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},
    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },
    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },
    { keys: ']\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },
    { keys: '[\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },
    // the next two aren't motions but must come before more general motion declarations
    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},
    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},
    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},
    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},
    { keys: '|', type: 'motion', motion: 'moveToColumn'},
    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},
    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},
    // Operators
    { keys: 'd', type: 'operator', operator: 'delete' },
    { keys: 'y', type: 'operator', operator: 'yank' },
    { keys: 'c', type: 'operator', operator: 'change' },
    { keys: '=', type: 'operator', operator: 'indentAuto' },
    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},
    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},
    { keys: 'g~', type: 'operator', operator: 'changeCase' },
    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },
    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },
    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},
    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},
    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},
    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},
    // Operator-Motion dual commands
    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},
    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},
    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},
    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},
    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},
    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},
    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},
    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},
    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},
    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},
    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },
    //ignore C-w in normal mode
    { keys: '<C-w>', type: 'idle', context: 'normal' },
    // Actions
    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},
    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},
    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},
    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},
    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },
    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },
    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },
    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },
    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },
    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },
    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },
    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },
    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },
    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },
    { keys: 'v', type: 'action', action: 'toggleVisualMode' },
    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},
    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},
    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},
    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },
    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },
    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },
    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},
    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},
    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },
    { keys: '@<character>', type: 'action', action: 'replayMacro' },
    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },
    // Handle Replace-mode as a special case of insert mode.
    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},
    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},
    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },
    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },
    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },
    { keys: '<C-r>', type: 'action', action: 'redo' },
    { keys: 'm<character>', type: 'action', action: 'setMark' },
    { keys: '"<character>', type: 'action', action: 'setRegister' },
    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},
    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },
    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},
    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },
    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},
    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },
    { keys: '.', type: 'action', action: 'repeatLastEdit' },
    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},
    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},
    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },
    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },
    // Text object motions
    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },
    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},
    // Search
    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},
    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},
    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},
    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},
    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},
    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},
    // Ex command
    { keys: ':', type: 'ex' }
  ];
  var defaultKeymapLength = defaultKeymap.length;

  /**
   * Ex commands
   * Care must be taken when adding to the default Ex command map. For any
   * pair of commands that have a shared prefix, at least one of their
   * shortNames must not match the prefix of the other command.
   */
  var defaultExCommandMap = [
    { name: 'colorscheme', shortName: 'colo' },
    { name: 'map' },
    { name: 'imap', shortName: 'im' },
    { name: 'nmap', shortName: 'nm' },
    { name: 'vmap', shortName: 'vm' },
    { name: 'unmap' },
    { name: 'write', shortName: 'w' },
    { name: 'undo', shortName: 'u' },
    { name: 'redo', shortName: 'red' },
    { name: 'set', shortName: 'se' },
    { name: 'setlocal', shortName: 'setl' },
    { name: 'setglobal', shortName: 'setg' },
    { name: 'sort', shortName: 'sor' },
    { name: 'substitute', shortName: 's', possiblyAsync: true },
    { name: 'nohlsearch', shortName: 'noh' },
    { name: 'yank', shortName: 'y' },
    { name: 'delmarks', shortName: 'delm' },
    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },
    { name: 'vglobal', shortName: 'v' },
    { name: 'global', shortName: 'g' }
  ];

  var Pos = CodeMirror.Pos;

  var Vim = function() {
    function enterVimMode(cm) {
      cm.setOption('disableInput', true);
      cm.setOption('showCursorWhenSelecting', false);
      CodeMirror.signal(cm, "vim-mode-change", {mode: "normal"});
      cm.on('cursorActivity', onCursorActivity);
      maybeInitVimState(cm);
      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));
    }

    function leaveVimMode(cm) {
      cm.setOption('disableInput', false);
      cm.off('cursorActivity', onCursorActivity);
      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));
      cm.state.vim = null;
    }

    function detachVimMap(cm, next) {
      if (this == CodeMirror.keyMap.vim) {
        CodeMirror.rmClass(cm.getWrapperElement(), "cm-fat-cursor");
        if (cm.getOption("inputStyle") == "contenteditable" && document.body.style.caretColor != null) {
          disableFatCursorMark(cm);
          cm.getInputField().style.caretColor = "";
        }
      }

      if (!next || next.attach != attachVimMap)
        leaveVimMode(cm);
    }
    function attachVimMap(cm, prev) {
      if (this == CodeMirror.keyMap.vim) {
        CodeMirror.addClass(cm.getWrapperElement(), "cm-fat-cursor");
        if (cm.getOption("inputStyle") == "contenteditable" && document.body.style.caretColor != null) {
          enableFatCursorMark(cm);
          cm.getInputField().style.caretColor = "transparent";
        }
      }

      if (!prev || prev.attach != attachVimMap)
        enterVimMode(cm);
    }

    function updateFatCursorMark(cm) {
      if (!cm.state.fatCursorMarks) return;
      clearFatCursorMark(cm);
      var ranges = cm.listSelections(), result = []
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (range.empty()) {
          var lineLength = cm.getLine(range.anchor.line).length;
          if (range.anchor.ch < lineLength) {
            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1),
                                    {className: "cm-fat-cursor-mark"}));
          } else {
            result.push(cm.markText(Pos(range.anchor.line, lineLength - 1),
                                    Pos(range.anchor.line, lineLength),
                                    {className: "cm-fat-cursor-mark"}));
          }
        }
      }
      cm.state.fatCursorMarks = result;
    }

    function clearFatCursorMark(cm) {
      var marks = cm.state.fatCursorMarks;
      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();
    }

    function enableFatCursorMark(cm) {
      cm.state.fatCursorMarks = [];
      updateFatCursorMark(cm)
      cm.on("cursorActivity", updateFatCursorMark)
    }

    function disableFatCursorMark(cm) {
      clearFatCursorMark(cm);
      cm.off("cursorActivity", updateFatCursorMark);
      // explicitly set fatCursorMarks to null because event listener above
      // can be invoke after removing it, if off is called from operation
      cm.state.fatCursorMarks = null;
    }

    // Deprecated, simply setting the keymap works again.
    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {
      if (val && cm.getOption("keyMap") != "vim")
        cm.setOption("keyMap", "vim");
      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption("keyMap")))
        cm.setOption("keyMap", "default");
    });

    function cmKey(key, cm) {
      if (!cm) { return undefined; }
      if (this[key]) { return this[key]; }
      var vimKey = cmKeyToVimKey(key);
      if (!vimKey) {
        return false;
      }
      var cmd = CodeMirror.Vim.findKey(cm, vimKey);
      if (typeof cmd == 'function') {
        CodeMirror.signal(cm, 'vim-keypress', vimKey);
      }
      return cmd;
    }

    var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};
    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};
    function cmKeyToVimKey(key) {
      if (key.charAt(0) == '\'') {
        // Keypress character binding of format "'a'"
        return key.charAt(1);
      }
      var pieces = key.split(/-(?!$)/);
      var lastPiece = pieces[pieces.length - 1];
      if (pieces.length == 1 && pieces[0].length == 1) {
        // No-modifier bindings use literal character bindings above. Skip.
        return false;
      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {
        // Ignore Shift+char bindings as they should be handled by literal character.
        return false;
      }
      var hasCharacter = false;
      for (var i = 0; i < pieces.length; i++) {
        var piece = pieces[i];
        if (piece in modifiers) { pieces[i] = modifiers[piece]; }
        else { hasCharacter = true; }
        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }
      }
      if (!hasCharacter) {
        // Vim does not support modifier only keys.
        return false;
      }
      // TODO: Current bindings expect the character to be lower case, but
      // it looks like vim key notation uses upper case.
      if (isUpperCase(lastPiece)) {
        pieces[pieces.length - 1] = lastPiece.toLowerCase();
      }
      return '<' + pieces.join('-') + '>';
    }

    function getOnPasteFn(cm) {
      var vim = cm.state.vim;
      if (!vim.onPasteFn) {
        vim.onPasteFn = function() {
          if (!vim.insertMode) {
            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));
            actions.enterInsertMode(cm, {}, vim);
          }
        };
      }
      return vim.onPasteFn;
    }

    var numberRegex = /[\d]/;
    var wordCharTest = [CodeMirror.isWordChar, function(ch) {
      return ch && !CodeMirror.isWordChar(ch) && !/\s/.test(ch);
    }], bigWordCharTest = [function(ch) {
      return /\S/.test(ch);
    }];
    function makeKeyRange(start, size) {
      var keys = [];
      for (var i = start; i < start + size; i++) {
        keys.push(String.fromCharCode(i));
      }
      return keys;
    }
    var upperCaseAlphabet = makeKeyRange(65, 26);
    var lowerCaseAlphabet = makeKeyRange(97, 26);
    var numbers = makeKeyRange(48, 10);
    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);
    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '"', '.', ':', '_', '/']);

    function isLine(cm, line) {
      return line >= cm.firstLine() && line <= cm.lastLine();
    }
    function isLowerCase(k) {
      return (/^[a-z]$/).test(k);
    }
    function isMatchableSymbol(k) {
      return '()[]{}'.indexOf(k) != -1;
    }
    function isNumber(k) {
      return numberRegex.test(k);
    }
    function isUpperCase(k) {
      return (/^[A-Z]$/).test(k);
    }
    function isWhiteSpaceString(k) {
      return (/^\s*$/).test(k);
    }
    function isEndOfSentenceSymbol(k) {
      return '.?!'.indexOf(k) != -1;
    }
    function inArray(val, arr) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] == val) {
          return true;
        }
      }
      return false;
    }

    var options = {};
    function defineOption(name, defaultValue, type, aliases, callback) {
      if (defaultValue === undefined && !callback) {
        throw Error('defaultValue is required unless callback is provided');
      }
      if (!type) { type = 'string'; }
      options[name] = {
        type: type,
        defaultValue: defaultValue,
        callback: callback
      };
      if (aliases) {
        for (var i = 0; i < aliases.length; i++) {
          options[aliases[i]] = options[name];
        }
      }
      if (defaultValue) {
        setOption(name, defaultValue);
      }
    }

    function setOption(name, value, cm, cfg) {
      var option = options[name];
      cfg = cfg || {};
      var scope = cfg.scope;
      if (!option) {
        return new Error('Unknown option: ' + name);
      }
      if (option.type == 'boolean') {
        if (value && value !== true) {
          return new Error('Invalid argument: ' + name + '=' + value);
        } else if (value !== false) {
          // Boolean options are set to true if value is not defined.
          value = true;
        }
      }
      if (option.callback) {
        if (scope !== 'local') {
          option.callback(value, undefined);
        }
        if (scope !== 'global' && cm) {
          option.callback(value, cm);
        }
      } else {
        if (scope !== 'local') {
          option.value = option.type == 'boolean' ? !!value : value;
        }
        if (scope !== 'global' && cm) {
          cm.state.vim.options[name] = {value: value};
        }
      }
    }

    function getOption(name, cm, cfg) {
      var option = options[name];
      cfg = cfg || {};
      var scope = cfg.scope;
      if (!option) {
        return new Error('Unknown option: ' + name);
      }
      if (option.callback) {
        var local = cm && option.callback(undefined, cm);
        if (scope !== 'global' && local !== undefined) {
          return local;
        }
        if (scope !== 'local') {
          return option.callback();
        }
        return;
      } else {
        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);
        return (local || (scope !== 'local') && option || {}).value;
      }
    }

    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {
      // Option is local. Do nothing for global.
      if (cm === undefined) {
        return;
      }
      // The 'filetype' option proxies to the CodeMirror 'mode' option.
      if (name === undefined) {
        var mode = cm.getOption('mode');
        return mode == 'null' ? '' : mode;
      } else {
        var mode = name == '' ? 'null' : name;
        cm.setOption('mode', mode);
      }
    });

    var createCircularJumpList = function() {
      var size = 100;
      var pointer = -1;
      var head = 0;
      var tail = 0;
      var buffer = new Array(size);
      function add(cm, oldCur, newCur) {
        var current = pointer % size;
        var curMark = buffer[current];
        function useNextSlot(cursor) {
          var next = ++pointer % size;
          var trashMark = buffer[next];
          if (trashMark) {
            trashMark.clear();
          }
          buffer[next] = cm.setBookmark(cursor);
        }
        if (curMark) {
          var markPos = curMark.find();
          // avoid recording redundant cursor position
          if (markPos && !cursorEqual(markPos, oldCur)) {
            useNextSlot(oldCur);
          }
        } else {
          useNextSlot(oldCur);
        }
        useNextSlot(newCur);
        head = pointer;
        tail = pointer - size + 1;
        if (tail < 0) {
          tail = 0;
        }
      }
      function move(cm, offset) {
        pointer += offset;
        if (pointer > head) {
          pointer = head;
        } else if (pointer < tail) {
          pointer = tail;
        }
        var mark = buffer[(size + pointer) % size];
        // skip marks that are temporarily removed from text buffer
        if (mark && !mark.find()) {
          var inc = offset > 0 ? 1 : -1;
          var newCur;
          var oldCur = cm.getCursor();
          do {
            pointer += inc;
            mark = buffer[(size + pointer) % size];
            // skip marks that are the same as current position
            if (mark &&
                (newCur = mark.find()) &&
                !cursorEqual(oldCur, newCur)) {
              break;
            }
          } while (pointer < head && pointer > tail);
        }
        return mark;
      }
      function find(cm, offset) {
        var oldPointer = pointer;
        var mark = move(cm, offset);
        pointer = oldPointer;
        return mark && mark.find();
      }
      return {
        cachedCursor: undefined, //used for # and * jumps
        add: add,
        find: find,
        move: move
      };
    };

    // Returns an object to track the changes associated insert mode.  It
    // clones the object that is passed in, or creates an empty object one if
    // none is provided.
    var createInsertModeChanges = function(c) {
      if (c) {
        // Copy construction
        return {
          changes: c.changes,
          expectCursorActivityForChange: c.expectCursorActivityForChange
        };
      }
      return {
        // Change list
        changes: [],
        // Set to true on change, false on cursorActivity.
        expectCursorActivityForChange: false
      };
    };

    function MacroModeState() {
      this.latestRegister = undefined;
      this.isPlaying = false;
      this.isRecording = false;
      this.replaySearchQueries = [];
      this.onRecordingDone = undefined;
      this.lastInsertModeChanges = createInsertModeChanges();
    }
    MacroModeState.prototype = {
      exitMacroRecordMode: function() {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.onRecordingDone) {
          macroModeState.onRecordingDone(); // close dialog
        }
        macroModeState.onRecordingDone = undefined;
        macroModeState.isRecording = false;
      },
      enterMacroRecordMode: function(cm, registerName) {
        var register =
            vimGlobalState.registerController.getRegister(registerName);
        if (register) {
          register.clear();
          this.latestRegister = registerName;
          if (cm.openDialog) {
            this.onRecordingDone = cm.openDialog(
                '(recording)['+registerName+']', null, {bottom:true});
          }
          this.isRecording = true;
        }
      }
    };

    function maybeInitVimState(cm) {
      if (!cm.state.vim) {
        // Store instance state in the CodeMirror object.
        cm.state.vim = {
          inputState: new InputState(),
          // Vim's input state that triggered the last edit, used to repeat
          // motions and operators with '.'.
          lastEditInputState: undefined,
          // Vim's action command before the last edit, used to repeat actions
          // with '.' and insert mode repeat.
          lastEditActionCommand: undefined,
          // When using jk for navigation, if you move from a longer line to a
          // shorter line, the cursor may clip to the end of the shorter line.
          // If j is pressed again and cursor goes to the next line, the
          // cursor should go back to its horizontal position on the longer
          // line if it can. This is to keep track of the horizontal position.
          lastHPos: -1,
          // Doing the same with screen-position for gj/gk
          lastHSPos: -1,
          // The last motion command run. Cleared if a non-motion command gets
          // executed in between.
          lastMotion: null,
          marks: {},
          // Mark for rendering fake cursor for visual mode.
          fakeCursor: null,
          insertMode: false,
          // Repeat count for changes made in insert mode, triggered by key
          // sequences like 3,i. Only exists when insertMode is true.
          insertModeRepeat: undefined,
          visualMode: false,
          // If we are in visual line mode. No effect if visualMode is false.
          visualLine: false,
          visualBlock: false,
          lastSelection: null,
          lastPastedText: null,
          sel: {},
          // Buffer-local/window-local values of vim options.
          options: {}
        };
      }
      return cm.state.vim;
    }
    var vimGlobalState;
    function resetVimGlobalState() {
      vimGlobalState = {
        // The current search query.
        searchQuery: null,
        // Whether we are searching backwards.
        searchIsReversed: false,
        // Replace part of the last substituted pattern
        lastSubstituteReplacePart: undefined,
        jumpList: createCircularJumpList(),
        macroModeState: new MacroModeState,
        // Recording latest f, t, F or T motion command.
        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},
        registerController: new RegisterController({}),
        // search history buffer
        searchHistoryController: new HistoryController(),
        // ex Command history buffer
        exCommandHistoryController : new HistoryController()
      };
      for (var optionName in options) {
        var option = options[optionName];
        option.value = option.defaultValue;
      }
    }

    var lastInsertModeKeyTimer;
    var vimApi= {
      buildKeyMap: function() {
        // TODO: Convert keymap into dictionary format for fast lookup.
      },
      // Testing hook, though it might be useful to expose the register
      // controller anyway.
      getRegisterController: function() {
        return vimGlobalState.registerController;
      },
      // Testing hook.
      resetVimGlobalState_: resetVimGlobalState,

      // Testing hook.
      getVimGlobalState_: function() {
        return vimGlobalState;
      },

      // Testing hook.
      maybeInitVimState_: maybeInitVimState,

      suppressErrorLogging: false,

      InsertModeKey: InsertModeKey,
      map: function(lhs, rhs, ctx) {
        // Add user defined key bindings.
        exCommandDispatcher.map(lhs, rhs, ctx);
      },
      unmap: function(lhs, ctx) {
        exCommandDispatcher.unmap(lhs, ctx);
      },
      // Non-recursive map function.
      // NOTE: This will not create mappings to key maps that aren't present
      // in the default key map. See TODO at bottom of function.
      noremap: function(lhs, rhs, ctx) {
        function toCtxArray(ctx) {
          return ctx ? [ctx] : ['normal', 'insert', 'visual'];
        }
        var ctxsToMap = toCtxArray(ctx);
        // Look through all actual defaults to find a map candidate.
        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;
        for (var i = actualLength - origLength;
             i < actualLength && ctxsToMap.length;
             i++) {
          var mapping = defaultKeymap[i];
          // Omit mappings that operate in the wrong context(s) and those of invalid type.
          if (mapping.keys == rhs &&
              (!ctx || !mapping.context || mapping.context === ctx) &&
              mapping.type.substr(0, 2) !== 'ex' &&
              mapping.type.substr(0, 3) !== 'key') {
            // Make a shallow copy of the original keymap entry.
            var newMapping = {};
            for (var key in mapping) {
              newMapping[key] = mapping[key];
            }
            // Modify it point to the new mapping with the proper context.
            newMapping.keys = lhs;
            if (ctx && !newMapping.context) {
              newMapping.context = ctx;
            }
            // Add it to the keymap with a higher priority than the original.
            this._mapCommand(newMapping);
            // Record the mapped contexts as complete.
            var mappedCtxs = toCtxArray(mapping.context);
            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });
          }
        }
        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.
      },
      // Remove all user-defined mappings for the provided context.
      mapclear: function(ctx) {
        // Partition the existing keymap into user-defined and true defaults.
        var actualLength = defaultKeymap.length,
            origLength = defaultKeymapLength;
        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);
        defaultKeymap = defaultKeymap.slice(actualLength - origLength);
        if (ctx) {
          // If a specific context is being cleared, we need to keep mappings
          // from all other contexts.
          for (var i = userKeymap.length - 1; i >= 0; i--) {
            var mapping = userKeymap[i];
            if (ctx !== mapping.context) {
              if (mapping.context) {
                this._mapCommand(mapping);
              } else {
                // `mapping` applies to all contexts so create keymap copies
                // for each context except the one being cleared.
                var contexts = ['normal', 'insert', 'visual'];
                for (var j in contexts) {
                  if (contexts[j] !== ctx) {
                    var newMapping = {};
                    for (var key in mapping) {
                      newMapping[key] = mapping[key];
                    }
                    newMapping.context = contexts[j];
                    this._mapCommand(newMapping);
                  }
                }
              }
            }
          }
        }
      },
      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace
      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.
      setOption: setOption,
      getOption: getOption,
      defineOption: defineOption,
      defineEx: function(name, prefix, func){
        if (!prefix) {
          prefix = name;
        } else if (name.indexOf(prefix) !== 0) {
          throw new Error('(Vim.defineEx) "'+prefix+'" is not a prefix of "'+name+'", command not registered');
        }
        exCommands[name]=func;
        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};
      },
      handleKey: function (cm, key, origin) {
        var command = this.findKey(cm, key, origin);
        if (typeof command === 'function') {
          return command();
        }
      },
      /**
       * This is the outermost function called by CodeMirror, after keys have
       * been mapped to their Vim equivalents.
       *
       * Finds a command based on the key (and cached keys if there is a
       * multi-key sequence). Returns `undefined` if no key is matched, a noop
       * function if a partial match is found (multi-key), and a function to
       * execute the bound command if a a key is matched. The function always
       * returns true.
       */
      findKey: function(cm, key, origin) {
        var vim = maybeInitVimState(cm);
        function handleMacroRecording() {
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isRecording) {
            if (key == 'q') {
              macroModeState.exitMacroRecordMode();
              clearInputState(cm);
              return true;
            }
            if (origin != 'mapping') {
              logKey(macroModeState, key);
            }
          }
        }
        function handleEsc() {
          if (key == '<Esc>') {
            // Clear input state and get back to normal mode.
            clearInputState(cm);
            if (vim.visualMode) {
              exitVisualMode(cm);
            } else if (vim.insertMode) {
              exitInsertMode(cm);
            }
            return true;
          }
        }
        function doKeyToKey(keys) {
          // TODO: prevent infinite recursion.
          var match;
          while (keys) {
            // Pull off one command key, which is either a single character
            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.
            match = (/<\w+-.+?>|<\w+>|./).exec(keys);
            key = match[0];
            keys = keys.substring(match.index + key.length);
            CodeMirror.Vim.handleKey(cm, key, 'mapping');
          }
        }

        function handleKeyInsertMode() {
          if (handleEsc()) { return true; }
          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
          var keysAreChars = key.length == 1;
          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');
          // Need to check all key substrings in insert mode.
          while (keys.length > 1 && match.type != 'full') {
            var keys = vim.inputState.keyBuffer = keys.slice(1);
            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');
            if (thisMatch.type != 'none') { match = thisMatch; }
          }
          if (match.type == 'none') { clearInputState(cm); return false; }
          else if (match.type == 'partial') {
            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }
            lastInsertModeKeyTimer = window.setTimeout(
              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },
              getOption('insertModeEscKeysTimeout'));
            return !keysAreChars;
          }

          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }
          if (keysAreChars) {
            var selections = cm.listSelections();
            for (var i = 0; i < selections.length; i++) {
              var here = selections[i].head;
              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');
            }
            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();
          }
          clearInputState(cm);
          return match.command;
        }

        function handleKeyNonInsertMode() {
          if (handleMacroRecording() || handleEsc()) { return true; }

          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
          if (/^[1-9]\d*$/.test(keys)) { return true; }

          var keysMatcher = /^(\d*)(.*)$/.exec(keys);
          if (!keysMatcher) { clearInputState(cm); return false; }
          var context = vim.visualMode ? 'visual' :
                                         'normal';
          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);
          if (match.type == 'none') { clearInputState(cm); return false; }
          else if (match.type == 'partial') { return true; }

          vim.inputState.keyBuffer = '';
          var keysMatcher = /^(\d*)(.*)$/.exec(keys);
          if (keysMatcher[1] && keysMatcher[1] != '0') {
            vim.inputState.pushRepeatDigit(keysMatcher[1]);
          }
          return match.command;
        }

        var command;
        if (vim.insertMode) { command = handleKeyInsertMode(); }
        else { command = handleKeyNonInsertMode(); }
        if (command === false) {
          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;
        } else if (command === true) {
          // TODO: Look into using CodeMirror's multi-key handling.
          // Return no-op since we are caching the key. Counts as handled, but
          // don't want act on it just yet.
          return function() { return true; };
        } else {
          return function() {
            return cm.operation(function() {
              cm.curOp.isVimOp = true;
              try {
                if (command.type == 'keyToKey') {
                  doKeyToKey(command.toKeys);
                } else {
                  commandDispatcher.processCommand(cm, vim, command);
                }
              } catch (e) {
                // clear VIM state in case it's in a bad state.
                cm.state.vim = undefined;
                maybeInitVimState(cm);
                if (!CodeMirror.Vim.suppressErrorLogging) {
                  console['log'](e);
                }
                throw e;
              }
              return true;
            });
          };
        }
      },
      handleEx: function(cm, input) {
        exCommandDispatcher.processCommand(cm, input);
      },

      defineMotion: defineMotion,
      defineAction: defineAction,
      defineOperator: defineOperator,
      mapCommand: mapCommand,
      _mapCommand: _mapCommand,

      defineRegister: defineRegister,

      exitVisualMode: exitVisualMode,
      exitInsertMode: exitInsertMode
    };

    // Represents the current input state.
    function InputState() {
      this.prefixRepeat = [];
      this.motionRepeat = [];

      this.operator = null;
      this.operatorArgs = null;
      this.motion = null;
      this.motionArgs = null;
      this.keyBuffer = []; // For matching multi-key commands.
      this.registerName = null; // Defaults to the unnamed register.
    }
    InputState.prototype.pushRepeatDigit = function(n) {
      if (!this.operator) {
        this.prefixRepeat = this.prefixRepeat.concat(n);
      } else {
        this.motionRepeat = this.motionRepeat.concat(n);
      }
    };
    InputState.prototype.getRepeat = function() {
      var repeat = 0;
      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {
        repeat = 1;
        if (this.prefixRepeat.length > 0) {
          repeat *= parseInt(this.prefixRepeat.join(''), 10);
        }
        if (this.motionRepeat.length > 0) {
          repeat *= parseInt(this.motionRepeat.join(''), 10);
        }
      }
      return repeat;
    };

    function clearInputState(cm, reason) {
      cm.state.vim.inputState = new InputState();
      CodeMirror.signal(cm, 'vim-command-done', reason);
    }

    /*
     * Register stores information about copy and paste registers.  Besides
     * text, a register must store whether it is linewise (i.e., when it is
     * pasted, should it insert itself into a new line, or should the text be
     * inserted at the cursor position.)
     */
    function Register(text, linewise, blockwise) {
      this.clear();
      this.keyBuffer = [text || ''];
      this.insertModeChanges = [];
      this.searchQueries = [];
      this.linewise = !!linewise;
      this.blockwise = !!blockwise;
    }
    Register.prototype = {
      setText: function(text, linewise, blockwise) {
        this.keyBuffer = [text || ''];
        this.linewise = !!linewise;
        this.blockwise = !!blockwise;
      },
      pushText: function(text, linewise) {
        // if this register has ever been set to linewise, use linewise.
        if (linewise) {
          if (!this.linewise) {
            this.keyBuffer.push('\n');
          }
          this.linewise = true;
        }
        this.keyBuffer.push(text);
      },
      pushInsertModeChanges: function(changes) {
        this.insertModeChanges.push(createInsertModeChanges(changes));
      },
      pushSearchQuery: function(query) {
        this.searchQueries.push(query);
      },
      clear: function() {
        this.keyBuffer = [];
        this.insertModeChanges = [];
        this.searchQueries = [];
        this.linewise = false;
      },
      toString: function() {
        return this.keyBuffer.join('');
      }
    };

    /**
     * Defines an external register.
     *
     * The name should be a single character that will be used to reference the register.
     * The register should support setText, pushText, clear, and toString(). See Register
     * for a reference implementation.
     */
    function defineRegister(name, register) {
      var registers = vimGlobalState.registerController.registers;
      if (!name || name.length != 1) {
        throw Error('Register name must be 1 character');
      }
      if (registers[name]) {
        throw Error('Register already defined ' + name);
      }
      registers[name] = register;
      validRegisters.push(name);
    }

    /*
     * vim registers allow you to keep many independent copy and paste buffers.
     * See http://usevim.com/2012/04/13/registers/ for an introduction.
     *
     * RegisterController keeps the state of all the registers.  An initial
     * state may be passed in.  The unnamed register '"' will always be
     * overridden.
     */
    function RegisterController(registers) {
      this.registers = registers;
      this.unnamedRegister = registers['"'] = new Register();
      registers['.'] = new Register();
      registers[':'] = new Register();
      registers['/'] = new Register();
    }
    RegisterController.prototype = {
      pushText: function(registerName, operator, text, linewise, blockwise) {
        // The black hole register, "_, means delete/yank to nowhere.
        if (registerName === '_') return;
        if (linewise && text.charAt(text.length - 1) !== '\n'){
          text += '\n';
        }
        // Lowercase and uppercase registers refer to the same register.
        // Uppercase just means append.
        var register = this.isValidRegister(registerName) ?
            this.getRegister(registerName) : null;
        // if no register/an invalid register was specified, things go to the
        // default registers
        if (!register) {
          switch (operator) {
            case 'yank':
              // The 0 register contains the text from the most recent yank.
              this.registers['0'] = new Register(text, linewise, blockwise);
              break;
            case 'delete':
            case 'change':
              if (text.indexOf('\n') == -1) {
                // Delete less than 1 line. Update the small delete register.
                this.registers['-'] = new Register(text, linewise);
              } else {
                // Shift down the contents of the numbered registers and put the
                // deleted text into register 1.
                this.shiftNumericRegisters_();
                this.registers['1'] = new Register(text, linewise);
              }
              break;
          }
          // Make sure the unnamed register is set to what just happened
          this.unnamedRegister.setText(text, linewise, blockwise);
          return;
        }

        // If we've gotten to this point, we've actually specified a register
        var append = isUpperCase(registerName);
        if (append) {
          register.pushText(text, linewise);
        } else {
          register.setText(text, linewise, blockwise);
        }
        // The unnamed register always has the same value as the last used
        // register.
        this.unnamedRegister.setText(register.toString(), linewise);
      },
      // Gets the register named @name.  If one of @name doesn't already exist,
      // create it.  If @name is invalid, return the unnamedRegister.
      getRegister: function(name) {
        if (!this.isValidRegister(name)) {
          return this.unnamedRegister;
        }
        name = name.toLowerCase();
        if (!this.registers[name]) {
          this.registers[name] = new Register();
        }
        return this.registers[name];
      },
      isValidRegister: function(name) {
        return name && inArray(name, validRegisters);
      },
      shiftNumericRegisters_: function() {
        for (var i = 9; i >= 2; i--) {
          this.registers[i] = this.getRegister('' + (i - 1));
        }
      }
    };
    function HistoryController() {
        this.historyBuffer = [];
        this.iterator = 0;
        this.initialPrefix = null;
    }
    HistoryController.prototype = {
      // the input argument here acts a user entered prefix for a small time
      // until we start autocompletion in which case it is the autocompleted.
      nextMatch: function (input, up) {
        var historyBuffer = this.historyBuffer;
        var dir = up ? -1 : 1;
        if (this.initialPrefix === null) this.initialPrefix = input;
        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {
          var element = historyBuffer[i];
          for (var j = 0; j <= element.length; j++) {
            if (this.initialPrefix == element.substring(0, j)) {
              this.iterator = i;
              return element;
            }
          }
        }
        // should return the user input in case we reach the end of buffer.
        if (i >= historyBuffer.length) {
          this.iterator = historyBuffer.length;
          return this.initialPrefix;
        }
        // return the last autocompleted query or exCommand as it is.
        if (i < 0 ) return input;
      },
      pushInput: function(input) {
        var index = this.historyBuffer.indexOf(input);
        if (index > -1) this.historyBuffer.splice(index, 1);
        if (input.length) this.historyBuffer.push(input);
      },
      reset: function() {
        this.initialPrefix = null;
        this.iterator = this.historyBuffer.length;
      }
    };
    var commandDispatcher = {
      matchCommand: function(keys, keyMap, inputState, context) {
        var matches = commandMatches(keys, keyMap, context, inputState);
        if (!matches.full && !matches.partial) {
          return {type: 'none'};
        } else if (!matches.full && matches.partial) {
          return {type: 'partial'};
        }

        var bestMatch;
        for (var i = 0; i < matches.full.length; i++) {
          var match = matches.full[i];
          if (!bestMatch) {
            bestMatch = match;
          }
        }
        if (bestMatch.keys.slice(-11) == '<character>') {
          var character = lastChar(keys);
          if (!character) return {type: 'none'};
          inputState.selectedCharacter = character;
        }
        return {type: 'full', command: bestMatch};
      },
      processCommand: function(cm, vim, command) {
        vim.inputState.repeatOverride = command.repeatOverride;
        switch (command.type) {
          case 'motion':
            this.processMotion(cm, vim, command);
            break;
          case 'operator':
            this.processOperator(cm, vim, command);
            break;
          case 'operatorMotion':
            this.processOperatorMotion(cm, vim, command);
            break;
          case 'action':
            this.processAction(cm, vim, command);
            break;
          case 'search':
            this.processSearch(cm, vim, command);
            break;
          case 'ex':
          case 'keyToEx':
            this.processEx(cm, vim, command);
            break;
          default:
            break;
        }
      },
      processMotion: function(cm, vim, command) {
        vim.inputState.motion = command.motion;
        vim.inputState.motionArgs = copyArgs(command.motionArgs);
        this.evalInput(cm, vim);
      },
      processOperator: function(cm, vim, command) {
        var inputState = vim.inputState;
        if (inputState.operator) {
          if (inputState.operator == command.operator) {
            // Typing an operator twice like 'dd' makes the operator operate
            // linewise
            inputState.motion = 'expandToLine';
            inputState.motionArgs = { linewise: true };
            this.evalInput(cm, vim);
            return;
          } else {
            // 2 different operators in a row doesn't make sense.
            clearInputState(cm);
          }
        }
        inputState.operator = command.operator;
        inputState.operatorArgs = copyArgs(command.operatorArgs);
        if (command.exitVisualBlock) {
            vim.visualBlock = false;
            updateCmSelection(cm);
        }
        if (vim.visualMode) {
          // Operating on a selection in visual mode. We don't need a motion.
          this.evalInput(cm, vim);
        }
      },
      processOperatorMotion: function(cm, vim, command) {
        var visualMode = vim.visualMode;
        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);
        if (operatorMotionArgs) {
          // Operator motions may have special behavior in visual mode.
          if (visualMode && operatorMotionArgs.visualLine) {
            vim.visualLine = true;
          }
        }
        this.processOperator(cm, vim, command);
        if (!visualMode) {
          this.processMotion(cm, vim, command);
        }
      },
      processAction: function(cm, vim, command) {
        var inputState = vim.inputState;
        var repeat = inputState.getRepeat();
        var repeatIsExplicit = !!repeat;
        var actionArgs = copyArgs(command.actionArgs) || {};
        if (inputState.selectedCharacter) {
          actionArgs.selectedCharacter = inputState.selectedCharacter;
        }
        // Actions may or may not have motions and operators. Do these first.
        if (command.operator) {
          this.processOperator(cm, vim, command);
        }
        if (command.motion) {
          this.processMotion(cm, vim, command);
        }
        if (command.motion || command.operator) {
          this.evalInput(cm, vim);
        }
        actionArgs.repeat = repeat || 1;
        actionArgs.repeatIsExplicit = repeatIsExplicit;
        actionArgs.registerName = inputState.registerName;
        clearInputState(cm);
        vim.lastMotion = null;
        if (command.isEdit) {
          this.recordLastEdit(vim, inputState, command);
        }
        actions[command.action](cm, actionArgs, vim);
      },
      processSearch: function(cm, vim, command) {
        if (!cm.getSearchCursor) {
          // Search depends on SearchCursor.
          return;
        }
        var forward = command.searchArgs.forward;
        var wholeWordOnly = command.searchArgs.wholeWordOnly;
        getSearchState(cm).setReversed(!forward);
        var promptPrefix = (forward) ? '/' : '?';
        var originalQuery = getSearchState(cm).getQuery();
        var originalScrollPos = cm.getScrollInfo();
        function handleQuery(query, ignoreCase, smartCase) {
          vimGlobalState.searchHistoryController.pushInput(query);
          vimGlobalState.searchHistoryController.reset();
          try {
            updateSearchQuery(cm, query, ignoreCase, smartCase);
          } catch (e) {
            showConfirm(cm, 'Invalid regex: ' + query);
            clearInputState(cm);
            return;
          }
          commandDispatcher.processMotion(cm, vim, {
            type: 'motion',
            motion: 'findNext',
            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }
          });
        }
        function onPromptClose(query) {
          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
          handleQuery(query, true /** ignoreCase */, true /** smartCase */);
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isRecording) {
            logSearchQuery(macroModeState, query);
          }
        }
        function onPromptKeyUp(e, query, close) {
          var keyName = CodeMirror.keyName(e), up, offset;
          if (keyName == 'Up' || keyName == 'Down') {
            up = keyName == 'Up' ? true : false;
            offset = e.target ? e.target.selectionEnd : 0;
            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';
            close(query);
            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
          } else {
            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')
              vimGlobalState.searchHistoryController.reset();
          }
          var parsedQuery;
          try {
            parsedQuery = updateSearchQuery(cm, query,
                true /** ignoreCase */, true /** smartCase */);
          } catch (e) {
            // Swallow bad regexes for incremental search.
          }
          if (parsedQuery) {
            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);
          } else {
            clearSearchHighlight(cm);
            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
          }
        }
        function onPromptKeyDown(e, query, close) {
          var keyName = CodeMirror.keyName(e);
          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||
              (keyName == 'Backspace' && query == '')) {
            vimGlobalState.searchHistoryController.pushInput(query);
            vimGlobalState.searchHistoryController.reset();
            updateSearchQuery(cm, originalQuery);
            clearSearchHighlight(cm);
            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
            CodeMirror.e_stop(e);
            clearInputState(cm);
            close();
            cm.focus();
          } else if (keyName == 'Up' || keyName == 'Down') {
            CodeMirror.e_stop(e);
          } else if (keyName == 'Ctrl-U') {
            // Ctrl-U clears input.
            CodeMirror.e_stop(e);
            close('');
          }
        }
        switch (command.searchArgs.querySrc) {
          case 'prompt':
            var macroModeState = vimGlobalState.macroModeState;
            if (macroModeState.isPlaying) {
              var query = macroModeState.replaySearchQueries.shift();
              handleQuery(query, true /** ignoreCase */, false /** smartCase */);
            } else {
              showPrompt(cm, {
                  onClose: onPromptClose,
                  prefix: promptPrefix,
                  desc: '(JavaScript regexp)',
                  onKeyUp: onPromptKeyUp,
                  onKeyDown: onPromptKeyDown
              });
            }
            break;
          case 'wordUnderCursor':
            var word = expandWordUnderCursor(cm, false /** inclusive */,
                true /** forward */, false /** bigWord */,
                true /** noSymbol */);
            var isKeyword = true;
            if (!word) {
              word = expandWordUnderCursor(cm, false /** inclusive */,
                  true /** forward */, false /** bigWord */,
                  false /** noSymbol */);
              isKeyword = false;
            }
            if (!word) {
              return;
            }
            var query = cm.getLine(word.start.line).substring(word.start.ch,
                word.end.ch);
            if (isKeyword && wholeWordOnly) {
                query = '\\b' + query + '\\b';
            } else {
              query = escapeRegex(query);
            }

            // cachedCursor is used to save the old position of the cursor
            // when * or # causes vim to seek for the nearest word and shift
            // the cursor before entering the motion.
            vimGlobalState.jumpList.cachedCursor = cm.getCursor();
            cm.setCursor(word.start);

            handleQuery(query, true /** ignoreCase */, false /** smartCase */);
            break;
        }
      },
      processEx: function(cm, vim, command) {
        function onPromptClose(input) {
          // Give the prompt some time to close so that if processCommand shows
          // an error, the elements don't overlap.
          vimGlobalState.exCommandHistoryController.pushInput(input);
          vimGlobalState.exCommandHistoryController.reset();
          exCommandDispatcher.processCommand(cm, input);
        }
        function onPromptKeyDown(e, input, close) {
          var keyName = CodeMirror.keyName(e), up, offset;
          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||
              (keyName == 'Backspace' && input == '')) {
            vimGlobalState.exCommandHistoryController.pushInput(input);
            vimGlobalState.exCommandHistoryController.reset();
            CodeMirror.e_stop(e);
            clearInputState(cm);
            close();
            cm.focus();
          }
          if (keyName == 'Up' || keyName == 'Down') {
            CodeMirror.e_stop(e);
            up = keyName == 'Up' ? true : false;
            offset = e.target ? e.target.selectionEnd : 0;
            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';
            close(input);
            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
          } else if (keyName == 'Ctrl-U') {
            // Ctrl-U clears input.
            CodeMirror.e_stop(e);
            close('');
          } else {
            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')
              vimGlobalState.exCommandHistoryController.reset();
          }
        }
        if (command.type == 'keyToEx') {
          // Handle user defined Ex to Ex mappings
          exCommandDispatcher.processCommand(cm, command.exArgs.input);
        } else {
          if (vim.visualMode) {
            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\'<,\'>',
                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});
          } else {
            showPrompt(cm, { onClose: onPromptClose, prefix: ':',
                onKeyDown: onPromptKeyDown});
          }
        }
      },
      evalInput: function(cm, vim) {
        // If the motion command is set, execute both the operator and motion.
        // Otherwise return.
        var inputState = vim.inputState;
        var motion = inputState.motion;
        var motionArgs = inputState.motionArgs || {};
        var operator = inputState.operator;
        var operatorArgs = inputState.operatorArgs || {};
        var registerName = inputState.registerName;
        var sel = vim.sel;
        // TODO: Make sure cm and vim selections are identical outside visual mode.
        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));
        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));
        var oldHead = copyCursor(origHead);
        var oldAnchor = copyCursor(origAnchor);
        var newHead, newAnchor;
        var repeat;
        if (operator) {
          this.recordLastEdit(vim, inputState);
        }
        if (inputState.repeatOverride !== undefined) {
          // If repeatOverride is specified, that takes precedence over the
          // input state's repeat. Used by Ex mode and can be user defined.
          repeat = inputState.repeatOverride;
        } else {
          repeat = inputState.getRepeat();
        }
        if (repeat > 0 && motionArgs.explicitRepeat) {
          motionArgs.repeatIsExplicit = true;
        } else if (motionArgs.noRepeat ||
            (!motionArgs.explicitRepeat && repeat === 0)) {
          repeat = 1;
          motionArgs.repeatIsExplicit = false;
        }
        if (inputState.selectedCharacter) {
          // If there is a character input, stick it in all of the arg arrays.
          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =
              inputState.selectedCharacter;
        }
        motionArgs.repeat = repeat;
        clearInputState(cm);
        if (motion) {
          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);
          vim.lastMotion = motions[motion];
          if (!motionResult) {
            return;
          }
          if (motionArgs.toJumplist) {
            var jumpList = vimGlobalState.jumpList;
            // if the current motion is # or *, use cachedCursor
            var cachedCursor = jumpList.cachedCursor;
            if (cachedCursor) {
              recordJumpPosition(cm, cachedCursor, motionResult);
              delete jumpList.cachedCursor;
            } else {
              recordJumpPosition(cm, origHead, motionResult);
            }
          }
          if (motionResult instanceof Array) {
            newAnchor = motionResult[0];
            newHead = motionResult[1];
          } else {
            newHead = motionResult;
          }
          // TODO: Handle null returns from motion commands better.
          if (!newHead) {
            newHead = copyCursor(origHead);
          }
          if (vim.visualMode) {
            if (!(vim.visualBlock && newHead.ch === Infinity)) {
              newHead = clipCursorToContent(cm, newHead);
            }
            if (newAnchor) {
              newAnchor = clipCursorToContent(cm, newAnchor);
            }
            newAnchor = newAnchor || oldAnchor;
            sel.anchor = newAnchor;
            sel.head = newHead;
            updateCmSelection(cm);
            updateMark(cm, vim, '<',
                cursorIsBefore(newAnchor, newHead) ? newAnchor
                    : newHead);
            updateMark(cm, vim, '>',
                cursorIsBefore(newAnchor, newHead) ? newHead
                    : newAnchor);
          } else if (!operator) {
            newHead = clipCursorToContent(cm, newHead);
            cm.setCursor(newHead.line, newHead.ch);
          }
        }
        if (operator) {
          if (operatorArgs.lastSel) {
            // Replaying a visual mode operation
            newAnchor = oldAnchor;
            var lastSel = operatorArgs.lastSel;
            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);
            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);
            if (lastSel.visualLine) {
              // Linewise Visual mode: The same number of lines.
              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
            } else if (lastSel.visualBlock) {
              // Blockwise Visual mode: The same number of lines and columns.
              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);
            } else if (lastSel.head.line == lastSel.anchor.line) {
              // Normal Visual mode within one line: The same number of characters.
              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);
            } else {
              // Normal Visual mode with several lines: The same number of lines, in the
              // last line the same number of characters as in the last line the last time.
              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
            }
            vim.visualMode = true;
            vim.visualLine = lastSel.visualLine;
            vim.visualBlock = lastSel.visualBlock;
            sel = vim.sel = {
              anchor: newAnchor,
              head: newHead
            };
            updateCmSelection(cm);
          } else if (vim.visualMode) {
            operatorArgs.lastSel = {
              anchor: copyCursor(sel.anchor),
              head: copyCursor(sel.head),
              visualBlock: vim.visualBlock,
              visualLine: vim.visualLine
            };
          }
          var curStart, curEnd, linewise, mode;
          var cmSel;
          if (vim.visualMode) {
            // Init visual op
            curStart = cursorMin(sel.head, sel.anchor);
            curEnd = cursorMax(sel.head, sel.anchor);
            linewise = vim.visualLine || operatorArgs.linewise;
            mode = vim.visualBlock ? 'block' :
                   linewise ? 'line' :
                   'char';
            cmSel = makeCmSelection(cm, {
              anchor: curStart,
              head: curEnd
            }, mode);
            if (linewise) {
              var ranges = cmSel.ranges;
              if (mode == 'block') {
                // Linewise operators in visual block mode extend to end of line
                for (var i = 0; i < ranges.length; i++) {
                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);
                }
              } else if (mode == 'line') {
                ranges[0].head = Pos(ranges[0].head.line + 1, 0);
              }
            }
          } else {
            // Init motion op
            curStart = copyCursor(newAnchor || oldAnchor);
            curEnd = copyCursor(newHead || oldHead);
            if (cursorIsBefore(curEnd, curStart)) {
              var tmp = curStart;
              curStart = curEnd;
              curEnd = tmp;
            }
            linewise = motionArgs.linewise || operatorArgs.linewise;
            if (linewise) {
              // Expand selection to entire line.
              expandSelectionToLine(cm, curStart, curEnd);
            } else if (motionArgs.forward) {
              // Clip to trailing newlines only if the motion goes forward.
              clipToLine(cm, curStart, curEnd);
            }
            mode = 'char';
            var exclusive = !motionArgs.inclusive || linewise;
            cmSel = makeCmSelection(cm, {
              anchor: curStart,
              head: curEnd
            }, mode, exclusive);
          }
          cm.setSelections(cmSel.ranges, cmSel.primary);
          vim.lastMotion = null;
          operatorArgs.repeat = repeat; // For indent in visual mode.
          operatorArgs.registerName = registerName;
          // Keep track of linewise as it affects how paste and change behave.
          operatorArgs.linewise = linewise;
          var operatorMoveTo = operators[operator](
            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);
          if (vim.visualMode) {
            exitVisualMode(cm, operatorMoveTo != null);
          }
          if (operatorMoveTo) {
            cm.setCursor(operatorMoveTo);
          }
        }
      },
      recordLastEdit: function(vim, inputState, actionCommand) {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isPlaying) { return; }
        vim.lastEditInputState = inputState;
        vim.lastEditActionCommand = actionCommand;
        macroModeState.lastInsertModeChanges.changes = [];
        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;
        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;
      }
    };

    /**
     * typedef {Object{line:number,ch:number}} Cursor An object containing the
     *     position of the cursor.
     */
    // All of the functions below return Cursor objects.
    var motions = {
      moveToTopLine: function(cm, _head, motionArgs) {
        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      moveToMiddleLine: function(cm) {
        var range = getUserVisibleLines(cm);
        var line = Math.floor((range.top + range.bottom) * 0.5);
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      moveToBottomLine: function(cm, _head, motionArgs) {
        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;
        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
      },
      expandToLine: function(_cm, head, motionArgs) {
        // Expands forward to end of line, and then to next line if repeat is
        // >1. Does not handle backward motion!
        var cur = head;
        return Pos(cur.line + motionArgs.repeat - 1, Infinity);
      },
      findNext: function(cm, _head, motionArgs) {
        var state = getSearchState(cm);
        var query = state.getQuery();
        if (!query) {
          return;
        }
        var prev = !motionArgs.forward;
        // If search is initiated with ? instead of /, negate direction.
        prev = (state.isReversed()) ? !prev : prev;
        highlightSearchMatches(cm, query);
        return findNext(cm, prev/** prev */, query, motionArgs.repeat);
      },
      /**
       * Find and select the next occurrence of the search query. If the cursor is currently
       * within a match, then find and select the current match. Otherwise, find the next occurrence in the
       * appropriate direction.
       *
       * This differs from `findNext` in the following ways:
       *
       * 1. Instead of only returning the "from", this returns a "from", "to" range.
       * 2. If the cursor is currently inside a search match, this selects the current match
       *    instead of the next match.
       * 3. If there is no associated operator, this will turn on visual mode.
       */
      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {
        var state = getSearchState(cm);
        var query = state.getQuery();

        if (!query) {
          return;
        }

        var prev = !motionArgs.forward;
        prev = (state.isReversed()) ? !prev : prev;

        // next: [from, to] | null
        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);

        // No matches.
        if (!next) {
          return;
        }

        // If there's an operator that will be executed, return the selection.
        if (prevInputState.operator) {
          return next;
        }

        // At this point, we know that there is no accompanying operator -- let's
        // deal with visual mode in order to select an appropriate match.

        var from = next[0];
        // For whatever reason, when we use the "to" as returned by searchcursor.js directly,
        // the resulting selection is extended by 1 char. Let's shrink it so that only the
        // match is selected.
        var to = Pos(next[1].line, next[1].ch - 1);

        if (vim.visualMode) {
          // If we were in visualLine or visualBlock mode, get out of it.
          if (vim.visualLine || vim.visualBlock) {
            vim.visualLine = false;
            vim.visualBlock = false;
            CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: ""});
          }

          // If we're currently in visual mode, we should extend the selection to include
          // the search result.
          var anchor = vim.sel.anchor;
          if (anchor) {
            if (state.isReversed()) {
              if (motionArgs.forward) {
                return [anchor, from];
              }

              return [anchor, to];
            } else {
              if (motionArgs.forward) {
                return [anchor, to];
              }

              return [anchor, from];
            }
          }
        } else {
          // Let's turn visual mode on.
          vim.visualMode = true;
          vim.visualLine = false;
          vim.visualBlock = false;
          CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: ""});
        }

        return prev ? [to, from] : [from, to];
      },
      goToMark: function(cm, _head, motionArgs, vim) {
        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);
        if (pos) {
          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;
        }
        return null;
      },
      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {
        if (vim.visualBlock && motionArgs.sameLine) {
          var sel = vim.sel;
          return [
            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),
            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))
          ];
        } else {
          return ([vim.sel.head, vim.sel.anchor]);
        }
      },
      jumpToMark: function(cm, head, motionArgs, vim) {
        var best = head;
        for (var i = 0; i < motionArgs.repeat; i++) {
          var cursor = best;
          for (var key in vim.marks) {
            if (!isLowerCase(key)) {
              continue;
            }
            var mark = vim.marks[key].find();
            var isWrongDirection = (motionArgs.forward) ?
              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);

            if (isWrongDirection) {
              continue;
            }
            if (motionArgs.linewise && (mark.line == cursor.line)) {
              continue;
            }

            var equal = cursorEqual(cursor, best);
            var between = (motionArgs.forward) ?
              cursorIsBetween(cursor, mark, best) :
              cursorIsBetween(best, mark, cursor);

            if (equal || between) {
              best = mark;
            }
          }
        }

        if (motionArgs.linewise) {
          // Vim places the cursor on the first non-whitespace character of
          // the line if there is one, else it places the cursor at the end
          // of the line, regardless of whether a mark was found.
          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));
        }
        return best;
      },
      moveByCharacters: function(_cm, head, motionArgs) {
        var cur = head;
        var repeat = motionArgs.repeat;
        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;
        return Pos(cur.line, ch);
      },
      moveByLines: function(cm, head, motionArgs, vim) {
        var cur = head;
        var endCh = cur.ch;
        // Depending what our last motion was, we may want to do different
        // things. If our last motion was moving vertically, we want to
        // preserve the HPos from our last horizontal move.  If our last motion
        // was going to the end of a line, moving vertically we should go to
        // the end of the line, etc.
        switch (vim.lastMotion) {
          case this.moveByLines:
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveToColumn:
          case this.moveToEol:
            endCh = vim.lastHPos;
            break;
          default:
            vim.lastHPos = endCh;
        }
        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);
        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;
        var first = cm.firstLine();
        var last = cm.lastLine();
        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);
        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;
        if (hasMarkedText) {
          line = posV.line;
          endCh = posV.ch;
        }
        // Vim go to line begin or line end when cursor at first/last line and
        // move to previous/next line is triggered.
        if (line < first && cur.line == first){
          return this.moveToStartOfLine(cm, head, motionArgs, vim);
        } else if (line > last && cur.line == last){
            return moveToEol(cm, head, motionArgs, vim, true);
        }
        if (motionArgs.toFirstChar){
          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));
          vim.lastHPos = endCh;
        }
        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;
        return Pos(line, endCh);
      },
      moveByDisplayLines: function(cm, head, motionArgs, vim) {
        var cur = head;
        switch (vim.lastMotion) {
          case this.moveByDisplayLines:
          case this.moveByScroll:
          case this.moveByLines:
          case this.moveToColumn:
          case this.moveToEol:
            break;
          default:
            vim.lastHSPos = cm.charCoords(cur,'div').left;
        }
        var repeat = motionArgs.repeat;
        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);
        if (res.hitSide) {
          if (motionArgs.forward) {
            var lastCharCoords = cm.charCoords(res, 'div');
            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };
            var res = cm.coordsChar(goalCoords, 'div');
          } else {
            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');
            resCoords.left = vim.lastHSPos;
            res = cm.coordsChar(resCoords, 'div');
          }
        }
        vim.lastHPos = res.ch;
        return res;
      },
      moveByPage: function(cm, head, motionArgs) {
        // CodeMirror only exposes functions that move the cursor page down, so
        // doing this bad hack to move the cursor and move it back. evalInput
        // will move the cursor to where it should be in the end.
        var curStart = head;
        var repeat = motionArgs.repeat;
        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');
      },
      moveByParagraph: function(cm, head, motionArgs) {
        var dir = motionArgs.forward ? 1 : -1;
        return findParagraph(cm, head, motionArgs.repeat, dir);
      },
      moveBySentence: function(cm, head, motionArgs) {
        var dir = motionArgs.forward ? 1 : -1;
        return findSentence(cm, head, motionArgs.repeat, dir);
      },
      moveByScroll: function(cm, head, motionArgs, vim) {
        var scrollbox = cm.getScrollInfo();
        var curEnd = null;
        var repeat = motionArgs.repeat;
        if (!repeat) {
          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());
        }
        var orig = cm.charCoords(head, 'local');
        motionArgs.repeat = repeat;
        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);
        if (!curEnd) {
          return null;
        }
        var dest = cm.charCoords(curEnd, 'local');
        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);
        return curEnd;
      },
      moveByWords: function(cm, head, motionArgs) {
        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,
            !!motionArgs.wordEnd, !!motionArgs.bigWord);
      },
      moveTillCharacter: function(cm, _head, motionArgs) {
        var repeat = motionArgs.repeat;
        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,
            motionArgs.selectedCharacter);
        var increment = motionArgs.forward ? -1 : 1;
        recordLastCharacterSearch(increment, motionArgs);
        if (!curEnd) return null;
        curEnd.ch += increment;
        return curEnd;
      },
      moveToCharacter: function(cm, head, motionArgs) {
        var repeat = motionArgs.repeat;
        recordLastCharacterSearch(0, motionArgs);
        return moveToCharacter(cm, repeat, motionArgs.forward,
            motionArgs.selectedCharacter) || head;
      },
      moveToSymbol: function(cm, head, motionArgs) {
        var repeat = motionArgs.repeat;
        return findSymbol(cm, repeat, motionArgs.forward,
            motionArgs.selectedCharacter) || head;
      },
      moveToColumn: function(cm, head, motionArgs, vim) {
        var repeat = motionArgs.repeat;
        // repeat is equivalent to which column we want to move to!
        vim.lastHPos = repeat - 1;
        vim.lastHSPos = cm.charCoords(head,'div').left;
        return moveToColumn(cm, repeat);
      },
      moveToEol: function(cm, head, motionArgs, vim) {
        return moveToEol(cm, head, motionArgs, vim, false);
      },
      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {
        // Go to the start of the line where the text begins, or the end for
        // whitespace-only lines
        var cursor = head;
        return Pos(cursor.line,
                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));
      },
      moveToMatchedSymbol: function(cm, head) {
        var cursor = head;
        var line = cursor.line;
        var ch = cursor.ch;
        var lineText = cm.getLine(line);
        var symbol;
        for (; ch < lineText.length; ch++) {
          symbol = lineText.charAt(ch);
          if (symbol && isMatchableSymbol(symbol)) {
            var style = cm.getTokenTypeAt(Pos(line, ch + 1));
            if (style !== "string" && style !== "comment") {
              break;
            }
          }
        }
        if (ch < lineText.length) {
          // Only include angle brackets in analysis if they are being matched.
          var re = (ch === '<' || ch === '>') ? /[(){}[\]<>]/ : /[(){}[\]]/;
          var matched = cm.findMatchingBracket(Pos(line, ch), {bracketRegex: re});
          return matched.to;
        } else {
          return cursor;
        }
      },
      moveToStartOfLine: function(_cm, head) {
        return Pos(head.line, 0);
      },
      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {
        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();
        if (motionArgs.repeatIsExplicit) {
          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');
        }
        return Pos(lineNum,
                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));
      },
      textObjectManipulation: function(cm, head, motionArgs, vim) {
        // TODO: lots of possible exceptions that can be thrown here. Try da(
        //     outside of a () block.
        var mirroredPairs = {'(': ')', ')': '(',
                             '{': '}', '}': '{',
                             '[': ']', ']': '[',
                             '<': '>', '>': '<'};
        var selfPaired = {'\'': true, '"': true, '`': true};

        var character = motionArgs.selectedCharacter;
        // 'b' refers to  '()' block.
        // 'B' refers to  '{}' block.
        if (character == 'b') {
          character = '(';
        } else if (character == 'B') {
          character = '{';
        }

        // Inclusive is the difference between a and i
        // TODO: Instead of using the additional text object map to perform text
        //     object operations, merge the map into the defaultKeyMap and use
        //     motionArgs to define behavior. Define separate entries for 'aw',
        //     'iw', 'a[', 'i[', etc.
        var inclusive = !motionArgs.textObjectInner;

        var tmp;
        if (mirroredPairs[character]) {
          tmp = selectCompanionObject(cm, head, character, inclusive);
        } else if (selfPaired[character]) {
          tmp = findBeginningAndEnd(cm, head, character, inclusive);
        } else if (character === 'W') {
          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,
                                                     true /** bigWord */);
        } else if (character === 'w') {
          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,
                                                     false /** bigWord */);
        } else if (character === 'p') {
          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);
          motionArgs.linewise = true;
          if (vim.visualMode) {
            if (!vim.visualLine) { vim.visualLine = true; }
          } else {
            var operatorArgs = vim.inputState.operatorArgs;
            if (operatorArgs) { operatorArgs.linewise = true; }
            tmp.end.line--;
          }
        } else if (character === 't') {
          tmp = expandTagUnderCursor(cm, head, inclusive);
        } else {
          // No text object defined for this, don't move.
          return null;
        }

        if (!cm.state.vim.visualMode) {
          return [tmp.start, tmp.end];
        } else {
          return expandSelection(cm, tmp.start, tmp.end);
        }
      },

      repeatLastCharacterSearch: function(cm, head, motionArgs) {
        var lastSearch = vimGlobalState.lastCharacterSearch;
        var repeat = motionArgs.repeat;
        var forward = motionArgs.forward === lastSearch.forward;
        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);
        cm.moveH(-increment, 'char');
        motionArgs.inclusive = forward ? true : false;
        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);
        if (!curEnd) {
          cm.moveH(increment, 'char');
          return head;
        }
        curEnd.ch += increment;
        return curEnd;
      }
    };

    function defineMotion(name, fn) {
      motions[name] = fn;
    }

    function fillArray(val, times) {
      var arr = [];
      for (var i = 0; i < times; i++) {
        arr.push(val);
      }
      return arr;
    }
    /**
     * An operator acts on a text selection. It receives the list of selections
     * as input. The corresponding CodeMirror selection is guaranteed to
    * match the input selection.
     */
    var operators = {
      change: function(cm, args, ranges) {
        var finalHead, text;
        var vim = cm.state.vim;
        var anchor = ranges[0].anchor,
            head = ranges[0].head;
        if (!vim.visualMode) {
          text = cm.getRange(anchor, head);
          var lastState = vim.lastEditInputState || {};
          if (lastState.motion == "moveByWords" && !isWhiteSpaceString(text)) {
            // Exclude trailing whitespace if the range is not all whitespace.
            var match = (/\s+$/).exec(text);
            if (match && lastState.motionArgs && lastState.motionArgs.forward) {
              head = offsetCursor(head, 0, - match[0].length);
              text = text.slice(0, - match[0].length);
            }
          }
          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);
          var wasLastLine = cm.firstLine() == cm.lastLine();
          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {
            cm.replaceRange('', prevLineEnd, head);
          } else {
            cm.replaceRange('', anchor, head);
          }
          if (args.linewise) {
            // Push the next line back down, if there is a next line.
            if (!wasLastLine) {
              cm.setCursor(prevLineEnd);
              CodeMirror.commands.newlineAndIndent(cm);
            }
            // make sure cursor ends up at the end of the line.
            anchor.ch = Number.MAX_VALUE;
          }
          finalHead = anchor;
        } else if (args.fullLine) {
            head.ch = Number.MAX_VALUE;
            head.line--;
            cm.setSelection(anchor, head)
            text = cm.getSelection();
            cm.replaceSelection("");
            finalHead = anchor;
        } else {
          text = cm.getSelection();
          var replacement = fillArray('', ranges.length);
          cm.replaceSelections(replacement);
          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
        }
        vimGlobalState.registerController.pushText(
            args.registerName, 'change', text,
            args.linewise, ranges.length > 1);
        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);
      },
      // delete is a javascript keyword.
      'delete': function(cm, args, ranges) {
        var finalHead, text;
        var vim = cm.state.vim;
        if (!vim.visualBlock) {
          var anchor = ranges[0].anchor,
              head = ranges[0].head;
          if (args.linewise &&
              head.line != cm.firstLine() &&
              anchor.line == cm.lastLine() &&
              anchor.line == head.line - 1) {
            // Special case for dd on last line (and first line).
            if (anchor.line == cm.firstLine()) {
              anchor.ch = 0;
            } else {
              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));
            }
          }
          text = cm.getRange(anchor, head);
          cm.replaceRange('', anchor, head);
          finalHead = anchor;
          if (args.linewise) {
            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);
          }
        } else {
          text = cm.getSelection();
          var replacement = fillArray('', ranges.length);
          cm.replaceSelections(replacement);
          finalHead = ranges[0].anchor;
        }
        vimGlobalState.registerController.pushText(
            args.registerName, 'delete', text,
            args.linewise, vim.visualBlock);
        return clipCursorToContent(cm, finalHead);
      },
      indent: function(cm, args, ranges) {
        var vim = cm.state.vim;
        var startLine = ranges[0].anchor.line;
        var endLine = vim.visualBlock ?
          ranges[ranges.length - 1].anchor.line :
          ranges[0].head.line;
        // In visual mode, n> shifts the selection right n times, instead of
        // shifting n lines right once.
        var repeat = (vim.visualMode) ? args.repeat : 1;
        if (args.linewise) {
          // The only way to delete a newline is to delete until the start of
          // the next line, so in linewise mode evalInput will include the next
          // line. We don't want this in indent, so we go back a line.
          endLine--;
        }
        for (var i = startLine; i <= endLine; i++) {
          for (var j = 0; j < repeat; j++) {
            cm.indentLine(i, args.indentRight);
          }
        }
        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
      },
      indentAuto: function(cm, _args, ranges) {
        cm.execCommand("indentAuto");
        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
      },
      changeCase: function(cm, args, ranges, oldAnchor, newHead) {
        var selections = cm.getSelections();
        var swapped = [];
        var toLower = args.toLower;
        for (var j = 0; j < selections.length; j++) {
          var toSwap = selections[j];
          var text = '';
          if (toLower === true) {
            text = toSwap.toLowerCase();
          } else if (toLower === false) {
            text = toSwap.toUpperCase();
          } else {
            for (var i = 0; i < toSwap.length; i++) {
              var character = toSwap.charAt(i);
              text += isUpperCase(character) ? character.toLowerCase() :
                  character.toUpperCase();
            }
          }
          swapped.push(text);
        }
        cm.replaceSelections(swapped);
        if (args.shouldMoveCursor){
          return newHead;
        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {
          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);
        } else if (args.linewise){
          return oldAnchor;
        } else {
          return cursorMin(ranges[0].anchor, ranges[0].head);
        }
      },
      yank: function(cm, args, ranges, oldAnchor) {
        var vim = cm.state.vim;
        var text = cm.getSelection();
        var endPos = vim.visualMode
          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)
          : oldAnchor;
        vimGlobalState.registerController.pushText(
            args.registerName, 'yank',
            text, args.linewise, vim.visualBlock);
        return endPos;
      }
    };

    function defineOperator(name, fn) {
      operators[name] = fn;
    }

    var actions = {
      jumpListWalk: function(cm, actionArgs, vim) {
        if (vim.visualMode) {
          return;
        }
        var repeat = actionArgs.repeat;
        var forward = actionArgs.forward;
        var jumpList = vimGlobalState.jumpList;

        var mark = jumpList.move(cm, forward ? repeat : -repeat);
        var markPos = mark ? mark.find() : undefined;
        markPos = markPos ? markPos : cm.getCursor();
        cm.setCursor(markPos);
      },
      scroll: function(cm, actionArgs, vim) {
        if (vim.visualMode) {
          return;
        }
        var repeat = actionArgs.repeat || 1;
        var lineHeight = cm.defaultTextHeight();
        var top = cm.getScrollInfo().top;
        var delta = lineHeight * repeat;
        var newPos = actionArgs.forward ? top + delta : top - delta;
        var cursor = copyCursor(cm.getCursor());
        var cursorCoords = cm.charCoords(cursor, 'local');
        if (actionArgs.forward) {
          if (newPos > cursorCoords.top) {
             cursor.line += (newPos - cursorCoords.top) / lineHeight;
             cursor.line = Math.ceil(cursor.line);
             cm.setCursor(cursor);
             cursorCoords = cm.charCoords(cursor, 'local');
             cm.scrollTo(null, cursorCoords.top);
          } else {
             // Cursor stays within bounds.  Just reposition the scroll window.
             cm.scrollTo(null, newPos);
          }
        } else {
          var newBottom = newPos + cm.getScrollInfo().clientHeight;
          if (newBottom < cursorCoords.bottom) {
             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;
             cursor.line = Math.floor(cursor.line);
             cm.setCursor(cursor);
             cursorCoords = cm.charCoords(cursor, 'local');
             cm.scrollTo(
                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);
          } else {
             // Cursor stays within bounds.  Just reposition the scroll window.
             cm.scrollTo(null, newPos);
          }
        }
      },
      scrollToCursor: function(cm, actionArgs) {
        var lineNum = cm.getCursor().line;
        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');
        var height = cm.getScrollInfo().clientHeight;
        var y = charCoords.top;
        var lineHeight = charCoords.bottom - y;
        switch (actionArgs.position) {
          case 'center': y = y - (height / 2) + lineHeight;
            break;
          case 'bottom': y = y - height + lineHeight;
            break;
        }
        cm.scrollTo(null, y);
      },
      replayMacro: function(cm, actionArgs, vim) {
        var registerName = actionArgs.selectedCharacter;
        var repeat = actionArgs.repeat;
        var macroModeState = vimGlobalState.macroModeState;
        if (registerName == '@') {
          registerName = macroModeState.latestRegister;
        } else {
          macroModeState.latestRegister = registerName;
        }
        while(repeat--){
          executeMacroRegister(cm, vim, macroModeState, registerName);
        }
      },
      enterMacroRecordMode: function(cm, actionArgs) {
        var macroModeState = vimGlobalState.macroModeState;
        var registerName = actionArgs.selectedCharacter;
        if (vimGlobalState.registerController.isValidRegister(registerName)) {
          macroModeState.enterMacroRecordMode(cm, registerName);
        }
      },
      toggleOverwrite: function(cm) {
        if (!cm.state.overwrite) {
          cm.toggleOverwrite(true);
          cm.setOption('keyMap', 'vim-replace');
          CodeMirror.signal(cm, "vim-mode-change", {mode: "replace"});
        } else {
          cm.toggleOverwrite(false);
          cm.setOption('keyMap', 'vim-insert');
          CodeMirror.signal(cm, "vim-mode-change", {mode: "insert"});
        }
      },
      enterInsertMode: function(cm, actionArgs, vim) {
        if (cm.getOption('readOnly')) { return; }
        vim.insertMode = true;
        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;
        var insertAt = (actionArgs) ? actionArgs.insertAt : null;
        var sel = vim.sel;
        var head = actionArgs.head || cm.getCursor('head');
        var height = cm.listSelections().length;
        if (insertAt == 'eol') {
          head = Pos(head.line, lineLength(cm, head.line));
        } else if (insertAt == 'bol') {
          head = Pos(head.line, 0);
        } else if (insertAt == 'charAfter') {
          head = offsetCursor(head, 0, 1);
        } else if (insertAt == 'firstNonBlank') {
          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);
        } else if (insertAt == 'startOfSelectedArea') {
          if (!vim.visualMode)
              return;
          if (!vim.visualBlock) {
            if (sel.head.line < sel.anchor.line) {
              head = sel.head;
            } else {
              head = Pos(sel.anchor.line, 0);
            }
          } else {
            head = Pos(
                Math.min(sel.head.line, sel.anchor.line),
                Math.min(sel.head.ch, sel.anchor.ch));
            height = Math.abs(sel.head.line - sel.anchor.line) + 1;
          }
        } else if (insertAt == 'endOfSelectedArea') {
            if (!vim.visualMode)
              return;
          if (!vim.visualBlock) {
            if (sel.head.line >= sel.anchor.line) {
              head = offsetCursor(sel.head, 0, 1);
            } else {
              head = Pos(sel.anchor.line, 0);
            }
          } else {
            head = Pos(
                Math.min(sel.head.line, sel.anchor.line),
                Math.max(sel.head.ch + 1, sel.anchor.ch));
            height = Math.abs(sel.head.line - sel.anchor.line) + 1;
          }
        } else if (insertAt == 'inplace') {
          if (vim.visualMode){
            return;
          }
        } else if (insertAt == 'lastEdit') {
          head = getLastEditPos(cm) || head;
        }
        cm.setOption('disableInput', false);
        if (actionArgs && actionArgs.replace) {
          // Handle Replace-mode as a special case of insert mode.
          cm.toggleOverwrite(true);
          cm.setOption('keyMap', 'vim-replace');
          CodeMirror.signal(cm, "vim-mode-change", {mode: "replace"});
        } else {
          cm.toggleOverwrite(false);
          cm.setOption('keyMap', 'vim-insert');
          CodeMirror.signal(cm, "vim-mode-change", {mode: "insert"});
        }
        if (!vimGlobalState.macroModeState.isPlaying) {
          // Only record if not replaying.
          cm.on('change', onChange);
          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);
        }
        if (vim.visualMode) {
          exitVisualMode(cm);
        }
        selectForInsert(cm, head, height);
      },
      toggleVisualMode: function(cm, actionArgs, vim) {
        var repeat = actionArgs.repeat;
        var anchor = cm.getCursor();
        var head;
        // TODO: The repeat should actually select number of characters/lines
        //     equal to the repeat times the size of the previous visual
        //     operation.
        if (!vim.visualMode) {
          // Entering visual mode
          vim.visualMode = true;
          vim.visualLine = !!actionArgs.linewise;
          vim.visualBlock = !!actionArgs.blockwise;
          head = clipCursorToContent(
              cm, Pos(anchor.line, anchor.ch + repeat - 1));
          vim.sel = {
            anchor: anchor,
            head: head
          };
          CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""});
          updateCmSelection(cm);
          updateMark(cm, vim, '<', cursorMin(anchor, head));
          updateMark(cm, vim, '>', cursorMax(anchor, head));
        } else if (vim.visualLine ^ actionArgs.linewise ||
            vim.visualBlock ^ actionArgs.blockwise) {
          // Toggling between modes
          vim.visualLine = !!actionArgs.linewise;
          vim.visualBlock = !!actionArgs.blockwise;
          CodeMirror.signal(cm, "vim-mode-change", {mode: "visual", subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""});
          updateCmSelection(cm);
        } else {
          exitVisualMode(cm);
        }
      },
      reselectLastSelection: function(cm, _actionArgs, vim) {
        var lastSelection = vim.lastSelection;
        if (vim.visualMode) {
          updateLastSelection(cm, vim);
        }
        if (lastSelection) {
          var anchor = lastSelection.anchorMark.find();
          var head = lastSelection.headMark.find();
          if (!anchor || !head) {
            // If the marks have been destroyed due to edits, do nothing.
            return;
          }
          vim.sel = {
            anchor: anchor,
            head: head
          };
          vim.visualMode = true;
          vim.visualLine = lastSelection.visualLine;
          vim.visualBlock = lastSelection.visualBlock;
          updateCmSelection(cm);
          updateMark(cm, vim, '<', cursorMin(anchor, head));
          updateMark(cm, vim, '>', cursorMax(anchor, head));
          CodeMirror.signal(cm, 'vim-mode-change', {
            mode: 'visual',
            subMode: vim.visualLine ? 'linewise' :
                     vim.visualBlock ? 'blockwise' : ''});
        }
      },
      joinLines: function(cm, actionArgs, vim) {
        var curStart, curEnd;
        if (vim.visualMode) {
          curStart = cm.getCursor('anchor');
          curEnd = cm.getCursor('head');
          if (cursorIsBefore(curEnd, curStart)) {
            var tmp = curEnd;
            curEnd = curStart;
            curStart = tmp;
          }
          curEnd.ch = lineLength(cm, curEnd.line) - 1;
        } else {
          // Repeat is the number of lines to join. Minimum 2 lines.
          var repeat = Math.max(actionArgs.repeat, 2);
          curStart = cm.getCursor();
          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,
                                               Infinity));
        }
        var finalCh = 0;
        for (var i = curStart.line; i < curEnd.line; i++) {
          finalCh = lineLength(cm, curStart.line);
          var tmp = Pos(curStart.line + 1,
                        lineLength(cm, curStart.line + 1));
          var text = cm.getRange(curStart, tmp);
          text = actionArgs.keepSpaces
            ? text.replace(/\n\r?/g, '')
            : text.replace(/\n\s*/g, ' ');
          cm.replaceRange(text, curStart, tmp);
        }
        var curFinalPos = Pos(curStart.line, finalCh);
        if (vim.visualMode) {
          exitVisualMode(cm, false);
        }
        cm.setCursor(curFinalPos);
      },
      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {
        vim.insertMode = true;
        var insertAt = copyCursor(cm.getCursor());
        if (insertAt.line === cm.firstLine() && !actionArgs.after) {
          // Special case for inserting newline before start of document.
          cm.replaceRange('\n', Pos(cm.firstLine(), 0));
          cm.setCursor(cm.firstLine(), 0);
        } else {
          insertAt.line = (actionArgs.after) ? insertAt.line :
              insertAt.line - 1;
          insertAt.ch = lineLength(cm, insertAt.line);
          cm.setCursor(insertAt);
          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||
              CodeMirror.commands.newlineAndIndent;
          newlineFn(cm);
        }
        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);
      },
      paste: function(cm, actionArgs, vim) {
        var cur = copyCursor(cm.getCursor());
        var register = vimGlobalState.registerController.getRegister(
            actionArgs.registerName);
        var text = register.toString();
        if (!text) {
          return;
        }
        if (actionArgs.matchIndent) {
          var tabSize = cm.getOption("tabSize");
          // length that considers tabs and tabSize
          var whitespaceLength = function(str) {
            var tabs = (str.split("\t").length - 1);
            var spaces = (str.split(" ").length - 1);
            return tabs * tabSize + spaces * 1;
          };
          var currentLine = cm.getLine(cm.getCursor().line);
          var indent = whitespaceLength(currentLine.match(/^\s*/)[0]);
          // chomp last newline b/c don't want it to match /^\s*/gm
          var chompedText = text.replace(/\n$/, '');
          var wasChomped = text !== chompedText;
          var firstIndent = whitespaceLength(text.match(/^\s*/)[0]);
          var text = chompedText.replace(/^\s*/gm, function(wspace) {
            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
            if (newIndent < 0) {
              return "";
            }
            else if (cm.getOption("indentWithTabs")) {
              var quotient = Math.floor(newIndent / tabSize);
              return Array(quotient + 1).join('\t');
            }
            else {
              return Array(newIndent + 1).join(' ');
            }
          });
          text += wasChomped ? "\n" : "";
        }
        if (actionArgs.repeat > 1) {
          var text = Array(actionArgs.repeat + 1).join(text);
        }
        var linewise = register.linewise;
        var blockwise = register.blockwise;
        if (blockwise) {
          text = text.split('\n');
          if (linewise) {
              text.pop();
          }
          for (var i = 0; i < text.length; i++) {
            text[i] = (text[i] == '') ? ' ' : text[i];
          }
          cur.ch += actionArgs.after ? 1 : 0;
          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);
        } else if (linewise) {
          if(vim.visualMode) {
            text = vim.visualLine ? text.slice(0, -1) : '\n' + text.slice(0, text.length - 1) + '\n';
          } else if (actionArgs.after) {
            // Move the newline at the end to the start instead, and paste just
            // before the newline character of the line we are on right now.
            text = '\n' + text.slice(0, text.length - 1);
            cur.ch = lineLength(cm, cur.line);
          } else {
            cur.ch = 0;
          }
        } else {
          cur.ch += actionArgs.after ? 1 : 0;
        }
        var curPosFinal;
        var idx;
        if (vim.visualMode) {
          //  save the pasted text for reselection if the need arises
          vim.lastPastedText = text;
          var lastSelectionCurEnd;
          var selectedArea = getSelectedAreaRange(cm, vim);
          var selectionStart = selectedArea[0];
          var selectionEnd = selectedArea[1];
          var selectedText = cm.getSelection();
          var selections = cm.listSelections();
          var emptyStrings = new Array(selections.length).join('1').split('1');
          // save the curEnd marker before it get cleared due to cm.replaceRange.
          if (vim.lastSelection) {
            lastSelectionCurEnd = vim.lastSelection.headMark.find();
          }
          // push the previously selected text to unnamed register
          vimGlobalState.registerController.unnamedRegister.setText(selectedText);
          if (blockwise) {
            // first delete the selected text
            cm.replaceSelections(emptyStrings);
            // Set new selections as per the block length of the yanked text
            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);
            cm.setCursor(selectionStart);
            selectBlock(cm, selectionEnd);
            cm.replaceSelections(text);
            curPosFinal = selectionStart;
          } else if (vim.visualBlock) {
            cm.replaceSelections(emptyStrings);
            cm.setCursor(selectionStart);
            cm.replaceRange(text, selectionStart, selectionStart);
            curPosFinal = selectionStart;
          } else {
            cm.replaceRange(text, selectionStart, selectionEnd);
            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);
          }
          // restore the the curEnd marker
          if(lastSelectionCurEnd) {
            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);
          }
          if (linewise) {
            curPosFinal.ch=0;
          }
        } else {
          if (blockwise) {
            cm.setCursor(cur);
            for (var i = 0; i < text.length; i++) {
              var line = cur.line+i;
              if (line > cm.lastLine()) {
                cm.replaceRange('\n',  Pos(line, 0));
              }
              var lastCh = lineLength(cm, line);
              if (lastCh < cur.ch) {
                extendLineToColumn(cm, line, cur.ch);
              }
            }
            cm.setCursor(cur);
            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));
            cm.replaceSelections(text);
            curPosFinal = cur;
          } else {
            cm.replaceRange(text, cur);
            // Now fine tune the cursor to where we want it.
            if (linewise && actionArgs.after) {
              curPosFinal = Pos(
              cur.line + 1,
              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));
            } else if (linewise && !actionArgs.after) {
              curPosFinal = Pos(
                cur.line,
                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));
            } else if (!linewise && actionArgs.after) {
              idx = cm.indexFromPos(cur);
              curPosFinal = cm.posFromIndex(idx + text.length - 1);
            } else {
              idx = cm.indexFromPos(cur);
              curPosFinal = cm.posFromIndex(idx + text.length);
            }
          }
        }
        if (vim.visualMode) {
          exitVisualMode(cm, false);
        }
        cm.setCursor(curPosFinal);
      },
      undo: function(cm, actionArgs) {
        cm.operation(function() {
          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();
          cm.setCursor(cm.getCursor('anchor'));
        });
      },
      redo: function(cm, actionArgs) {
        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();
      },
      setRegister: function(_cm, actionArgs, vim) {
        vim.inputState.registerName = actionArgs.selectedCharacter;
      },
      setMark: function(cm, actionArgs, vim) {
        var markName = actionArgs.selectedCharacter;
        updateMark(cm, vim, markName, cm.getCursor());
      },
      replace: function(cm, actionArgs, vim) {
        var replaceWith = actionArgs.selectedCharacter;
        var curStart = cm.getCursor();
        var replaceTo;
        var curEnd;
        var selections = cm.listSelections();
        if (vim.visualMode) {
          curStart = cm.getCursor('start');
          curEnd = cm.getCursor('end');
        } else {
          var line = cm.getLine(curStart.line);
          replaceTo = curStart.ch + actionArgs.repeat;
          if (replaceTo > line.length) {
            replaceTo=line.length;
          }
          curEnd = Pos(curStart.line, replaceTo);
        }
        if (replaceWith=='\n') {
          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);
          // special case, where vim help says to replace by just one line-break
          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);
        } else {
          var replaceWithStr = cm.getRange(curStart, curEnd);
          //replace all characters in range by selected, but keep linebreaks
          replaceWithStr = replaceWithStr.replace(/[^\n]/g, replaceWith);
          if (vim.visualBlock) {
            // Tabs are split in visua block before replacing
            var spaces = new Array(cm.getOption("tabSize")+1).join(' ');
            replaceWithStr = cm.getSelection();
            replaceWithStr = replaceWithStr.replace(/\t/g, spaces).replace(/[^\n]/g, replaceWith).split('\n');
            cm.replaceSelections(replaceWithStr);
          } else {
            cm.replaceRange(replaceWithStr, curStart, curEnd);
          }
          if (vim.visualMode) {
            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?
                         selections[0].anchor : selections[0].head;
            cm.setCursor(curStart);
            exitVisualMode(cm, false);
          } else {
            cm.setCursor(offsetCursor(curEnd, 0, -1));
          }
        }
      },
      incrementNumberToken: function(cm, actionArgs) {
        var cur = cm.getCursor();
        var lineStr = cm.getLine(cur.line);
        var re = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi;
        var match;
        var start;
        var end;
        var numberStr;
        while ((match = re.exec(lineStr)) !== null) {
          start = match.index;
          end = start + match[0].length;
          if (cur.ch < end)break;
        }
        if (!actionArgs.backtrack && (end <= cur.ch))return;
        if (match) {
          var baseStr = match[2] || match[4]
          var digits = match[3] || match[5]
          var increment = actionArgs.increase ? 1 : -1;
          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];
          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);
          numberStr = number.toString(base);
          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''
          if (numberStr.charAt(0) === '-') {
            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);
          } else {
            numberStr = baseStr + zeroPadding + numberStr;
          }
          var from = Pos(cur.line, start);
          var to = Pos(cur.line, end);
          cm.replaceRange(numberStr, from, to);
        } else {
          return;
        }
        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));
      },
      repeatLastEdit: function(cm, actionArgs, vim) {
        var lastEditInputState = vim.lastEditInputState;
        if (!lastEditInputState) { return; }
        var repeat = actionArgs.repeat;
        if (repeat && actionArgs.repeatIsExplicit) {
          vim.lastEditInputState.repeatOverride = repeat;
        } else {
          repeat = vim.lastEditInputState.repeatOverride || repeat;
        }
        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);
      },
      indent: function(cm, actionArgs) {
        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);
      },
      exitInsertMode: exitInsertMode
    };

    function defineAction(name, fn) {
      actions[name] = fn;
    }

    /*
     * Below are miscellaneous utility functions used by vim.js
     */

    /**
     * Clips cursor to ensure that line is within the buffer's range
     * If includeLineBreak is true, then allow cur.ch == lineLength.
     */
    function clipCursorToContent(cm, cur) {
      var vim = cm.state.vim;
      var includeLineBreak = vim.insertMode || vim.visualMode;
      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );
      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;
      var ch = Math.min(Math.max(0, cur.ch), maxCh);
      return Pos(line, ch);
    }
    function copyArgs(args) {
      var ret = {};
      for (var prop in args) {
        if (args.hasOwnProperty(prop)) {
          ret[prop] = args[prop];
        }
      }
      return ret;
    }
    function offsetCursor(cur, offsetLine, offsetCh) {
      if (typeof offsetLine === 'object') {
        offsetCh = offsetLine.ch;
        offsetLine = offsetLine.line;
      }
      return Pos(cur.line + offsetLine, cur.ch + offsetCh);
    }
    function commandMatches(keys, keyMap, context, inputState) {
      // Partial matches are not applied. They inform the key handler
      // that the current key sequence is a subsequence of a valid key
      // sequence, so that the key buffer is not cleared.
      var match, partial = [], full = [];
      for (var i = 0; i < keyMap.length; i++) {
        var command = keyMap[i];
        if (context == 'insert' && command.context != 'insert' ||
            command.context && command.context != context ||
            inputState.operator && command.type == 'action' ||
            !(match = commandMatch(keys, command.keys))) { continue; }
        if (match == 'partial') { partial.push(command); }
        if (match == 'full') { full.push(command); }
      }
      return {
        partial: partial.length && partial,
        full: full.length && full
      };
    }
    function commandMatch(pressed, mapped) {
      if (mapped.slice(-11) == '<character>') {
        // Last character matches anything.
        var prefixLen = mapped.length - 11;
        var pressedPrefix = pressed.slice(0, prefixLen);
        var mappedPrefix = mapped.slice(0, prefixLen);
        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :
               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;
      } else {
        return pressed == mapped ? 'full' :
               mapped.indexOf(pressed) == 0 ? 'partial' : false;
      }
    }
    function lastChar(keys) {
      var match = /^.*(<[^>]+>)$/.exec(keys);
      var selectedCharacter = match ? match[1] : keys.slice(-1);
      if (selectedCharacter.length > 1){
        switch(selectedCharacter){
          case '<CR>':
            selectedCharacter='\n';
            break;
          case '<Space>':
            selectedCharacter=' ';
            break;
          default:
            selectedCharacter='';
            break;
        }
      }
      return selectedCharacter;
    }
    function repeatFn(cm, fn, repeat) {
      return function() {
        for (var i = 0; i < repeat; i++) {
          fn(cm);
        }
      };
    }
    function copyCursor(cur) {
      return Pos(cur.line, cur.ch);
    }
    function cursorEqual(cur1, cur2) {
      return cur1.ch == cur2.ch && cur1.line == cur2.line;
    }
    function cursorIsBefore(cur1, cur2) {
      if (cur1.line < cur2.line) {
        return true;
      }
      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {
        return true;
      }
      return false;
    }
    function cursorMin(cur1, cur2) {
      if (arguments.length > 2) {
        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));
      }
      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;
    }
    function cursorMax(cur1, cur2) {
      if (arguments.length > 2) {
        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));
      }
      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;
    }
    function cursorIsBetween(cur1, cur2, cur3) {
      // returns true if cur2 is between cur1 and cur3.
      var cur1before2 = cursorIsBefore(cur1, cur2);
      var cur2before3 = cursorIsBefore(cur2, cur3);
      return cur1before2 && cur2before3;
    }
    function lineLength(cm, lineNum) {
      return cm.getLine(lineNum).length;
    }
    function trim(s) {
      if (s.trim) {
        return s.trim();
      }
      return s.replace(/^\s+|\s+$/g, '');
    }
    function escapeRegex(s) {
      return s.replace(/([.?*+$\[\]\/\\(){}|\-])/g, '\\$1');
    }
    function extendLineToColumn(cm, lineNum, column) {
      var endCh = lineLength(cm, lineNum);
      var spaces = new Array(column-endCh+1).join(' ');
      cm.setCursor(Pos(lineNum, endCh));
      cm.replaceRange(spaces, cm.getCursor());
    }
    // This functions selects a rectangular block
    // of text with selectionEnd as any of its corner
    // Height of block:
    // Difference in selectionEnd.line and first/last selection.line
    // Width of the block:
    // Distance between selectionEnd.ch and any(first considered here) selection.ch
    function selectBlock(cm, selectionEnd) {
      var selections = [], ranges = cm.listSelections();
      var head = copyCursor(cm.clipPos(selectionEnd));
      var isClipped = !cursorEqual(selectionEnd, head);
      var curHead = cm.getCursor('head');
      var primIndex = getIndex(ranges, curHead);
      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);
      var max = ranges.length - 1;
      var index = max - primIndex > primIndex ? max : 0;
      var base = ranges[index].anchor;

      var firstLine = Math.min(base.line, head.line);
      var lastLine = Math.max(base.line, head.line);
      var baseCh = base.ch, headCh = head.ch;

      var dir = ranges[index].head.ch - baseCh;
      var newDir = headCh - baseCh;
      if (dir > 0 && newDir <= 0) {
        baseCh++;
        if (!isClipped) { headCh--; }
      } else if (dir < 0 && newDir >= 0) {
        baseCh--;
        if (!wasClipped) { headCh++; }
      } else if (dir < 0 && newDir == -1) {
        baseCh--;
        headCh++;
      }
      for (var line = firstLine; line <= lastLine; line++) {
        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};
        selections.push(range);
      }
      cm.setSelections(selections);
      selectionEnd.ch = headCh;
      base.ch = baseCh;
      return base;
    }
    function selectForInsert(cm, head, height) {
      var sel = [];
      for (var i = 0; i < height; i++) {
        var lineHead = offsetCursor(head, i, 0);
        sel.push({anchor: lineHead, head: lineHead});
      }
      cm.setSelections(sel, 0);
    }
    // getIndex returns the index of the cursor in the selections.
    function getIndex(ranges, cursor, end) {
      for (var i = 0; i < ranges.length; i++) {
        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);
        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);
        if (atAnchor || atHead) {
          return i;
        }
      }
      return -1;
    }
    function getSelectedAreaRange(cm, vim) {
      var lastSelection = vim.lastSelection;
      var getCurrentSelectedAreaRange = function() {
        var selections = cm.listSelections();
        var start =  selections[0];
        var end = selections[selections.length-1];
        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;
        return [selectionStart, selectionEnd];
      };
      var getLastSelectedAreaRange = function() {
        var selectionStart = cm.getCursor();
        var selectionEnd = cm.getCursor();
        var block = lastSelection.visualBlock;
        if (block) {
          var width = block.width;
          var height = block.height;
          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);
          var selections = [];
          // selectBlock creates a 'proper' rectangular block.
          // We do not want that in all cases, so we manually set selections.
          for (var i = selectionStart.line; i < selectionEnd.line; i++) {
            var anchor = Pos(i, selectionStart.ch);
            var head = Pos(i, selectionEnd.ch);
            var range = {anchor: anchor, head: head};
            selections.push(range);
          }
          cm.setSelections(selections);
        } else {
          var start = lastSelection.anchorMark.find();
          var end = lastSelection.headMark.find();
          var line = end.line - start.line;
          var ch = end.ch - start.ch;
          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};
          if (lastSelection.visualLine) {
            selectionStart = Pos(selectionStart.line, 0);
            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));
          }
          cm.setSelection(selectionStart, selectionEnd);
        }
        return [selectionStart, selectionEnd];
      };
      if (!vim.visualMode) {
      // In case of replaying the action.
        return getLastSelectedAreaRange();
      } else {
        return getCurrentSelectedAreaRange();
      }
    }
    // Updates the previous selection with the current selection's values. This
    // should only be called in visual mode.
    function updateLastSelection(cm, vim) {
      var anchor = vim.sel.anchor;
      var head = vim.sel.head;
      // To accommodate the effect of lastPastedText in the last selection
      if (vim.lastPastedText) {
        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);
        vim.lastPastedText = null;
      }
      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),
                           'headMark': cm.setBookmark(head),
                           'anchor': copyCursor(anchor),
                           'head': copyCursor(head),
                           'visualMode': vim.visualMode,
                           'visualLine': vim.visualLine,
                           'visualBlock': vim.visualBlock};
    }
    function expandSelection(cm, start, end) {
      var sel = cm.state.vim.sel;
      var head = sel.head;
      var anchor = sel.anchor;
      var tmp;
      if (cursorIsBefore(end, start)) {
        tmp = end;
        end = start;
        start = tmp;
      }
      if (cursorIsBefore(head, anchor)) {
        head = cursorMin(start, head);
        anchor = cursorMax(anchor, end);
      } else {
        anchor = cursorMin(start, anchor);
        head = cursorMax(head, end);
        head = offsetCursor(head, 0, -1);
        if (head.ch == -1 && head.line != cm.firstLine()) {
          head = Pos(head.line - 1, lineLength(cm, head.line - 1));
        }
      }
      return [anchor, head];
    }
    /**
     * Updates the CodeMirror selection to match the provided vim selection.
     * If no arguments are given, it uses the current vim selection state.
     */
    function updateCmSelection(cm, sel, mode) {
      var vim = cm.state.vim;
      sel = sel || vim.sel;
      var mode = mode ||
        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';
      var cmSel = makeCmSelection(cm, sel, mode);
      cm.setSelections(cmSel.ranges, cmSel.primary);
      updateFakeCursor(cm);
    }
    function makeCmSelection(cm, sel, mode, exclusive) {
      var head = copyCursor(sel.head);
      var anchor = copyCursor(sel.anchor);
      if (mode == 'char') {
        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
        head = offsetCursor(sel.head, 0, headOffset);
        anchor = offsetCursor(sel.anchor, 0, anchorOffset);
        return {
          ranges: [{anchor: anchor, head: head}],
          primary: 0
        };
      } else if (mode == 'line') {
        if (!cursorIsBefore(sel.head, sel.anchor)) {
          anchor.ch = 0;

          var lastLine = cm.lastLine();
          if (head.line > lastLine) {
            head.line = lastLine;
          }
          head.ch = lineLength(cm, head.line);
        } else {
          head.ch = 0;
          anchor.ch = lineLength(cm, anchor.line);
        }
        return {
          ranges: [{anchor: anchor, head: head}],
          primary: 0
        };
      } else if (mode == 'block') {
        var top = Math.min(anchor.line, head.line),
            left = Math.min(anchor.ch, head.ch),
            bottom = Math.max(anchor.line, head.line),
            right = Math.max(anchor.ch, head.ch) + 1;
        var height = bottom - top + 1;
        var primary = head.line == top ? 0 : height - 1;
        var ranges = [];
        for (var i = 0; i < height; i++) {
          ranges.push({
            anchor: Pos(top + i, left),
            head: Pos(top + i, right)
          });
        }
        return {
          ranges: ranges,
          primary: primary
        };
      }
    }
    function getHead(cm) {
      var cur = cm.getCursor('head');
      if (cm.getSelection().length == 1) {
        // Small corner case when only 1 character is selected. The "real"
        // head is the left of head and anchor.
        cur = cursorMin(cur, cm.getCursor('anchor'));
      }
      return cur;
    }

    /**
     * If moveHead is set to false, the CodeMirror selection will not be
     * touched. The caller assumes the responsibility of putting the cursor
    * in the right place.
     */
    function exitVisualMode(cm, moveHead) {
      var vim = cm.state.vim;
      if (moveHead !== false) {
        cm.setCursor(clipCursorToContent(cm, vim.sel.head));
      }
      updateLastSelection(cm, vim);
      vim.visualMode = false;
      vim.visualLine = false;
      vim.visualBlock = false;
      if (!vim.insertMode) CodeMirror.signal(cm, "vim-mode-change", {mode: "normal"});
      clearFakeCursor(vim);
    }

    // Remove any trailing newlines from the selection. For
    // example, with the caret at the start of the last word on the line,
    // 'dw' should word, but not the newline, while 'w' should advance the
    // caret to the first character of the next line.
    function clipToLine(cm, curStart, curEnd) {
      var selection = cm.getRange(curStart, curEnd);
      // Only clip if the selection ends with trailing newline + whitespace
      if (/\n\s*$/.test(selection)) {
        var lines = selection.split('\n');
        // We know this is all whitespace.
        lines.pop();

        // Cases:
        // 1. Last word is an empty line - do not clip the trailing '\n'
        // 2. Last word is not an empty line - clip the trailing '\n'
        var line;
        // Find the line containing the last word, and clip all whitespace up
        // to it.
        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {
          curEnd.line--;
          curEnd.ch = 0;
        }
        // If the last word is not an empty line, clip an additional newline
        if (line) {
          curEnd.line--;
          curEnd.ch = lineLength(cm, curEnd.line);
        } else {
          curEnd.ch = 0;
        }
      }
    }

    // Expand the selection to line ends.
    function expandSelectionToLine(_cm, curStart, curEnd) {
      curStart.ch = 0;
      curEnd.ch = 0;
      curEnd.line++;
    }

    function findFirstNonWhiteSpaceCharacter(text) {
      if (!text) {
        return 0;
      }
      var firstNonWS = text.search(/\S/);
      return firstNonWS == -1 ? text.length : firstNonWS;
    }

    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {
      var cur = getHead(cm);
      var line = cm.getLine(cur.line);
      var idx = cur.ch;

      // Seek to first word or non-whitespace character, depending on if
      // noSymbol is true.
      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];
      while (!test(line.charAt(idx))) {
        idx++;
        if (idx >= line.length) { return null; }
      }

      if (bigWord) {
        test = bigWordCharTest[0];
      } else {
        test = wordCharTest[0];
        if (!test(line.charAt(idx))) {
          test = wordCharTest[1];
        }
      }

      var end = idx, start = idx;
      while (test(line.charAt(end)) && end < line.length) { end++; }
      while (test(line.charAt(start)) && start >= 0) { start--; }
      start++;

      if (inclusive) {
        // If present, include all whitespace after word.
        // Otherwise, include all whitespace before word, except indentation.
        var wordEnd = end;
        while (/\s/.test(line.charAt(end)) && end < line.length) { end++; }
        if (wordEnd == end) {
          var wordStart = start;
          while (/\s/.test(line.charAt(start - 1)) && start > 0) { start--; }
          if (!start) { start = wordStart; }
        }
      }
      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };
    }

    /**
     * Depends on the following:
     *
     * - editor mode should be htmlmixedmode / xml
     * - mode/xml/xml.js should be loaded
     * - addon/fold/xml-fold.js should be loaded
     *
     * If any of the above requirements are not true, this function noops.
     *
     * This is _NOT_ a 100% accurate implementation of vim tag text objects.
     * The following caveats apply (based off cursory testing, I'm sure there
     * are other discrepancies):
     *
     * - Does not work inside comments:
     *   ```
     *   <!-- <div>broken</div> -->
     *   ```
     * - Does not work when tags have different cases:
     *   ```
     *   <div>broken</DIV>
     *   ```
     * - Does not work when cursor is inside a broken tag:
     *   ```
     *   <div><brok><en></div>
     *   ```
     */
    function expandTagUnderCursor(cm, head, inclusive) {
      var cur = head;
      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {
        return { start: cur, end: cur };
      }

      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);
      if (!tags || !tags.open || !tags.close) {
        return { start: cur, end: cur };
      }

      if (inclusive) {
        return { start: tags.open.from, end: tags.close.to };
      }
      return { start: tags.open.to, end: tags.close.from };
    }

    function recordJumpPosition(cm, oldCur, newCur) {
      if (!cursorEqual(oldCur, newCur)) {
        vimGlobalState.jumpList.add(cm, oldCur, newCur);
      }
    }

    function recordLastCharacterSearch(increment, args) {
        vimGlobalState.lastCharacterSearch.increment = increment;
        vimGlobalState.lastCharacterSearch.forward = args.forward;
        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;
    }

    var symbolToMode = {
        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',
        '[': 'section', ']': 'section',
        '*': 'comment', '/': 'comment',
        'm': 'method', 'M': 'method',
        '#': 'preprocess'
    };
    var findSymbolModes = {
      bracket: {
        isComplete: function(state) {
          if (state.nextCh === state.symb) {
            state.depth++;
            if (state.depth >= 1)return true;
          } else if (state.nextCh === state.reverseSymb) {
            state.depth--;
          }
          return false;
        }
      },
      section: {
        init: function(state) {
          state.curMoveThrough = true;
          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';
        },
        isComplete: function(state) {
          return state.index === 0 && state.nextCh === state.symb;
        }
      },
      comment: {
        isComplete: function(state) {
          var found = state.lastCh === '*' && state.nextCh === '/';
          state.lastCh = state.nextCh;
          return found;
        }
      },
      // TODO: The original Vim implementation only operates on level 1 and 2.
      // The current implementation doesn't check for code block level and
      // therefore it operates on any levels.
      method: {
        init: function(state) {
          state.symb = (state.symb === 'm' ? '{' : '}');
          state.reverseSymb = state.symb === '{' ? '}' : '{';
        },
        isComplete: function(state) {
          if (state.nextCh === state.symb)return true;
          return false;
        }
      },
      preprocess: {
        init: function(state) {
          state.index = 0;
        },
        isComplete: function(state) {
          if (state.nextCh === '#') {
            var token = state.lineText.match(/^#(\w+)/)[1];
            if (token === 'endif') {
              if (state.forward && state.depth === 0) {
                return true;
              }
              state.depth++;
            } else if (token === 'if') {
              if (!state.forward && state.depth === 0) {
                return true;
              }
              state.depth--;
            }
            if (token === 'else' && state.depth === 0)return true;
          }
          return false;
        }
      }
    };
    function findSymbol(cm, repeat, forward, symb) {
      var cur = copyCursor(cm.getCursor());
      var increment = forward ? 1 : -1;
      var endLine = forward ? cm.lineCount() : -1;
      var curCh = cur.ch;
      var line = cur.line;
      var lineText = cm.getLine(line);
      var state = {
        lineText: lineText,
        nextCh: lineText.charAt(curCh),
        lastCh: null,
        index: curCh,
        symb: symb,
        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],
        forward: forward,
        depth: 0,
        curMoveThrough: false
      };
      var mode = symbolToMode[symb];
      if (!mode)return cur;
      var init = findSymbolModes[mode].init;
      var isComplete = findSymbolModes[mode].isComplete;
      if (init) { init(state); }
      while (line !== endLine && repeat) {
        state.index += increment;
        state.nextCh = state.lineText.charAt(state.index);
        if (!state.nextCh) {
          line += increment;
          state.lineText = cm.getLine(line) || '';
          if (increment > 0) {
            state.index = 0;
          } else {
            var lineLen = state.lineText.length;
            state.index = (lineLen > 0) ? (lineLen-1) : 0;
          }
          state.nextCh = state.lineText.charAt(state.index);
        }
        if (isComplete(state)) {
          cur.line = line;
          cur.ch = state.index;
          repeat--;
        }
      }
      if (state.nextCh || state.curMoveThrough) {
        return Pos(line, state.index);
      }
      return cur;
    }

    /*
     * Returns the boundaries of the next word. If the cursor in the middle of
     * the word, then returns the boundaries of the current word, starting at
     * the cursor. If the cursor is at the start/end of a word, and we are going
     * forward/backward, respectively, find the boundaries of the next word.
     *
     * @param {CodeMirror} cm CodeMirror object.
     * @param {Cursor} cur The cursor position.
     * @param {boolean} forward True to search forward. False to search
     *     backward.
     * @param {boolean} bigWord True if punctuation count as part of the word.
     *     False if only [a-zA-Z0-9] characters count as part of the word.
     * @param {boolean} emptyLineIsWord True if empty lines should be treated
     *     as words.
     * @return {Object{from:number, to:number, line: number}} The boundaries of
     *     the word, or null if there are no more words.
     */
    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {
      var lineNum = cur.line;
      var pos = cur.ch;
      var line = cm.getLine(lineNum);
      var dir = forward ? 1 : -1;
      var charTests = bigWord ? bigWordCharTest: wordCharTest;

      if (emptyLineIsWord && line == '') {
        lineNum += dir;
        line = cm.getLine(lineNum);
        if (!isLine(cm, lineNum)) {
          return null;
        }
        pos = (forward) ? 0 : line.length;
      }

      while (true) {
        if (emptyLineIsWord && line == '') {
          return { from: 0, to: 0, line: lineNum };
        }
        var stop = (dir > 0) ? line.length : -1;
        var wordStart = stop, wordEnd = stop;
        // Find bounds of next word.
        while (pos != stop) {
          var foundWord = false;
          for (var i = 0; i < charTests.length && !foundWord; ++i) {
            if (charTests[i](line.charAt(pos))) {
              wordStart = pos;
              // Advance to end of word.
              while (pos != stop && charTests[i](line.charAt(pos))) {
                pos += dir;
              }
              wordEnd = pos;
              foundWord = wordStart != wordEnd;
              if (wordStart == cur.ch && lineNum == cur.line &&
                  wordEnd == wordStart + dir) {
                // We started at the end of a word. Find the next one.
                continue;
              } else {
                return {
                  from: Math.min(wordStart, wordEnd + 1),
                  to: Math.max(wordStart, wordEnd),
                  line: lineNum };
              }
            }
          }
          if (!foundWord) {
            pos += dir;
          }
        }
        // Advance to next/prev line.
        lineNum += dir;
        if (!isLine(cm, lineNum)) {
          return null;
        }
        line = cm.getLine(lineNum);
        pos = (dir > 0) ? 0 : line.length;
      }
    }

    /**
     * @param {CodeMirror} cm CodeMirror object.
     * @param {Pos} cur The position to start from.
     * @param {int} repeat Number of words to move past.
     * @param {boolean} forward True to search forward. False to search
     *     backward.
     * @param {boolean} wordEnd True to move to end of word. False to move to
     *     beginning of word.
     * @param {boolean} bigWord True if punctuation count as part of the word.
     *     False if only alphabet characters count as part of the word.
     * @return {Cursor} The position the cursor should move to.
     */
    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {
      var curStart = copyCursor(cur);
      var words = [];
      if (forward && !wordEnd || !forward && wordEnd) {
        repeat++;
      }
      // For 'e', empty lines are not considered words, go figure.
      var emptyLineIsWord = !(forward && wordEnd);
      for (var i = 0; i < repeat; i++) {
        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);
        if (!word) {
          var eodCh = lineLength(cm, cm.lastLine());
          words.push(forward
              ? {line: cm.lastLine(), from: eodCh, to: eodCh}
              : {line: 0, from: 0, to: 0});
          break;
        }
        words.push(word);
        cur = Pos(word.line, forward ? (word.to - 1) : word.from);
      }
      var shortCircuit = words.length != repeat;
      var firstWord = words[0];
      var lastWord = words.pop();
      if (forward && !wordEnd) {
        // w
        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {
          // We did not start in the middle of a word. Discard the extra word at the end.
          lastWord = words.pop();
        }
        return Pos(lastWord.line, lastWord.from);
      } else if (forward && wordEnd) {
        return Pos(lastWord.line, lastWord.to - 1);
      } else if (!forward && wordEnd) {
        // ge
        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {
          // We did not start in the middle of a word. Discard the extra word at the end.
          lastWord = words.pop();
        }
        return Pos(lastWord.line, lastWord.to);
      } else {
        // b
        return Pos(lastWord.line, lastWord.from);
      }
    }

    function moveToEol(cm, head, motionArgs, vim, keepHPos) {
      var cur = head;
      var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);
      var end=cm.clipPos(retval);
      end.ch--;
      if (!keepHPos) {
        vim.lastHPos = Infinity;
        vim.lastHSPos = cm.charCoords(end,'div').left;
      }
      return retval;
    }

    function moveToCharacter(cm, repeat, forward, character) {
      var cur = cm.getCursor();
      var start = cur.ch;
      var idx;
      for (var i = 0; i < repeat; i ++) {
        var line = cm.getLine(cur.line);
        idx = charIdxInLine(start, line, character, forward, true);
        if (idx == -1) {
          return null;
        }
        start = idx;
      }
      return Pos(cm.getCursor().line, idx);
    }

    function moveToColumn(cm, repeat) {
      // repeat is always >= 1, so repeat - 1 always corresponds
      // to the column we want to go to.
      var line = cm.getCursor().line;
      return clipCursorToContent(cm, Pos(line, repeat - 1));
    }

    function updateMark(cm, vim, markName, pos) {
      if (!inArray(markName, validMarks)) {
        return;
      }
      if (vim.marks[markName]) {
        vim.marks[markName].clear();
      }
      vim.marks[markName] = cm.setBookmark(pos);
    }

    function charIdxInLine(start, line, character, forward, includeChar) {
      // Search for char in line.
      // motion_options: {forward, includeChar}
      // If includeChar = true, include it too.
      // If forward = true, search forward, else search backwards.
      // If char is not found on this line, do nothing
      var idx;
      if (forward) {
        idx = line.indexOf(character, start + 1);
        if (idx != -1 && !includeChar) {
          idx -= 1;
        }
      } else {
        idx = line.lastIndexOf(character, start - 1);
        if (idx != -1 && !includeChar) {
          idx += 1;
        }
      }
      return idx;
    }

    function findParagraph(cm, head, repeat, dir, inclusive) {
      var line = head.line;
      var min = cm.firstLine();
      var max = cm.lastLine();
      var start, end, i = line;
      function isEmpty(i) { return !cm.getLine(i); }
      function isBoundary(i, dir, any) {
        if (any) { return isEmpty(i) != isEmpty(i + dir); }
        return !isEmpty(i) && isEmpty(i + dir);
      }
      if (dir) {
        while (min <= i && i <= max && repeat > 0) {
          if (isBoundary(i, dir)) { repeat--; }
          i += dir;
        }
        return new Pos(i, 0);
      }

      var vim = cm.state.vim;
      if (vim.visualLine && isBoundary(line, 1, true)) {
        var anchor = vim.sel.anchor;
        if (isBoundary(anchor.line, -1, true)) {
          if (!inclusive || anchor.line != line) {
            line += 1;
          }
        }
      }
      var startState = isEmpty(line);
      for (i = line; i <= max && repeat; i++) {
        if (isBoundary(i, 1, true)) {
          if (!inclusive || isEmpty(i) != startState) {
            repeat--;
          }
        }
      }
      end = new Pos(i, 0);
      // select boundary before paragraph for the last one
      if (i > max && !startState) { startState = true; }
      else { inclusive = false; }
      for (i = line; i > min; i--) {
        if (!inclusive || isEmpty(i) == startState || i == line) {
          if (isBoundary(i, -1, true)) { break; }
        }
      }
      start = new Pos(i, 0);
      return { start: start, end: end };
    }

    function findSentence(cm, cur, repeat, dir) {

      /*
        Takes an index object
        {
          line: the line string,
          ln: line number,
          pos: index in line,
          dir: direction of traversal (-1 or 1)
        }
        and modifies the line, ln, and pos members to represent the
        next valid position or sets them to null if there are
        no more valid positions.
       */
      function nextChar(cm, idx) {
        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {
          idx.ln += idx.dir;
          if (!isLine(cm, idx.ln)) {
            idx.line = null;
            idx.ln = null;
            idx.pos = null;
            return;
          }
          idx.line = cm.getLine(idx.ln);
          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;
        }
        else {
          idx.pos += idx.dir;
        }
      }

      /*
        Performs one iteration of traversal in forward direction
        Returns an index object of the new location
       */
      function forward(cm, ln, pos, dir) {
        var line = cm.getLine(ln);
        var stop = (line === "");

        var curr = {
          line: line,
          ln: ln,
          pos: pos,
          dir: dir,
        }

        var last_valid = {
          ln: curr.ln,
          pos: curr.pos,
        }

        var skip_empty_lines = (curr.line === "");

        // Move one step to skip character we start on
        nextChar(cm, curr);

        while (curr.line !== null) {
          last_valid.ln = curr.ln;
          last_valid.pos = curr.pos;

          if (curr.line === "" && !skip_empty_lines) {
            return { ln: curr.ln, pos: curr.pos, };
          }
          else if (stop && curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
            return { ln: curr.ln, pos: curr.pos, };
          }
          else if (isEndOfSentenceSymbol(curr.line[curr.pos])
            && !stop
            && (curr.pos === curr.line.length - 1
              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {
            stop = true;
          }

          nextChar(cm, curr);
        }

        /*
          Set the position to the last non whitespace character on the last
          valid line in the case that we reach the end of the document.
        */
        var line = cm.getLine(last_valid.ln);
        last_valid.pos = 0;
        for(var i = line.length - 1; i >= 0; --i) {
          if (!isWhiteSpaceString(line[i])) {
            last_valid.pos = i;
            break;
          }
        }

        return last_valid;

      }

      /*
        Performs one iteration of traversal in reverse direction
        Returns an index object of the new location
       */
      function reverse(cm, ln, pos, dir) {
        var line = cm.getLine(ln);

        var curr = {
          line: line,
          ln: ln,
          pos: pos,
          dir: dir,
        }

        var last_valid = {
          ln: curr.ln,
          pos: null,
        };

        var skip_empty_lines = (curr.line === "");

        // Move one step to skip character we start on
        nextChar(cm, curr);

        while (curr.line !== null) {

          if (curr.line === "" && !skip_empty_lines) {
            if (last_valid.pos !== null) {
              return last_valid;
            }
            else {
              return { ln: curr.ln, pos: curr.pos };
            }
          }
          else if (isEndOfSentenceSymbol(curr.line[curr.pos])
              && last_valid.pos !== null
              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {
            return last_valid;
          }
          else if (curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
            skip_empty_lines = false;
            last_valid = { ln: curr.ln, pos: curr.pos }
          }

          nextChar(cm, curr);
        }

        /*
          Set the position to the first non whitespace character on the last
          valid line in the case that we reach the beginning of the document.
        */
        var line = cm.getLine(last_valid.ln);
        last_valid.pos = 0;
        for(var i = 0; i < line.length; ++i) {
          if (!isWhiteSpaceString(line[i])) {
            last_valid.pos = i;
            break;
          }
        }
        return last_valid;
      }

      var curr_index = {
        ln: cur.line,
        pos: cur.ch,
      };

      while (repeat > 0) {
        if (dir < 0) {
          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
        }
        else {
          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
        }
        repeat--;
      }

      return Pos(curr_index.ln, curr_index.pos);
    }

    // TODO: perhaps this finagling of start and end positions belongs
    // in codemirror/replaceRange?
    function selectCompanionObject(cm, head, symb, inclusive) {
      var cur = head, start, end;

      var bracketRegexp = ({
        '(': /[()]/, ')': /[()]/,
        '[': /[[\]]/, ']': /[[\]]/,
        '{': /[{}]/, '}': /[{}]/,
        '<': /[<>]/, '>': /[<>]/})[symb];
      var openSym = ({
        '(': '(', ')': '(',
        '[': '[', ']': '[',
        '{': '{', '}': '{',
        '<': '<', '>': '<'})[symb];
      var curChar = cm.getLine(cur.line).charAt(cur.ch);
      // Due to the behavior of scanForBracket, we need to add an offset if the
      // cursor is on a matching open bracket.
      var offset = curChar === openSym ? 1 : 0;

      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});
      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});

      if (!start || !end) {
        return { start: cur, end: cur };
      }

      start = start.pos;
      end = end.pos;

      if ((start.line == end.line && start.ch > end.ch)
          || (start.line > end.line)) {
        var tmp = start;
        start = end;
        end = tmp;
      }

      if (inclusive) {
        end.ch += 1;
      } else {
        start.ch += 1;
      }

      return { start: start, end: end };
    }

    // Takes in a symbol and a cursor and tries to simulate text objects that
    // have identical opening and closing symbols
    // TODO support across multiple lines
    function findBeginningAndEnd(cm, head, symb, inclusive) {
      var cur = copyCursor(head);
      var line = cm.getLine(cur.line);
      var chars = line.split('');
      var start, end, i, len;
      var firstIndex = chars.indexOf(symb);

      // the decision tree is to always look backwards for the beginning first,
      // but if the cursor is in front of the first instance of the symb,
      // then move the cursor forward
      if (cur.ch < firstIndex) {
        cur.ch = firstIndex;
        // Why is this line even here???
        // cm.setCursor(cur.line, firstIndex+1);
      }
      // otherwise if the cursor is currently on the closing symbol
      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {
        end = cur.ch; // assign end to the current cursor
        --cur.ch; // make sure to look backwards
      }

      // if we're currently on the symbol, we've got a start
      if (chars[cur.ch] == symb && !end) {
        start = cur.ch + 1; // assign start to ahead of the cursor
      } else {
        // go backwards to find the start
        for (i = cur.ch; i > -1 && !start; i--) {
          if (chars[i] == symb) {
            start = i + 1;
          }
        }
      }

      // look forwards for the end symbol
      if (start && !end) {
        for (i = start, len = chars.length; i < len && !end; i++) {
          if (chars[i] == symb) {
            end = i;
          }
        }
      }

      // nothing found
      if (!start || !end) {
        return { start: cur, end: cur };
      }

      // include the symbols
      if (inclusive) {
        --start; ++end;
      }

      return {
        start: Pos(cur.line, start),
        end: Pos(cur.line, end)
      };
    }

    // Search functions
    defineOption('pcre', true, 'boolean');
    function SearchState() {}
    SearchState.prototype = {
      getQuery: function() {
        return vimGlobalState.query;
      },
      setQuery: function(query) {
        vimGlobalState.query = query;
      },
      getOverlay: function() {
        return this.searchOverlay;
      },
      setOverlay: function(overlay) {
        this.searchOverlay = overlay;
      },
      isReversed: function() {
        return vimGlobalState.isReversed;
      },
      setReversed: function(reversed) {
        vimGlobalState.isReversed = reversed;
      },
      getScrollbarAnnotate: function() {
        return this.annotate;
      },
      setScrollbarAnnotate: function(annotate) {
        this.annotate = annotate;
      }
    };
    function getSearchState(cm) {
      var vim = cm.state.vim;
      return vim.searchState_ || (vim.searchState_ = new SearchState());
    }
    function splitBySlash(argString) {
      return splitBySeparator(argString, '/');
    }

    function findUnescapedSlashes(argString) {
      return findUnescapedSeparators(argString, '/');
    }

    function splitBySeparator(argString, separator) {
      var slashes = findUnescapedSeparators(argString, separator) || [];
      if (!slashes.length) return [];
      var tokens = [];
      // in case of strings like foo/bar
      if (slashes[0] !== 0) return;
      for (var i = 0; i < slashes.length; i++) {
        if (typeof slashes[i] == 'number')
          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));
      }
      return tokens;
    }

    function findUnescapedSeparators(str, separator) {
      if (!separator)
        separator = '/';

      var escapeNextChar = false;
      var slashes = [];
      for (var i = 0; i < str.length; i++) {
        var c = str.charAt(i);
        if (!escapeNextChar && c == separator) {
          slashes.push(i);
        }
        escapeNextChar = !escapeNextChar && (c == '\\');
      }
      return slashes;
    }

    // Translates a search string from ex (vim) syntax into javascript form.
    function translateRegex(str) {
      // When these match, add a '\' if unescaped or remove one if escaped.
      var specials = '|(){';
      // Remove, but never add, a '\' for these.
      var unescape = '}';
      var escapeNextChar = false;
      var out = [];
      for (var i = -1; i < str.length; i++) {
        var c = str.charAt(i) || '';
        var n = str.charAt(i+1) || '';
        var specialComesNext = (n && specials.indexOf(n) != -1);
        if (escapeNextChar) {
          if (c !== '\\' || !specialComesNext) {
            out.push(c);
          }
          escapeNextChar = false;
        } else {
          if (c === '\\') {
            escapeNextChar = true;
            // Treat the unescape list as special for removing, but not adding '\'.
            if (n && unescape.indexOf(n) != -1) {
              specialComesNext = true;
            }
            // Not passing this test means removing a '\'.
            if (!specialComesNext || n === '\\') {
              out.push(c);
            }
          } else {
            out.push(c);
            if (specialComesNext && n !== '\\') {
              out.push('\\');
            }
          }
        }
      }
      return out.join('');
    }

    // Translates the replace part of a search and replace from ex (vim) syntax into
    // javascript form.  Similar to translateRegex, but additionally fixes back references
    // (translates '\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.
    var charUnescapes = {'\\n': '\n', '\\r': '\r', '\\t': '\t'};
    function translateRegexReplace(str) {
      var escapeNextChar = false;
      var out = [];
      for (var i = -1; i < str.length; i++) {
        var c = str.charAt(i) || '';
        var n = str.charAt(i+1) || '';
        if (charUnescapes[c + n]) {
          out.push(charUnescapes[c+n]);
          i++;
        } else if (escapeNextChar) {
          // At any point in the loop, escapeNextChar is true if the previous
          // character was a '\' and was not escaped.
          out.push(c);
          escapeNextChar = false;
        } else {
          if (c === '\\') {
            escapeNextChar = true;
            if ((isNumber(n) || n === '$')) {
              out.push('$');
            } else if (n !== '/' && n !== '\\') {
              out.push('\\');
            }
          } else {
            if (c === '$') {
              out.push('$');
            }
            out.push(c);
            if (n === '/') {
              out.push('\\');
            }
          }
        }
      }
      return out.join('');
    }

    // Unescape \ and / in the replace part, for PCRE mode.
    var unescapes = {'\\/': '/', '\\\\': '\\', '\\n': '\n', '\\r': '\r', '\\t': '\t', '\\&':'&'};
    function unescapeRegexReplace(str) {
      var stream = new CodeMirror.StringStream(str);
      var output = [];
      while (!stream.eol()) {
        // Search for \.
        while (stream.peek() && stream.peek() != '\\') {
          output.push(stream.next());
        }
        var matched = false;
        for (var matcher in unescapes) {
          if (stream.match(matcher, true)) {
            matched = true;
            output.push(unescapes[matcher]);
            break;
          }
        }
        if (!matched) {
          // Don't change anything
          output.push(stream.next());
        }
      }
      return output.join('');
    }

    /**
     * Extract the regular expression from the query and return a Regexp object.
     * Returns null if the query is blank.
     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.
     * If smartCase is passed in, and the query contains upper case letters,
     *   then ignoreCase is overridden, and the 'i' flag will not be set.
     * If the query contains the /i in the flag part of the regular expression,
     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed
     *   through to the Regex object.
     */
    function parseQuery(query, ignoreCase, smartCase) {
      // First update the last search register
      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');
      lastSearchRegister.setText(query);
      // Check if the query is already a regex.
      if (query instanceof RegExp) { return query; }
      // First try to extract regex + flags from the input. If no flags found,
      // extract just the regex. IE does not accept flags directly defined in
      // the regex string in the form /regex/flags
      var slashes = findUnescapedSlashes(query);
      var regexPart;
      var forceIgnoreCase;
      if (!slashes.length) {
        // Query looks like 'regexp'
        regexPart = query;
      } else {
        // Query looks like 'regexp/...'
        regexPart = query.substring(0, slashes[0]);
        var flagsPart = query.substring(slashes[0]);
        forceIgnoreCase = (flagsPart.indexOf('i') != -1);
      }
      if (!regexPart) {
        return null;
      }
      if (!getOption('pcre')) {
        regexPart = translateRegex(regexPart);
      }
      if (smartCase) {
        ignoreCase = (/^[^A-Z]*$/).test(regexPart);
      }
      var regexp = new RegExp(regexPart,
          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);
      return regexp;
    }

    /**
     * dom - Document Object Manipulator
     * Usage:
     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])
     * Examples:
     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))
     *   dom(document.head, dom('script', 'alert("hello!")'))
     * Not supported:
     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))
     */
    function dom(n) {
      if (typeof n === 'string') n = document.createElement(n);
      for (var a, i = 1; i < arguments.length; i++) {
        if (!(a = arguments[i])) continue;
        if (typeof a !== 'object') a = document.createTextNode(a);
        if (a.nodeType) n.appendChild(a);
        else for (var key in a) {
          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;
          if (key[0] === '$') n.style[key.slice(1)] = a[key];
          else n.setAttribute(key, a[key]);
        }
      }
      return n;
    }

    function showConfirm(cm, template) {
      var pre = dom('pre', {$color: 'red'}, template);
      if (cm.openNotification) {
        cm.openNotification(pre, {bottom: true, duration: 5000});
      } else {
        alert(pre.innerText);
      }
    }

    function makePrompt(prefix, desc) {
      return dom(document.createDocumentFragment(),
               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre'},
                 prefix,
                 dom('input', {type: 'text', autocorrect: 'off',
                               autocapitalize: 'off', spellcheck: 'false'})),
               desc && dom('span', {$color: '#888'}, desc));
    }

    function showPrompt(cm, options) {
      var shortText = (options.prefix || '') + ' ' + (options.desc || '');
      var template = makePrompt(options.prefix, options.desc);
      if (cm.openDialog) {
        cm.openDialog(template, options.onClose, {
          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,
          bottom: true, selectValueOnOpen: false, value: options.value
        });
      }
      else {
        options.onClose(prompt(shortText, ''));
      }
    }

    function regexEqual(r1, r2) {
      if (r1 instanceof RegExp && r2 instanceof RegExp) {
          var props = ['global', 'multiline', 'ignoreCase', 'source'];
          for (var i = 0; i < props.length; i++) {
              var prop = props[i];
              if (r1[prop] !== r2[prop]) {
                  return false;
              }
          }
          return true;
      }
      return false;
    }
    // Returns true if the query is valid.
    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {
      if (!rawQuery) {
        return;
      }
      var state = getSearchState(cm);
      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);
      if (!query) {
        return;
      }
      highlightSearchMatches(cm, query);
      if (regexEqual(query, state.getQuery())) {
        return query;
      }
      state.setQuery(query);
      return query;
    }
    function searchOverlay(query) {
      if (query.source.charAt(0) == '^') {
        var matchSol = true;
      }
      return {
        token: function(stream) {
          if (matchSol && !stream.sol()) {
            stream.skipToEnd();
            return;
          }
          var match = stream.match(query, false);
          if (match) {
            if (match[0].length == 0) {
              // Matched empty string, skip to next.
              stream.next();
              return 'searching';
            }
            if (!stream.sol()) {
              // Backtrack 1 to match \b
              stream.backUp(1);
              if (!query.exec(stream.next() + match[0])) {
                stream.next();
                return null;
              }
            }
            stream.match(query);
            return 'searching';
          }
          while (!stream.eol()) {
            stream.next();
            if (stream.match(query, false)) break;
          }
        },
        query: query
      };
    }
    var highlightTimeout = 0;
    function highlightSearchMatches(cm, query) {
      clearTimeout(highlightTimeout);
      highlightTimeout = setTimeout(function() {
        var searchState = getSearchState(cm);
        var overlay = searchState.getOverlay();
        if (!overlay || query != overlay.query) {
          if (overlay) {
            cm.removeOverlay(overlay);
          }
          overlay = searchOverlay(query);
          cm.addOverlay(overlay);
          if (cm.showMatchesOnScrollbar) {
            if (searchState.getScrollbarAnnotate()) {
              searchState.getScrollbarAnnotate().clear();
            }
            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));
          }
          searchState.setOverlay(overlay);
        }
      }, 50);
    }
    function findNext(cm, prev, query, repeat) {
      if (repeat === undefined) { repeat = 1; }
      return cm.operation(function() {
        var pos = cm.getCursor();
        var cursor = cm.getSearchCursor(query, pos);
        for (var i = 0; i < repeat; i++) {
          var found = cursor.find(prev);
          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }
          if (!found) {
            // SearchCursor may have returned null because it hit EOF, wrap
            // around and try again.
            cursor = cm.getSearchCursor(query,
                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );
            if (!cursor.find(prev)) {
              return;
            }
          }
        }
        return cursor.from();
      });
    }
    /**
     * Pretty much the same as `findNext`, except for the following differences:
     *
     * 1. Before starting the search, move to the previous search. This way if our cursor is
     * already inside a match, we should return the current match.
     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.
     */
    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {
      if (repeat === undefined) { repeat = 1; }
      return cm.operation(function() {
        var pos = cm.getCursor();
        var cursor = cm.getSearchCursor(query, pos);

        // Go back one result to ensure that if the cursor is currently a match, we keep it.
        var found = cursor.find(!prev);

        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).
        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {
          cursor.find(!prev);
        }

        for (var i = 0; i < repeat; i++) {
          found = cursor.find(prev);
          if (!found) {
            // SearchCursor may have returned null because it hit EOF, wrap
            // around and try again.
            cursor = cm.getSearchCursor(query,
                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );
            if (!cursor.find(prev)) {
              return;
            }
          }
        }
        return [cursor.from(), cursor.to()];
      });
    }
    function clearSearchHighlight(cm) {
      var state = getSearchState(cm);
      cm.removeOverlay(getSearchState(cm).getOverlay());
      state.setOverlay(null);
      if (state.getScrollbarAnnotate()) {
        state.getScrollbarAnnotate().clear();
        state.setScrollbarAnnotate(null);
      }
    }
    /**
     * Check if pos is in the specified range, INCLUSIVE.
     * Range can be specified with 1 or 2 arguments.
     * If the first range argument is an array, treat it as an array of line
     * numbers. Match pos against any of the lines.
     * If the first range argument is a number,
     *   if there is only 1 range argument, check if pos has the same line
     *       number
     *   if there are 2 range arguments, then check if pos is in between the two
     *       range arguments.
     */
    function isInRange(pos, start, end) {
      if (typeof pos != 'number') {
        // Assume it is a cursor position. Get the line number.
        pos = pos.line;
      }
      if (start instanceof Array) {
        return inArray(pos, start);
      } else {
        if (typeof end == 'number') {
          return (pos >= start && pos <= end);
        } else {
          return pos == start;
        }
      }
    }
    function getUserVisibleLines(cm) {
      var scrollInfo = cm.getScrollInfo();
      var occludeToleranceTop = 6;
      var occludeToleranceBottom = 10;
      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');
      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;
      var to = cm.coordsChar({left:0, top: bottomY}, 'local');
      return {top: from.line, bottom: to.line};
    }

    function getMarkPos(cm, vim, markName) {
      if (markName == '\'' || markName == '`') {
        return vimGlobalState.jumpList.find(cm, -1) || Pos(0, 0);
      } else if (markName == '.') {
        return getLastEditPos(cm);
      }

      var mark = vim.marks[markName];
      return mark && mark.find();
    }

    function getLastEditPos(cm) {
      var done = cm.doc.history.done;
      for (var i = done.length; i--;) {
        if (done[i].changes) {
          return copyCursor(done[i].changes[0].to);
        }
      }
    }

    var ExCommandDispatcher = function() {
      this.buildCommandMap_();
    };
    ExCommandDispatcher.prototype = {
      processCommand: function(cm, input, opt_params) {
        var that = this;
        cm.operation(function () {
          cm.curOp.isVimOp = true;
          that._processCommand(cm, input, opt_params);
        });
      },
      _processCommand: function(cm, input, opt_params) {
        var vim = cm.state.vim;
        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');
        var previousCommand = commandHistoryRegister.toString();
        if (vim.visualMode) {
          exitVisualMode(cm);
        }
        var inputStream = new CodeMirror.StringStream(input);
        // update ": with the latest command whether valid or invalid
        commandHistoryRegister.setText(input);
        var params = opt_params || {};
        params.input = input;
        try {
          this.parseInput_(cm, inputStream, params);
        } catch(e) {
          showConfirm(cm, e.toString());
          throw e;
        }
        var command;
        var commandName;
        if (!params.commandName) {
          // If only a line range is defined, move to the line.
          if (params.line !== undefined) {
            commandName = 'move';
          }
        } else {
          command = this.matchCommand_(params.commandName);
          if (command) {
            commandName = command.name;
            if (command.excludeFromCommandHistory) {
              commandHistoryRegister.setText(previousCommand);
            }
            this.parseCommandArgs_(inputStream, params, command);
            if (command.type == 'exToKey') {
              // Handle Ex to Key mapping.
              for (var i = 0; i < command.toKeys.length; i++) {
                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');
              }
              return;
            } else if (command.type == 'exToEx') {
              // Handle Ex to Ex mapping.
              this.processCommand(cm, command.toInput);
              return;
            }
          }
        }
        if (!commandName) {
          showConfirm(cm, 'Not an editor command ":' + input + '"');
          return;
        }
        try {
          exCommands[commandName](cm, params);
          // Possibly asynchronous commands (e.g. substitute, which might have a
          // user confirmation), are responsible for calling the callback when
          // done. All others have it taken care of for them here.
          if ((!command || !command.possiblyAsync) && params.callback) {
            params.callback();
          }
        } catch(e) {
          showConfirm(cm, e.toString());
          throw e;
        }
      },
      parseInput_: function(cm, inputStream, result) {
        inputStream.eatWhile(':');
        // Parse range.
        if (inputStream.eat('%')) {
          result.line = cm.firstLine();
          result.lineEnd = cm.lastLine();
        } else {
          result.line = this.parseLineSpec_(cm, inputStream);
          if (result.line !== undefined && inputStream.eat(',')) {
            result.lineEnd = this.parseLineSpec_(cm, inputStream);
          }
        }

        // Parse command name.
        var commandMatch = inputStream.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
        if (commandMatch) {
          result.commandName = commandMatch[1];
        } else {
          result.commandName = inputStream.match(/.*/)[0];
        }

        return result;
      },
      parseLineSpec_: function(cm, inputStream) {
        var numberMatch = inputStream.match(/^(\d+)/);
        if (numberMatch) {
          // Absolute line number plus offset (N+M or N-M) is probably a typo,
          // not something the user actually wanted. (NB: vim does allow this.)
          return parseInt(numberMatch[1], 10) - 1;
        }
        switch (inputStream.next()) {
          case '.':
            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
          case '$':
            return this.parseLineSpecOffset_(inputStream, cm.lastLine());
          case '\'':
            var markName = inputStream.next();
            var markPos = getMarkPos(cm, cm.state.vim, markName);
            if (!markPos) throw new Error('Mark not set');
            return this.parseLineSpecOffset_(inputStream, markPos.line);
          case '-':
          case '+':
            inputStream.backUp(1);
            // Offset is relative to current line if not otherwise specified.
            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
          default:
            inputStream.backUp(1);
            return undefined;
        }
      },
      parseLineSpecOffset_: function(inputStream, line) {
        var offsetMatch = inputStream.match(/^([+-])?(\d+)/);
        if (offsetMatch) {
          var offset = parseInt(offsetMatch[2], 10);
          if (offsetMatch[1] == "-") {
            line -= offset;
          } else {
            line += offset;
          }
        }
        return line;
      },
      parseCommandArgs_: function(inputStream, params, command) {
        if (inputStream.eol()) {
          return;
        }
        params.argString = inputStream.match(/.*/)[0];
        // Parse command-line arguments
        var delim = command.argDelimiter || /\s+/;
        var args = trim(params.argString).split(delim);
        if (args.length && args[0]) {
          params.args = args;
        }
      },
      matchCommand_: function(commandName) {
        // Return the command in the command map that matches the shortest
        // prefix of the passed in command name. The match is guaranteed to be
        // unambiguous if the defaultExCommandMap's shortNames are set up
        // correctly. (see @code{defaultExCommandMap}).
        for (var i = commandName.length; i > 0; i--) {
          var prefix = commandName.substring(0, i);
          if (this.commandMap_[prefix]) {
            var command = this.commandMap_[prefix];
            if (command.name.indexOf(commandName) === 0) {
              return command;
            }
          }
        }
        return null;
      },
      buildCommandMap_: function() {
        this.commandMap_ = {};
        for (var i = 0; i < defaultExCommandMap.length; i++) {
          var command = defaultExCommandMap[i];
          var key = command.shortName || command.name;
          this.commandMap_[key] = command;
        }
      },
      map: function(lhs, rhs, ctx) {
        if (lhs != ':' && lhs.charAt(0) == ':') {
          if (ctx) { throw Error('Mode not supported for ex mappings'); }
          var commandName = lhs.substring(1);
          if (rhs != ':' && rhs.charAt(0) == ':') {
            // Ex to Ex mapping
            this.commandMap_[commandName] = {
              name: commandName,
              type: 'exToEx',
              toInput: rhs.substring(1),
              user: true
            };
          } else {
            // Ex to key mapping
            this.commandMap_[commandName] = {
              name: commandName,
              type: 'exToKey',
              toKeys: rhs,
              user: true
            };
          }
        } else {
          if (rhs != ':' && rhs.charAt(0) == ':') {
            // Key to Ex mapping.
            var mapping = {
              keys: lhs,
              type: 'keyToEx',
              exArgs: { input: rhs.substring(1) }
            };
            if (ctx) { mapping.context = ctx; }
            defaultKeymap.unshift(mapping);
          } else {
            // Key to key mapping
            var mapping = {
              keys: lhs,
              type: 'keyToKey',
              toKeys: rhs
            };
            if (ctx) { mapping.context = ctx; }
            defaultKeymap.unshift(mapping);
          }
        }
      },
      unmap: function(lhs, ctx) {
        if (lhs != ':' && lhs.charAt(0) == ':') {
          // Ex to Ex or Ex to key mapping
          if (ctx) { throw Error('Mode not supported for ex mappings'); }
          var commandName = lhs.substring(1);
          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {
            delete this.commandMap_[commandName];
            return;
          }
        } else {
          // Key to Ex or key to key mapping
          var keys = lhs;
          for (var i = 0; i < defaultKeymap.length; i++) {
            if (keys == defaultKeymap[i].keys
                && defaultKeymap[i].context === ctx) {
              defaultKeymap.splice(i, 1);
              return;
            }
          }
        }
        throw Error('No such mapping.');
      }
    };

    var exCommands = {
      colorscheme: function(cm, params) {
        if (!params.args || params.args.length < 1) {
          showConfirm(cm, cm.getOption('theme'));
          return;
        }
        cm.setOption('theme', params.args[0]);
      },
      map: function(cm, params, ctx) {
        var mapArgs = params.args;
        if (!mapArgs || mapArgs.length < 2) {
          if (cm) {
            showConfirm(cm, 'Invalid mapping: ' + params.input);
          }
          return;
        }
        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);
      },
      imap: function(cm, params) { this.map(cm, params, 'insert'); },
      nmap: function(cm, params) { this.map(cm, params, 'normal'); },
      vmap: function(cm, params) { this.map(cm, params, 'visual'); },
      unmap: function(cm, params, ctx) {
        var mapArgs = params.args;
        if (!mapArgs || mapArgs.length < 1) {
          if (cm) {
            showConfirm(cm, 'No such mapping: ' + params.input);
          }
          return;
        }
        exCommandDispatcher.unmap(mapArgs[0], ctx);
      },
      move: function(cm, params) {
        commandDispatcher.processCommand(cm, cm.state.vim, {
            type: 'motion',
            motion: 'moveToLineOrEdgeOfDocument',
            motionArgs: { forward: false, explicitRepeat: true,
              linewise: true },
            repeatOverride: params.line+1});
      },
      set: function(cm, params) {
        var setArgs = params.args;
        // Options passed through to the setOption/getOption calls. May be passed in by the
        // local/global versions of the set command
        var setCfg = params.setCfg || {};
        if (!setArgs || setArgs.length < 1) {
          if (cm) {
            showConfirm(cm, 'Invalid mapping: ' + params.input);
          }
          return;
        }
        var expr = setArgs[0].split('=');
        var optionName = expr[0];
        var value = expr[1];
        var forceGet = false;

        if (optionName.charAt(optionName.length - 1) == '?') {
          // If post-fixed with ?, then the set is actually a get.
          if (value) { throw Error('Trailing characters: ' + params.argString); }
          optionName = optionName.substring(0, optionName.length - 1);
          forceGet = true;
        }
        if (value === undefined && optionName.substring(0, 2) == 'no') {
          // To set boolean options to false, the option name is prefixed with
          // 'no'.
          optionName = optionName.substring(2);
          value = false;
        }

        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';
        if (optionIsBoolean && value == undefined) {
          // Calling set with a boolean option sets it to true.
          value = true;
        }
        // If no value is provided, then we assume this is a get.
        if (!optionIsBoolean && value === undefined || forceGet) {
          var oldValue = getOption(optionName, cm, setCfg);
          if (oldValue instanceof Error) {
            showConfirm(cm, oldValue.message);
          } else if (oldValue === true || oldValue === false) {
            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);
          } else {
            showConfirm(cm, '  ' + optionName + '=' + oldValue);
          }
        } else {
          var setOptionReturn = setOption(optionName, value, cm, setCfg);
          if (setOptionReturn instanceof Error) {
            showConfirm(cm, setOptionReturn.message);
          }
        }
      },
      setlocal: function (cm, params) {
        // setCfg is passed through to setOption
        params.setCfg = {scope: 'local'};
        this.set(cm, params);
      },
      setglobal: function (cm, params) {
        // setCfg is passed through to setOption
        params.setCfg = {scope: 'global'};
        this.set(cm, params);
      },
      registers: function(cm, params) {
        var regArgs = params.args;
        var registers = vimGlobalState.registerController.registers;
        var regInfo = '----------Registers----------\n\n';
        if (!regArgs) {
          for (var registerName in registers) {
            var text = registers[registerName].toString();
            if (text.length) {
              regInfo += '"' + registerName + '    ' + text + '\n'
            }
          }
        } else {
          var registerName;
          regArgs = regArgs.join('');
          for (var i = 0; i < regArgs.length; i++) {
            registerName = regArgs.charAt(i);
            if (!vimGlobalState.registerController.isValidRegister(registerName)) {
              continue;
            }
            var register = registers[registerName] || new Register();
            regInfo += '"' + registerName + '    ' + register.toString() + '\n'
          }
        }
        showConfirm(cm, regInfo);
      },
      sort: function(cm, params) {
        var reverse, ignoreCase, unique, number, pattern;
        function parseArgs() {
          if (params.argString) {
            var args = new CodeMirror.StringStream(params.argString);
            if (args.eat('!')) { reverse = true; }
            if (args.eol()) { return; }
            if (!args.eatSpace()) { return 'Invalid arguments'; }
            var opts = args.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
            if (!opts && !args.eol()) { return 'Invalid arguments'; }
            if (opts[1]) {
              ignoreCase = opts[1].indexOf('i') != -1;
              unique = opts[1].indexOf('u') != -1;
              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;
              var hex = opts[1].indexOf('x') != -1 && 1;
              var octal = opts[1].indexOf('o') != -1 && 1;
              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }
              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';
            }
            if (opts[2]) {
              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');
            }
          }
        }
        var err = parseArgs();
        if (err) {
          showConfirm(cm, err + ': ' + params.argString);
          return;
        }
        var lineStart = params.line || cm.firstLine();
        var lineEnd = params.lineEnd || params.line || cm.lastLine();
        if (lineStart == lineEnd) { return; }
        var curStart = Pos(lineStart, 0);
        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));
        var text = cm.getRange(curStart, curEnd).split('\n');
        var numberRegex = pattern ? pattern :
           (number == 'decimal') ? /(-?)([\d]+)/ :
           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :
           (number == 'octal') ? /([0-7]+)/ : null;
        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;
        var numPart = [], textPart = [];
        if (number || pattern) {
          for (var i = 0; i < text.length; i++) {
            var matchPart = pattern ? text[i].match(pattern) : null;
            if (matchPart && matchPart[0] != '') {
              numPart.push(matchPart);
            } else if (!pattern && numberRegex.exec(text[i])) {
              numPart.push(text[i]);
            } else {
              textPart.push(text[i]);
            }
          }
        } else {
          textPart = text;
        }
        function compareFn(a, b) {
          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }
          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }
          var anum = number && numberRegex.exec(a);
          var bnum = number && numberRegex.exec(b);
          if (!anum) { return a < b ? -1 : 1; }
          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);
          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);
          return anum - bnum;
        }
        function comparePatternFn(a, b) {
          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }
          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }
          return (a[0] < b[0]) ? -1 : 1;
        }
        numPart.sort(pattern ? comparePatternFn : compareFn);
        if (pattern) {
          for (var i = 0; i < numPart.length; i++) {
            numPart[i] = numPart[i].input;
          }
        } else if (!number) { textPart.sort(compareFn); }
        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);
        if (unique) { // Remove duplicate lines
          var textOld = text;
          var lastLine;
          text = [];
          for (var i = 0; i < textOld.length; i++) {
            if (textOld[i] != lastLine) {
              text.push(textOld[i]);
            }
            lastLine = textOld[i];
          }
        }
        cm.replaceRange(text.join('\n'), curStart, curEnd);
      },
      vglobal: function(cm, params) {
        // global inspects params.commandName
        this.global(cm, params);
      },
      global: function(cm, params) {
        // a global command is of the form
        // :[range]g/pattern/[cmd]
        // argString holds the string /pattern/[cmd]
        var argString = params.argString;
        if (!argString) {
          showConfirm(cm, 'Regular Expression missing from global');
          return;
        }
        var inverted = params.commandName[0] === 'v';
        // range is specified here
        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();
        var lineEnd = params.lineEnd || params.line || cm.lastLine();
        // get the tokens from argString
        var tokens = splitBySlash(argString);
        var regexPart = argString, cmd;
        if (tokens.length) {
          regexPart = tokens[0];
          cmd = tokens.slice(1, tokens.length).join('/');
        }
        if (regexPart) {
          // If regex part is empty, then use the previous query. Otherwise
          // use the regex part as the new query.
          try {
           updateSearchQuery(cm, regexPart, true /** ignoreCase */,
             true /** smartCase */);
          } catch (e) {
           showConfirm(cm, 'Invalid regex: ' + regexPart);
           return;
          }
        }
        // now that we have the regexPart, search for regex matches in the
        // specified range of lines
        var query = getSearchState(cm).getQuery();
        var matchedLines = [];
        for (var i = lineStart; i <= lineEnd; i++) {
          var line = cm.getLineHandle(i);
          var matched = query.test(line.text);
          if (matched !== inverted) {
            matchedLines.push(cmd ? line : line.text);
          }
        }
        // if there is no [cmd], just display the list of matched lines
        if (!cmd) {
          showConfirm(cm, matchedLines.join('\n'));
          return;
        }
        var index = 0;
        var nextCommand = function() {
          if (index < matchedLines.length) {
            var line = matchedLines[index++];
            var lineNum = cm.getLineNumber(line);
            if (lineNum == null) {
              nextCommand();
              return;
            }
            var command = (lineNum + 1) + cmd;
            exCommandDispatcher.processCommand(cm, command, {
              callback: nextCommand
            });
          }
        };
        nextCommand();
      },
      substitute: function(cm, params) {
        if (!cm.getSearchCursor) {
          throw new Error('Search feature not available. Requires searchcursor.js or ' +
              'any other getSearchCursor implementation.');
        }
        var argString = params.argString;
        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];
        var regexPart, replacePart = '', trailing, flagsPart, count;
        var confirm = false; // Whether to confirm each replace.
        var global = false; // True to replace all instances on a line, false to replace only 1.
        if (tokens.length) {
          regexPart = tokens[0];
          if (getOption('pcre') && regexPart !== '') {
              regexPart = new RegExp(regexPart).source; //normalize not escaped characters
          }
          replacePart = tokens[1];
          // If the pattern ends with $ (line boundary assertion), change $ to \n.
          // Caveat: this workaround cannot match on the last line of the document.
          if (/(^|[^\\])(\\\\)*\$$/.test(regexPart)) {
            regexPart = regexPart.slice(0, -1) + '\\n';
            replacePart = (replacePart || '') + '\n';
          }
          if (replacePart !== undefined) {
            if (getOption('pcre')) {
              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\])&/g,"$1$$&"));
            } else {
              replacePart = translateRegexReplace(replacePart);
            }
            vimGlobalState.lastSubstituteReplacePart = replacePart;
          }
          trailing = tokens[2] ? tokens[2].split(' ') : [];
        } else {
          // either the argString is empty or its of the form ' hello/world'
          // actually splitBySlash returns a list of tokens
          // only if the string starts with a '/'
          if (argString && argString.length) {
            showConfirm(cm, 'Substitutions should be of the form ' +
                ':s/pattern/replace/');
            return;
          }
        }
        // After the 3rd slash, we can have flags followed by a space followed
        // by count.
        if (trailing) {
          flagsPart = trailing[0];
          count = parseInt(trailing[1]);
          if (flagsPart) {
            if (flagsPart.indexOf('c') != -1) {
              confirm = true;
            }
            if (flagsPart.indexOf('g') != -1) {
              global = true;
            }
            if (getOption('pcre')) {
               regexPart = regexPart + '/' + flagsPart;
            } else {
               regexPart = regexPart.replace(/\//g, "\\/") + '/' + flagsPart;
            }
          }
        }
        if (regexPart) {
          // If regex part is empty, then use the previous query. Otherwise use
          // the regex part as the new query.
          try {
            updateSearchQuery(cm, regexPart, true /** ignoreCase */,
              true /** smartCase */);
          } catch (e) {
            showConfirm(cm, 'Invalid regex: ' + regexPart);
            return;
          }
        }
        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;
        if (replacePart === undefined) {
          showConfirm(cm, 'No previous substitute regular expression');
          return;
        }
        var state = getSearchState(cm);
        var query = state.getQuery();
        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;
        var lineEnd = params.lineEnd || lineStart;
        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {
          lineEnd = Infinity;
        }
        if (count) {
          lineStart = lineEnd;
          lineEnd = lineStart + count - 1;
        }
        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));
        var cursor = cm.getSearchCursor(query, startPos);
        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);
      },
      redo: CodeMirror.commands.redo,
      undo: CodeMirror.commands.undo,
      write: function(cm) {
        if (CodeMirror.commands.save) {
          // If a save command is defined, call it.
          CodeMirror.commands.save(cm);
        } else if (cm.save) {
          // Saves to text area if no save command is defined and cm.save() is available.
          cm.save();
        }
      },
      nohlsearch: function(cm) {
        clearSearchHighlight(cm);
      },
      yank: function (cm) {
        var cur = copyCursor(cm.getCursor());
        var line = cur.line;
        var lineText = cm.getLine(line);
        vimGlobalState.registerController.pushText(
          '0', 'yank', lineText, true, true);
      },
      delmarks: function(cm, params) {
        if (!params.argString || !trim(params.argString)) {
          showConfirm(cm, 'Argument required');
          return;
        }

        var state = cm.state.vim;
        var stream = new CodeMirror.StringStream(trim(params.argString));
        while (!stream.eol()) {
          stream.eatSpace();

          // Record the streams position at the beginning of the loop for use
          // in error messages.
          var count = stream.pos;

          if (!stream.match(/[a-zA-Z]/, false)) {
            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
            return;
          }

          var sym = stream.next();
          // Check if this symbol is part of a range
          if (stream.match('-', true)) {
            // This symbol is part of a range.

            // The range must terminate at an alphabetic character.
            if (!stream.match(/[a-zA-Z]/, false)) {
              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
              return;
            }

            var startMark = sym;
            var finishMark = stream.next();
            // The range must terminate at an alphabetic character which
            // shares the same case as the start of the range.
            if (isLowerCase(startMark) && isLowerCase(finishMark) ||
                isUpperCase(startMark) && isUpperCase(finishMark)) {
              var start = startMark.charCodeAt(0);
              var finish = finishMark.charCodeAt(0);
              if (start >= finish) {
                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));
                return;
              }

              // Because marks are always ASCII values, and we have
              // determined that they are the same case, we can use
              // their char codes to iterate through the defined range.
              for (var j = 0; j <= finish - start; j++) {
                var mark = String.fromCharCode(start + j);
                delete state.marks[mark];
              }
            } else {
              showConfirm(cm, 'Invalid argument: ' + startMark + '-');
              return;
            }
          } else {
            // This symbol is a valid mark, and is not part of a range.
            delete state.marks[sym];
          }
        }
      }
    };

    var exCommandDispatcher = new ExCommandDispatcher();

    /**
    * @param {CodeMirror} cm CodeMirror instance we are in.
    * @param {boolean} confirm Whether to confirm each replace.
    * @param {Cursor} lineStart Line to start replacing from.
    * @param {Cursor} lineEnd Line to stop replacing at.
    * @param {RegExp} query Query for performing matches with.
    * @param {string} replaceWith Text to replace matches with. May contain $1,
    *     $2, etc for replacing captured groups using JavaScript replace.
    * @param {function()} callback A callback for when the replace is done.
    */
    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,
        replaceWith, callback) {
      // Set up all the functions.
      cm.state.vim.exMode = true;
      var done = false;
      var lastPos, modifiedLineNumber, joined;
      function replaceAll() {
        cm.operation(function() {
          while (!done) {
            replace();
            next();
          }
          stop();
        });
      }
      function replace() {
        var text = cm.getRange(searchCursor.from(), searchCursor.to());
        var newText = text.replace(query, replaceWith);
        var unmodifiedLineNumber = searchCursor.to().line;
        searchCursor.replace(newText);
        modifiedLineNumber = searchCursor.to().line;
        lineEnd += modifiedLineNumber - unmodifiedLineNumber;
        joined = modifiedLineNumber < unmodifiedLineNumber;
      }
      function next() {
        // The below only loops to skip over multiple occurrences on the same
        // line when 'global' is not true.
        while(searchCursor.findNext() &&
              isInRange(searchCursor.from(), lineStart, lineEnd)) {
          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {
            continue;
          }
          cm.scrollIntoView(searchCursor.from(), 30);
          cm.setSelection(searchCursor.from(), searchCursor.to());
          lastPos = searchCursor.from();
          done = false;
          return;
        }
        done = true;
      }
      function stop(close) {
        if (close) { close(); }
        cm.focus();
        if (lastPos) {
          cm.setCursor(lastPos);
          var vim = cm.state.vim;
          vim.exMode = false;
          vim.lastHPos = vim.lastHSPos = lastPos.ch;
        }
        if (callback) { callback(); }
      }
      function onPromptKeyDown(e, _value, close) {
        // Swallow all keys.
        CodeMirror.e_stop(e);
        var keyName = CodeMirror.keyName(e);
        switch (keyName) {
          case 'Y':
            replace(); next(); break;
          case 'N':
            next(); break;
          case 'A':
            // replaceAll contains a call to close of its own. We don't want it
            // to fire too early or multiple times.
            var savedCallback = callback;
            callback = undefined;
            cm.operation(replaceAll);
            callback = savedCallback;
            break;
          case 'L':
            replace();
            // fall through and exit.
          case 'Q':
          case 'Esc':
          case 'Ctrl-C':
          case 'Ctrl-[':
            stop(close);
            break;
        }
        if (done) { stop(close); }
        return true;
      }

      // Actually do replace.
      next();
      if (done) {
        showConfirm(cm, 'No matches for ' + query.source);
        return;
      }
      if (!confirm) {
        replaceAll();
        if (callback) { callback(); }
        return;
      }
      showPrompt(cm, {
        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),
        onKeyDown: onPromptKeyDown
      });
    }

    CodeMirror.keyMap.vim = {
      attach: attachVimMap,
      detach: detachVimMap,
      call: cmKey
    };

    function exitInsertMode(cm) {
      var vim = cm.state.vim;
      var macroModeState = vimGlobalState.macroModeState;
      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');
      var isPlaying = macroModeState.isPlaying;
      var lastChange = macroModeState.lastInsertModeChanges;
      if (!isPlaying) {
        cm.off('change', onChange);
        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);
      }
      if (!isPlaying && vim.insertModeRepeat > 1) {
        // Perform insert mode repeat for commands like 3,a and 3,o.
        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,
            true /** repeatForInsert */);
        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;
      }
      delete vim.insertModeRepeat;
      vim.insertMode = false;
      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);
      cm.setOption('keyMap', 'vim');
      cm.setOption('disableInput', true);
      cm.toggleOverwrite(false); // exit replace mode if we were in it.
      // update the ". register before exiting insert mode
      insertModeChangeRegister.setText(lastChange.changes.join(''));
      CodeMirror.signal(cm, "vim-mode-change", {mode: "normal"});
      if (macroModeState.isRecording) {
        logInsertModeChange(macroModeState);
      }
    }

    function _mapCommand(command) {
      defaultKeymap.unshift(command);
    }

    function mapCommand(keys, type, name, args, extra) {
      var command = {keys: keys, type: type};
      command[type] = name;
      command[type + "Args"] = args;
      for (var key in extra)
        command[key] = extra[key];
      _mapCommand(command);
    }

    // The timeout in milliseconds for the two-character ESC keymap should be
    // adjusted according to your typing speed to prevent false positives.
    defineOption('insertModeEscKeysTimeout', 200, 'number');

    CodeMirror.keyMap['vim-insert'] = {
      // TODO: override navigation keys so that Esc will cancel automatic
      // indentation from o, O, i_<CR>
      fallthrough: ['default'],
      attach: attachVimMap,
      detach: detachVimMap,
      call: cmKey
    };

    CodeMirror.keyMap['vim-replace'] = {
      'Backspace': 'goCharLeft',
      fallthrough: ['vim-insert'],
      attach: attachVimMap,
      detach: detachVimMap,
      call: cmKey
    };

    function executeMacroRegister(cm, vim, macroModeState, registerName) {
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (registerName == ':') {
        // Read-only register containing last Ex command.
        if (register.keyBuffer[0]) {
          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);
        }
        macroModeState.isPlaying = false;
        return;
      }
      var keyBuffer = register.keyBuffer;
      var imc = 0;
      macroModeState.isPlaying = true;
      macroModeState.replaySearchQueries = register.searchQueries.slice(0);
      for (var i = 0; i < keyBuffer.length; i++) {
        var text = keyBuffer[i];
        var match, key;
        while (text) {
          // Pull off one command key, which is either a single character
          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.
          match = (/<\w+-.+?>|<\w+>|./).exec(text);
          key = match[0];
          text = text.substring(match.index + key.length);
          CodeMirror.Vim.handleKey(cm, key, 'macro');
          if (vim.insertMode) {
            var changes = register.insertModeChanges[imc++].changes;
            vimGlobalState.macroModeState.lastInsertModeChanges.changes =
                changes;
            repeatInsertModeChanges(cm, changes, 1);
            exitInsertMode(cm);
          }
        }
      }
      macroModeState.isPlaying = false;
    }

    function logKey(macroModeState, key) {
      if (macroModeState.isPlaying) { return; }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register) {
        register.pushText(key);
      }
    }

    function logInsertModeChange(macroModeState) {
      if (macroModeState.isPlaying) { return; }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register && register.pushInsertModeChanges) {
        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);
      }
    }

    function logSearchQuery(macroModeState, query) {
      if (macroModeState.isPlaying) { return; }
      var registerName = macroModeState.latestRegister;
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register && register.pushSearchQuery) {
        register.pushSearchQuery(query);
      }
    }

    /**
     * Listens for changes made in insert mode.
     * Should only be active in insert mode.
     */
    function onChange(cm, changeObj) {
      var macroModeState = vimGlobalState.macroModeState;
      var lastChange = macroModeState.lastInsertModeChanges;
      if (!macroModeState.isPlaying) {
        while(changeObj) {
          lastChange.expectCursorActivityForChange = true;
          if (lastChange.ignoreCount > 1) {
            lastChange.ignoreCount--;
          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'
              || changeObj.origin === undefined /* only in testing */) {
            var selectionCount = cm.listSelections().length;
            if (selectionCount > 1)
              lastChange.ignoreCount = selectionCount;
            var text = changeObj.text.join('\n');
            if (lastChange.maybeReset) {
              lastChange.changes = [];
              lastChange.maybeReset = false;
            }
            if (text) {
              if (cm.state.overwrite && !/\n/.test(text)) {
                lastChange.changes.push([text]);
              } else {
                lastChange.changes.push(text);
              }
            }
          }
          // Change objects may be chained with next.
          changeObj = changeObj.next;
        }
      }
    }

    /**
    * Listens for any kind of cursor activity on CodeMirror.
    */
    function onCursorActivity(cm) {
      var vim = cm.state.vim;
      if (vim.insertMode) {
        // Tracking cursor activity in insert mode (for macro support).
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isPlaying) { return; }
        var lastChange = macroModeState.lastInsertModeChanges;
        if (lastChange.expectCursorActivityForChange) {
          lastChange.expectCursorActivityForChange = false;
        } else {
          // Cursor moved outside the context of an edit. Reset the change.
          lastChange.maybeReset = true;
        }
      } else if (!cm.curOp.isVimOp) {
        handleExternalSelection(cm, vim);
      }
      if (vim.visualMode) {
        updateFakeCursor(cm);
      }
    }
    /**
     * Keeps track of a fake cursor to support visual mode cursor behavior.
     */
    function updateFakeCursor(cm) {
      var className = 'cm-animate-fat-cursor';
      var vim = cm.state.vim;
      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));
      var to = offsetCursor(from, 0, 1);
      clearFakeCursor(vim);
      // In visual mode, the cursor may be positioned over EOL.
      if (from.ch == cm.getLine(from.line).length) {
        var widget = dom('span', { 'class': className }, '\u00a0');
        vim.fakeCursorBookmark = cm.setBookmark(from, {widget: widget});
      } else {
        vim.fakeCursor = cm.markText(from, to, {className: className});
      }
    }
    function clearFakeCursor(vim) {
      if (vim.fakeCursor) {
        vim.fakeCursor.clear();
        vim.fakeCursor = null;
      }
      if (vim.fakeCursorBookmark) {
        vim.fakeCursorBookmark.clear();
        vim.fakeCursorBookmark = null;
      }
    }
    function handleExternalSelection(cm, vim) {
      var anchor = cm.getCursor('anchor');
      var head = cm.getCursor('head');
      // Enter or exit visual mode to match mouse selection.
      if (vim.visualMode && !cm.somethingSelected()) {
        exitVisualMode(cm, false);
      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {
        vim.visualMode = true;
        vim.visualLine = false;
        CodeMirror.signal(cm, "vim-mode-change", {mode: "visual"});
      }
      if (vim.visualMode) {
        // Bind CodeMirror selection model to vim selection model.
        // Mouse selections are considered visual characterwise.
        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
        head = offsetCursor(head, 0, headOffset);
        anchor = offsetCursor(anchor, 0, anchorOffset);
        vim.sel = {
          anchor: anchor,
          head: head
        };
        updateMark(cm, vim, '<', cursorMin(head, anchor));
        updateMark(cm, vim, '>', cursorMax(head, anchor));
      } else if (!vim.insertMode) {
        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.
        vim.lastHPos = cm.getCursor().ch;
      }
    }

    /** Wrapper for special keys pressed in insert mode */
    function InsertModeKey(keyName) {
      this.keyName = keyName;
    }

    /**
    * Handles raw key down events from the text area.
    * - Should only be active in insert mode.
    * - For recording deletes in insert mode.
    */
    function onKeyEventTargetKeyDown(e) {
      var macroModeState = vimGlobalState.macroModeState;
      var lastChange = macroModeState.lastInsertModeChanges;
      var keyName = CodeMirror.keyName(e);
      if (!keyName) { return; }
      function onKeyFound() {
        if (lastChange.maybeReset) {
          lastChange.changes = [];
          lastChange.maybeReset = false;
        }
        lastChange.changes.push(new InsertModeKey(keyName));
        return true;
      }
      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {
        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);
      }
    }

    /**
     * Repeats the last edit, which includes exactly 1 command and at most 1
     * insert. Operator and motion commands are read from lastEditInputState,
     * while action commands are read from lastEditActionCommand.
     *
     * If repeatForInsert is true, then the function was called by
     * exitInsertMode to repeat the insert mode changes the user just made. The
     * corresponding enterInsertMode call was made with a count.
     */
    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {
      var macroModeState = vimGlobalState.macroModeState;
      macroModeState.isPlaying = true;
      var isAction = !!vim.lastEditActionCommand;
      var cachedInputState = vim.inputState;
      function repeatCommand() {
        if (isAction) {
          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);
        } else {
          commandDispatcher.evalInput(cm, vim);
        }
      }
      function repeatInsert(repeat) {
        if (macroModeState.lastInsertModeChanges.changes.length > 0) {
          // For some reason, repeat cw in desktop VIM does not repeat
          // insert mode changes. Will conform to that behavior.
          repeat = !vim.lastEditActionCommand ? 1 : repeat;
          var changeObject = macroModeState.lastInsertModeChanges;
          repeatInsertModeChanges(cm, changeObject.changes, repeat);
        }
      }
      vim.inputState = vim.lastEditInputState;
      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {
        // o and O repeat have to be interlaced with insert repeats so that the
        // insertions appear on separate lines instead of the last line.
        for (var i = 0; i < repeat; i++) {
          repeatCommand();
          repeatInsert(1);
        }
      } else {
        if (!repeatForInsert) {
          // Hack to get the cursor to end up at the right place. If I is
          // repeated in insert mode repeat, cursor will be 1 insert
          // change set left of where it should be.
          repeatCommand();
        }
        repeatInsert(repeat);
      }
      vim.inputState = cachedInputState;
      if (vim.insertMode && !repeatForInsert) {
        // Don't exit insert mode twice. If repeatForInsert is set, then we
        // were called by an exitInsertMode call lower on the stack.
        exitInsertMode(cm);
      }
      macroModeState.isPlaying = false;
    }

    function repeatInsertModeChanges(cm, changes, repeat) {
      function keyHandler(binding) {
        if (typeof binding == 'string') {
          CodeMirror.commands[binding](cm);
        } else {
          binding(cm);
        }
        return true;
      }
      var head = cm.getCursor('head');
      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;
      if (visualBlock) {
        // Set up block selection again for repeating the changes.
        selectForInsert(cm, head, visualBlock + 1);
        repeat = cm.listSelections().length;
        cm.setCursor(head);
      }
      for (var i = 0; i < repeat; i++) {
        if (visualBlock) {
          cm.setCursor(offsetCursor(head, i, 0));
        }
        for (var j = 0; j < changes.length; j++) {
          var change = changes[j];
          if (change instanceof InsertModeKey) {
            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);
          } else if (typeof change == "string") {
            var cur = cm.getCursor();
            cm.replaceRange(change, cur, cur);
          } else {
            var start = cm.getCursor();
            var end = offsetCursor(start, 0, change[0].length);
            cm.replaceRange(change[0], start, end);
          }
        }
      }
      if (visualBlock) {
        cm.setCursor(offsetCursor(head, 0, 1));
      }
    }

    resetVimGlobalState();
    return vimApi;
  };
  // Initialize Vim and make it available as an API.
  CodeMirror.Vim = Vim();
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9rZXltYXAvdmltLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsR0FBRztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMsc0VBQW1CLEdBQUcsbUJBQU8sQ0FBQyw0RkFBOEIsR0FBRyxtQkFBTyxDQUFDLGdGQUF3QixHQUFHLG1CQUFPLENBQUMsNkZBQWdDO0FBQzFKLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnREFBZ0Q7QUFDckQsS0FBSyxpREFBaUQ7QUFDdEQsS0FBSyw4Q0FBOEM7QUFDbkQsS0FBSyxnREFBZ0Q7QUFDckQsS0FBSyxpREFBaUQ7QUFDdEQsS0FBSyxnRUFBZ0U7QUFDckUsS0FBSyxpRUFBaUU7QUFDdEUsS0FBSyxtREFBbUQ7QUFDeEQsS0FBSyxtRUFBbUU7QUFDeEUsS0FBSyxtREFBbUQ7QUFDeEQsS0FBSyxtRUFBbUU7QUFDeEUsS0FBSywrQ0FBK0M7QUFDcEQsS0FBSywrQ0FBK0M7QUFDcEQsS0FBSyxtREFBbUQ7QUFDeEQsS0FBSyxtREFBbUQ7QUFDeEQsS0FBSyxzRUFBc0U7QUFDM0UsS0FBSyxzRUFBc0U7QUFDM0UsS0FBSywrREFBK0Q7QUFDcEUsS0FBSyw2REFBNkQ7QUFDbEUsS0FBSywrREFBK0Q7QUFDcEUsS0FBSyxnRUFBZ0U7QUFDckUsS0FBSyxnREFBZ0Q7QUFDckQsS0FBSywrQ0FBK0M7QUFDcEQsS0FBSyxzREFBc0Q7QUFDM0QsS0FBSyx3REFBd0Q7QUFDN0QsS0FBSyxrRUFBa0U7QUFDdkUsS0FBSyw4RUFBOEU7QUFDbkY7QUFDQSxLQUFLLGtFQUFrRSxvQ0FBb0M7QUFDM0csS0FBSyxxRUFBcUUsb0NBQW9DO0FBQzlHLEtBQUsscUVBQXFFLG9DQUFvQztBQUM5RyxLQUFLLHFFQUFxRSxrQkFBa0I7QUFDNUYsS0FBSyxxRUFBcUUsaUJBQWlCO0FBQzNGLEtBQUssZ0VBQWdFLGlDQUFpQztBQUN0RyxLQUFLLGdFQUFnRSxrQ0FBa0M7QUFDdkcsS0FBSyx3RUFBd0UsaUJBQWlCO0FBQzlGLEtBQUssd0VBQXdFLGtCQUFrQjtBQUMvRixLQUFLLGdFQUFnRSxpQ0FBaUM7QUFDdEcsS0FBSyxnRUFBZ0UsZ0RBQWdEO0FBQ3JILEtBQUssZ0VBQWdFLGlEQUFpRDtBQUN0SCxLQUFLLGdFQUFnRSxnRUFBZ0U7QUFDckksS0FBSyxnRUFBZ0Usa0NBQWtDO0FBQ3ZHLEtBQUssZ0VBQWdFLGlEQUFpRDtBQUN0SCxLQUFLLGlFQUFpRSxrREFBa0Q7QUFDeEgsS0FBSyxpRUFBaUUsaUVBQWlFO0FBQ3ZJLEtBQUssU0FBUywyREFBMkQsb0NBQW9DO0FBQzdHLEtBQUssU0FBUywyREFBMkQsbUNBQW1DO0FBQzVHLEtBQUssbUVBQW1FLGtCQUFrQjtBQUMxRixLQUFLLG1FQUFtRSxpQkFBaUI7QUFDekYsS0FBSyxtRUFBbUUsaUJBQWlCO0FBQ3pGLEtBQUssbUVBQW1FLGtCQUFrQjtBQUMxRixLQUFLLHFFQUFxRSx1Q0FBdUM7QUFDakgsS0FBSyxxRUFBcUUsd0NBQXdDO0FBQ2xILEtBQUssZ0ZBQWdGLDBFQUEwRTtBQUMvSixLQUFLLCtFQUErRSx5RUFBeUU7QUFDN0osS0FBSyx5REFBeUQ7QUFDOUQsS0FBSyx5RUFBeUU7QUFDOUUsS0FBSyxnRUFBZ0UsbUNBQW1DO0FBQ3hHLEtBQUssZ0VBQWdFLG9DQUFvQztBQUN6RyxLQUFLLGdFQUFnRSxvREFBb0Q7QUFDekgsS0FBSyw4REFBOEQsbUJBQW1CO0FBQ3RGLEtBQUssd0VBQXdFLHFDQUFxQztBQUNsSCxLQUFLLCtFQUErRSxtQ0FBbUM7QUFDdkgsS0FBSywrRUFBK0Usa0JBQWtCO0FBQ3RHLEtBQUssaUZBQWlGLGtDQUFrQztBQUN4SCxLQUFLLGlGQUFpRixrQkFBa0I7QUFDeEcsS0FBSyxTQUFTLHFFQUFxRSxpQkFBaUI7QUFDcEcsS0FBSyw4RUFBOEUsa0JBQWtCO0FBQ3JHLEtBQUsseUVBQXlFLGtDQUFrQztBQUNoSCxLQUFLLHdFQUF3RSxrQkFBa0I7QUFDL0YsS0FBSyxnRUFBZ0UsZ0JBQWdCLEVBQUU7QUFDdkYsS0FBSyxnRUFBZ0UsaUJBQWlCLEVBQUU7QUFDeEYsS0FBSyxpRUFBaUUsZ0NBQWdDLEVBQUU7QUFDeEcsS0FBSyxpRUFBaUUsaUNBQWlDLEVBQUU7QUFDekc7QUFDQSxLQUFLLHlFQUF5RSwrQ0FBK0M7QUFDN0gsS0FBSyx5RUFBeUUsZ0RBQWdEO0FBQzlILEtBQUssNEVBQTRFLGtDQUFrQztBQUNuSCxLQUFLLDRFQUE0RSxtQ0FBbUM7QUFDcEgsS0FBSyxtREFBbUQ7QUFDeEQsS0FBSyxrRkFBa0Y7QUFDdkYsS0FBSyw4RUFBOEUsZUFBZSxtQkFBbUI7QUFDckg7QUFDQSxLQUFLLGtEQUFrRDtBQUN2RCxLQUFLLGdEQUFnRDtBQUNyRCxLQUFLLGtEQUFrRDtBQUN2RCxLQUFLLHNEQUFzRDtBQUMzRCxLQUFLLGlFQUFpRSxxQkFBcUI7QUFDM0YsS0FBSyxpRUFBaUUsc0JBQXNCO0FBQzVGLEtBQUssdURBQXVEO0FBQzVELEtBQUssc0VBQXNFLGNBQWMsZ0JBQWdCO0FBQ3pHLEtBQUssc0VBQXNFLGVBQWUsZ0JBQWdCO0FBQzFHLEtBQUssNkRBQTZELG1DQUFtQztBQUNyRyxLQUFLLDZEQUE2RCxvQ0FBb0M7QUFDdEcsS0FBSyxnRkFBZ0YsaUJBQWlCO0FBQ3RHLEtBQUssZ0ZBQWdGLGtCQUFrQjtBQUN2RztBQUNBLEtBQUssaUdBQWlHLGdCQUFnQix1QkFBdUIscUJBQXFCO0FBQ2xLLEtBQUssaUdBQWlHLGlCQUFpQix1QkFBdUIsb0JBQW9CO0FBQ2xLLEtBQUssMEZBQTBGLGtCQUFrQixvQkFBb0I7QUFDckksS0FBSyxpRUFBaUUsaUJBQWlCLG9CQUFvQjtBQUMzRyxLQUFLLDJGQUEyRixpQkFBaUIsb0JBQW9CO0FBQ3JJLEtBQUssK0RBQStELGlCQUFpQixvQkFBb0I7QUFDekcsS0FBSywwRkFBMEYsa0JBQWtCLG9CQUFvQjtBQUNySSxLQUFLLGlFQUFpRSxpQkFBaUIsb0JBQW9CO0FBQzNHLEtBQUsscUdBQXFHLGdCQUFnQixpQkFBaUIseUJBQXlCLG9CQUFvQjtBQUN4TCxLQUFLLHdFQUF3RTtBQUM3RSxLQUFLLGdHQUFnRyxpQ0FBaUMscUJBQXFCO0FBQzNKO0FBQ0EsS0FBSyxpREFBaUQ7QUFDdEQ7QUFDQSxLQUFLLHFFQUFxRSxpQkFBaUI7QUFDM0YsS0FBSyxxRUFBcUUsa0JBQWtCO0FBQzVGLEtBQUssK0RBQStELGlDQUFpQztBQUNyRyxLQUFLLCtEQUErRCxrQ0FBa0M7QUFDdEcsS0FBSyxrRkFBa0Ysd0JBQXdCLHFCQUFxQjtBQUNwSSxLQUFLLGtGQUFrRixrQkFBa0IscUJBQXFCO0FBQzlILEtBQUssa0ZBQWtGLGdDQUFnQyxxQkFBcUI7QUFDNUksS0FBSyxrRkFBa0Ysc0JBQXNCLHFCQUFxQjtBQUNsSSxLQUFLLG1GQUFtRix1QkFBdUIscUJBQXFCO0FBQ3BJLEtBQUssa0ZBQWtGLDJCQUEyQixxQkFBcUI7QUFDdkksS0FBSyxtRkFBbUYsaUJBQWlCLHFCQUFxQjtBQUM5SCxLQUFLLGtGQUFrRixrQ0FBa0MscUJBQXFCO0FBQzlJLEtBQUsseUhBQXlILGNBQWMscUJBQXFCO0FBQ2pLLEtBQUsseUhBQXlILGVBQWUscUJBQXFCO0FBQ2xLLEtBQUssd0RBQXdEO0FBQzdELEtBQUsscUVBQXFFLGtCQUFrQjtBQUM1RixLQUFLLHlFQUF5RSxtQkFBbUI7QUFDakcsS0FBSyx5RUFBeUUsbUJBQW1CO0FBQ2pHLEtBQUssOERBQThEO0FBQ25FLEtBQUssK0RBQStEO0FBQ3BFLEtBQUssK0RBQStELG1CQUFtQixnQkFBZ0I7QUFDdkcsS0FBSyx3RUFBd0UsNkJBQTZCO0FBQzFHLEtBQUssd0VBQXdFLDhCQUE4QjtBQUMzRyxLQUFLLHdFQUF3RTtBQUM3RSxLQUFLLDhEQUE4RDtBQUNuRSxLQUFLLHVFQUF1RTtBQUM1RTtBQUNBLEtBQUssa0ZBQWtGLGdCQUFnQixvQkFBb0I7QUFDM0gsS0FBSyxpRUFBaUUsaUNBQWlDLDJDQUEyQztBQUNsSixLQUFLLCtEQUErRDtBQUNwRSxLQUFLLHFFQUFxRSxjQUFjLG1DQUFtQztBQUMzSCxLQUFLLHFFQUFxRSxlQUFlLG1DQUFtQztBQUM1SCxLQUFLLGdEQUFnRDtBQUNyRCxLQUFLLDBEQUEwRDtBQUMvRCxLQUFLLDhEQUE4RDtBQUNuRSxLQUFLLG9FQUFvRSxzQkFBc0I7QUFDL0YsS0FBSyxvRUFBb0UscUJBQXFCLCtDQUErQztBQUM3SSxLQUFLLG9FQUFvRSxtQkFBbUI7QUFDNUYsS0FBSyx1RUFBdUUsa0JBQWtCLCtDQUErQztBQUM3SSxLQUFLLG9FQUFvRSxzQkFBc0I7QUFDL0YsS0FBSyxvRUFBb0UscUJBQXFCLCtDQUErQztBQUM3SSxLQUFLLHNEQUFzRDtBQUMzRCxLQUFLLDJGQUEyRixrQ0FBa0M7QUFDbEksS0FBSywyRkFBMkYsbUNBQW1DO0FBQ25JLEtBQUssK0RBQStELG9CQUFvQixxQkFBcUI7QUFDN0csS0FBSywrREFBK0QscUJBQXFCLHFCQUFxQjtBQUM5RztBQUNBLEtBQUsseUVBQXlFO0FBQzlFLEtBQUssc0ZBQXNGLHlCQUF5QjtBQUNwSDtBQUNBLEtBQUsseUNBQXlDLHVEQUF1RDtBQUNyRyxLQUFLLHlDQUF5Qyx3REFBd0Q7QUFDdEcsS0FBSyx5Q0FBeUMscUZBQXFGO0FBQ25JLEtBQUsseUNBQXlDLHNGQUFzRjtBQUNwSSxLQUFLLDBDQUEwQyxnRUFBZ0U7QUFDL0csS0FBSywwQ0FBMEMsaUVBQWlFO0FBQ2hIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlDQUF5QztBQUM5QyxLQUFLLGNBQWM7QUFDbkIsS0FBSyxnQ0FBZ0M7QUFDckMsS0FBSyxnQ0FBZ0M7QUFDckMsS0FBSyxnQ0FBZ0M7QUFDckMsS0FBSyxnQkFBZ0I7QUFDckIsS0FBSyxnQ0FBZ0M7QUFDckMsS0FBSywrQkFBK0I7QUFDcEMsS0FBSyxpQ0FBaUM7QUFDdEMsS0FBSywrQkFBK0I7QUFDcEMsS0FBSyxzQ0FBc0M7QUFDM0MsS0FBSyx1Q0FBdUM7QUFDNUMsS0FBSyxpQ0FBaUM7QUFDdEMsS0FBSywwREFBMEQ7QUFDL0QsS0FBSyx1Q0FBdUM7QUFDNUMsS0FBSywrQkFBK0I7QUFDcEMsS0FBSyxzQ0FBc0M7QUFDM0MsS0FBSyx1RUFBdUU7QUFDNUUsS0FBSyxrQ0FBa0M7QUFDdkMsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0NBQWdDO0FBQ3JFLFdBQVc7QUFDWDtBQUNBO0FBQ0EscUNBQXFDLGdDQUFnQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBLGlDQUFpQyw4QkFBOEI7QUFDL0QsY0FBYyxxQkFBcUI7QUFDbkMsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRCQUE0QjtBQUM1QixxRUFBcUU7QUFDckUsV0FBVztBQUNYLDRCQUE0QjtBQUM1QiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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ZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9rZXltYXBfdmltX2pzLjkyNDYyYzAyZmQ1MjI3NjY5MzBjLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLyoqXG4gKiBTdXBwb3J0ZWQga2V5YmluZGluZ3M6XG4gKiAgIFRvbyBtYW55IHRvIGxpc3QuIFJlZmVyIHRvIGRlZmF1bHRLZXltYXAgYmVsb3cuXG4gKlxuICogU3VwcG9ydGVkIEV4IGNvbW1hbmRzOlxuICogICBSZWZlciB0byBkZWZhdWx0RXhDb21tYW5kTWFwIGJlbG93LlxuICpcbiAqIFJlZ2lzdGVyczogdW5uYW1lZCwgLSwgLiwgOiwgLywgXywgYS16LCBBLVosIDAtOVxuICogICAoRG9lcyBub3QgcmVzcGVjdCB0aGUgc3BlY2lhbCBjYXNlIGZvciBudW1iZXIgcmVnaXN0ZXJzIHdoZW4gZGVsZXRlXG4gKiAgICBvcGVyYXRvciBpcyBtYWRlIHdpdGggdGhlc2UgY29tbWFuZHM6ICUsICgsICksICAsIC8sID8sIG4sIE4sIHssIH0gKVxuICogICBUT0RPOiBJbXBsZW1lbnQgdGhlIHJlbWFpbmluZyByZWdpc3RlcnMuXG4gKlxuICogTWFya3M6IGEteiwgQS1aLCBhbmQgMC05XG4gKiAgIFRPRE86IEltcGxlbWVudCB0aGUgcmVtYWluaW5nIHNwZWNpYWwgbWFya3MuIFRoZXkgaGF2ZSBtb3JlIGNvbXBsZXhcbiAqICAgICAgIGJlaGF2aW9yLlxuICpcbiAqIEV2ZW50czpcbiAqICAndmltLW1vZGUtY2hhbmdlJyAtIHJhaXNlZCBvbiB0aGUgZWRpdG9yIGFueXRpbWUgdGhlIGN1cnJlbnQgbW9kZSBjaGFuZ2VzLFxuICogICAgICAgICAgICAgICAgICAgICAgRXZlbnQgb2JqZWN0OiB7bW9kZTogXCJ2aXN1YWxcIiwgc3ViTW9kZTogXCJsaW5ld2lzZVwifVxuICpcbiAqIENvZGUgc3RydWN0dXJlOlxuICogIDEuIERlZmF1bHQga2V5bWFwXG4gKiAgMi4gVmFyaWFibGUgZGVjbGFyYXRpb25zIGFuZCBzaG9ydCBiYXNpYyBoZWxwZXJzXG4gKiAgMy4gSW5zdGFuY2UgKEV4dGVybmFsIEFQSSkgaW1wbGVtZW50YXRpb25cbiAqICA0LiBJbnRlcm5hbCBzdGF0ZSB0cmFja2luZyBvYmplY3RzIChpbnB1dCBzdGF0ZSwgY291bnRlcikgaW1wbGVtZW50YXRpb25cbiAqICAgICBhbmQgaW5zdGFudGlhdGlvblxuICogIDUuIEtleSBoYW5kbGVyICh0aGUgbWFpbiBjb21tYW5kIGRpc3BhdGNoZXIpIGltcGxlbWVudGF0aW9uXG4gKiAgNi4gTW90aW9uLCBvcGVyYXRvciwgYW5kIGFjdGlvbiBpbXBsZW1lbnRhdGlvbnNcbiAqICA3LiBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUga2V5IGhhbmRsZXIsIG1vdGlvbnMsIG9wZXJhdG9ycywgYW5kIGFjdGlvbnNcbiAqICA4LiBTZXQgdXAgVmltIHRvIHdvcmsgYXMgYSBrZXltYXAgZm9yIENvZGVNaXJyb3IuXG4gKiAgOS4gRXggY29tbWFuZCBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uL2FkZG9uL3NlYXJjaC9zZWFyY2hjdXJzb3JcIiksIHJlcXVpcmUoXCIuLi9hZGRvbi9kaWFsb2cvZGlhbG9nXCIpLCByZXF1aXJlKFwiLi4vYWRkb24vZWRpdC9tYXRjaGJyYWNrZXRzLmpzXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4vYWRkb24vc2VhcmNoL3NlYXJjaGN1cnNvclwiLCBcIi4uL2FkZG9uL2RpYWxvZy9kaWFsb2dcIiwgXCIuLi9hZGRvbi9lZGl0L21hdGNoYnJhY2tldHNcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZGVmYXVsdEtleW1hcCA9IFtcbiAgICAvLyBLZXkgdG8ga2V5IG1hcHBpbmcuIFRoaXMgZ29lcyBmaXJzdCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIG92ZXJyaWRlXG4gICAgLy8gZXhpc3RpbmcgbWFwcGluZ3MuXG4gICAgeyBrZXlzOiAnPExlZnQ+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnaCcgfSxcbiAgICB7IGtleXM6ICc8UmlnaHQ+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnbCcgfSxcbiAgICB7IGtleXM6ICc8VXA+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnaycgfSxcbiAgICB7IGtleXM6ICc8RG93bj4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdqJyB9LFxuICAgIHsga2V5czogJzxTcGFjZT4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdsJyB9LFxuICAgIHsga2V5czogJzxCUz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdoJywgY29udGV4dDogJ25vcm1hbCd9LFxuICAgIHsga2V5czogJzxEZWw+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAneCcsIGNvbnRleHQ6ICdub3JtYWwnfSxcbiAgICB7IGtleXM6ICc8Qy1TcGFjZT4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdXJyB9LFxuICAgIHsga2V5czogJzxDLUJTPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ0InLCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJzxTLVNwYWNlPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ3cnIH0sXG4gICAgeyBrZXlzOiAnPFMtQlM+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnYicsIGNvbnRleHQ6ICdub3JtYWwnIH0sXG4gICAgeyBrZXlzOiAnPEMtbj4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdqJyB9LFxuICAgIHsga2V5czogJzxDLXA+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnaycgfSxcbiAgICB7IGtleXM6ICc8Qy1bPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJzxFc2M+JyB9LFxuICAgIHsga2V5czogJzxDLWM+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnPEVzYz4nIH0sXG4gICAgeyBrZXlzOiAnPEMtWz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICc8RXNjPicsIGNvbnRleHQ6ICdpbnNlcnQnIH0sXG4gICAgeyBrZXlzOiAnPEMtYz4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICc8RXNjPicsIGNvbnRleHQ6ICdpbnNlcnQnIH0sXG4gICAgeyBrZXlzOiAncycsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJ2NsJywgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICdzJywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnYycsIGNvbnRleHQ6ICd2aXN1YWwnfSxcbiAgICB7IGtleXM6ICdTJywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnY2MnLCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ1MnLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdWZE8nLCBjb250ZXh0OiAndmlzdWFsJyB9LFxuICAgIHsga2V5czogJzxIb21lPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJzAnIH0sXG4gICAgeyBrZXlzOiAnPEVuZD4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICckJyB9LFxuICAgIHsga2V5czogJzxQYWdlVXA+JywgdHlwZTogJ2tleVRvS2V5JywgdG9LZXlzOiAnPEMtYj4nIH0sXG4gICAgeyBrZXlzOiAnPFBhZ2VEb3duPicsIHR5cGU6ICdrZXlUb0tleScsIHRvS2V5czogJzxDLWY+JyB9LFxuICAgIHsga2V5czogJzxDUj4nLCB0eXBlOiAna2V5VG9LZXknLCB0b0tleXM6ICdqXicsIGNvbnRleHQ6ICdub3JtYWwnIH0sXG4gICAgeyBrZXlzOiAnPElucz4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAndG9nZ2xlT3ZlcndyaXRlJywgY29udGV4dDogJ2luc2VydCcgfSxcbiAgICAvLyBNb3Rpb25zXG4gICAgeyBrZXlzOiAnSCcsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9Ub3BMaW5lJywgbW90aW9uQXJnczogeyBsaW5ld2lzZTogdHJ1ZSwgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdNJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb01pZGRsZUxpbmUnLCBtb3Rpb25BcmdzOiB7IGxpbmV3aXNlOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ0wnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvQm90dG9tTGluZScsIG1vdGlvbkFyZ3M6IHsgbGluZXdpc2U6IHRydWUsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnaCcsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlDaGFyYWN0ZXJzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICdsJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeUNoYXJhY3RlcnMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnaicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlMaW5lcycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgbGluZXdpc2U6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnaycsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlMaW5lcycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIGxpbmV3aXNlOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2dqJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeURpc3BsYXlMaW5lcycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdnaycsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlEaXNwbGF5TGluZXMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlIH19LFxuICAgIHsga2V5czogJ3cnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5V29yZHMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIHdvcmRFbmQ6IGZhbHNlIH19LFxuICAgIHsga2V5czogJ1cnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5V29yZHMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIHdvcmRFbmQ6IGZhbHNlLCBiaWdXb3JkOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2UnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5V29yZHMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIHdvcmRFbmQ6IHRydWUsIGluY2x1c2l2ZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdFJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVdvcmRzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB3b3JkRW5kOiB0cnVlLCBiaWdXb3JkOiB0cnVlLCBpbmNsdXNpdmU6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnYicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlXb3JkcycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIHdvcmRFbmQ6IGZhbHNlIH19LFxuICAgIHsga2V5czogJ0InLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5V29yZHMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB3b3JkRW5kOiBmYWxzZSwgYmlnV29yZDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdnZScsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlXb3JkcycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIHdvcmRFbmQ6IHRydWUsIGluY2x1c2l2ZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdnRScsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlXb3JkcycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIHdvcmRFbmQ6IHRydWUsIGJpZ1dvcmQ6IHRydWUsIGluY2x1c2l2ZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICd7JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVBhcmFncmFwaCcsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnfScsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlQYXJhZ3JhcGgnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnKCcsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlTZW50ZW5jZScsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAnKScsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlTZW50ZW5jZScsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICc8Qy1mPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlQYWdlJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlIH19LFxuICAgIHsga2V5czogJzxDLWI+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVBhZ2UnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlIH19LFxuICAgIHsga2V5czogJzxDLWQ+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeVNjcm9sbCcsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgZXhwbGljaXRSZXBlYXQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnPEMtdT4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZUJ5U2Nyb2xsJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgZXhwbGljaXRSZXBlYXQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZ2cnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvTGluZU9yRWRnZU9mRG9jdW1lbnQnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCBleHBsaWNpdFJlcGVhdDogdHJ1ZSwgbGluZXdpc2U6IHRydWUsIHRvSnVtcGxpc3Q6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnRycsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9MaW5lT3JFZGdlT2ZEb2N1bWVudCcsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgZXhwbGljaXRSZXBlYXQ6IHRydWUsIGxpbmV3aXNlOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJzAnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvU3RhcnRPZkxpbmUnIH0sXG4gICAgeyBrZXlzOiAnXicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXInIH0sXG4gICAgeyBrZXlzOiAnKycsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlQnlMaW5lcycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgdG9GaXJzdENoYXI6dHJ1ZSB9fSxcbiAgICB7IGtleXM6ICctJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeUxpbmVzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgdG9GaXJzdENoYXI6dHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdfJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVCeUxpbmVzJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB0b0ZpcnN0Q2hhcjp0cnVlLCByZXBlYXRPZmZzZXQ6LTEgfX0sXG4gICAgeyBrZXlzOiAnJCcsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9Fb2wnLCBtb3Rpb25BcmdzOiB7IGluY2x1c2l2ZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICclJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb01hdGNoZWRTeW1ib2wnLCBtb3Rpb25BcmdzOiB7IGluY2x1c2l2ZTogdHJ1ZSwgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdmPGNoYXJhY3Rlcj4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvQ2hhcmFjdGVyJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlICwgaW5jbHVzaXZlOiB0cnVlIH19LFxuICAgIHsga2V5czogJ0Y8Y2hhcmFjdGVyPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVG9DaGFyYWN0ZXInLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlIH19LFxuICAgIHsga2V5czogJ3Q8Y2hhcmFjdGVyPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVGlsbENoYXJhY3RlcicsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgaW5jbHVzaXZlOiB0cnVlIH19LFxuICAgIHsga2V5czogJ1Q8Y2hhcmFjdGVyPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdtb3ZlVGlsbENoYXJhY3RlcicsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAnOycsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICdyZXBlYXRMYXN0Q2hhcmFjdGVyU2VhcmNoJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlIH19LFxuICAgIHsga2V5czogJywnLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAncmVwZWF0TGFzdENoYXJhY3RlclNlYXJjaCcsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UgfX0sXG4gICAgeyBrZXlzOiAnXFwnPGNoYXJhY3Rlcj4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnZ29Ub01hcmsnLCBtb3Rpb25BcmdzOiB7dG9KdW1wbGlzdDogdHJ1ZSwgbGluZXdpc2U6IHRydWV9fSxcbiAgICB7IGtleXM6ICdgPGNoYXJhY3Rlcj4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnZ29Ub01hcmsnLCBtb3Rpb25BcmdzOiB7dG9KdW1wbGlzdDogdHJ1ZX19LFxuICAgIHsga2V5czogJ11gJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2p1bXBUb01hcmsnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfSB9LFxuICAgIHsga2V5czogJ1tgJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2p1bXBUb01hcmsnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlIH0gfSxcbiAgICB7IGtleXM6ICddXFwnJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2p1bXBUb01hcmsnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIGxpbmV3aXNlOiB0cnVlIH0gfSxcbiAgICB7IGtleXM6ICdbXFwnJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2p1bXBUb01hcmsnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCBsaW5ld2lzZTogdHJ1ZSB9IH0sXG4gICAgLy8gdGhlIG5leHQgdHdvIGFyZW4ndCBtb3Rpb25zIGJ1dCBtdXN0IGNvbWUgYmVmb3JlIG1vcmUgZ2VuZXJhbCBtb3Rpb24gZGVjbGFyYXRpb25zXG4gICAgeyBrZXlzOiAnXXAnLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAncGFzdGUnLCBpc0VkaXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHsgYWZ0ZXI6IHRydWUsIGlzRWRpdDogdHJ1ZSwgbWF0Y2hJbmRlbnQ6IHRydWV9fSxcbiAgICB7IGtleXM6ICdbcCcsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdwYXN0ZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBhZnRlcjogZmFsc2UsIGlzRWRpdDogdHJ1ZSwgbWF0Y2hJbmRlbnQ6IHRydWV9fSxcbiAgICB7IGtleXM6ICddPGNoYXJhY3Rlcj4nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvU3ltYm9sJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlfX0sXG4gICAgeyBrZXlzOiAnWzxjaGFyYWN0ZXI+JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb1N5bWJvbCcsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIHRvSnVtcGxpc3Q6IHRydWV9fSxcbiAgICB7IGtleXM6ICd8JywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ21vdmVUb0NvbHVtbid9LFxuICAgIHsga2V5czogJ28nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvT3RoZXJIaWdobGlnaHRlZEVuZCcsIGNvbnRleHQ6J3Zpc3VhbCd9LFxuICAgIHsga2V5czogJ08nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnbW92ZVRvT3RoZXJIaWdobGlnaHRlZEVuZCcsIG1vdGlvbkFyZ3M6IHtzYW1lTGluZTogdHJ1ZX0sIGNvbnRleHQ6J3Zpc3VhbCd9LFxuICAgIC8vIE9wZXJhdG9yc1xuICAgIHsga2V5czogJ2QnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2RlbGV0ZScgfSxcbiAgICB7IGtleXM6ICd5JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICd5YW5rJyB9LFxuICAgIHsga2V5czogJ2MnLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2NoYW5nZScgfSxcbiAgICB7IGtleXM6ICc9JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdpbmRlbnRBdXRvJyB9LFxuICAgIHsga2V5czogJz4nLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2luZGVudCcsIG9wZXJhdG9yQXJnczogeyBpbmRlbnRSaWdodDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICc8JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdpbmRlbnQnLCBvcGVyYXRvckFyZ3M6IHsgaW5kZW50UmlnaHQ6IGZhbHNlIH19LFxuICAgIHsga2V5czogJ2d+JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2VDYXNlJyB9LFxuICAgIHsga2V5czogJ2d1JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2VDYXNlJywgb3BlcmF0b3JBcmdzOiB7dG9Mb3dlcjogdHJ1ZX0sIGlzRWRpdDogdHJ1ZSB9LFxuICAgIHsga2V5czogJ2dVJywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2VDYXNlJywgb3BlcmF0b3JBcmdzOiB7dG9Mb3dlcjogZmFsc2V9LCBpc0VkaXQ6IHRydWUgfSxcbiAgICB7IGtleXM6ICduJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2ZpbmROZXh0JywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ04nLCB0eXBlOiAnbW90aW9uJywgbW90aW9uOiAnZmluZE5leHQnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ2duJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2ZpbmRBbmRTZWxlY3ROZXh0SW5jbHVzaXZlJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2dOJywgdHlwZTogJ21vdGlvbicsIG1vdGlvbjogJ2ZpbmRBbmRTZWxlY3ROZXh0SW5jbHVzaXZlJywgbW90aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICAvLyBPcGVyYXRvci1Nb3Rpb24gZHVhbCBjb21tYW5kc1xuICAgIHsga2V5czogJ3gnLCB0eXBlOiAnb3BlcmF0b3JNb3Rpb24nLCBvcGVyYXRvcjogJ2RlbGV0ZScsIG1vdGlvbjogJ21vdmVCeUNoYXJhY3RlcnMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfSwgb3BlcmF0b3JNb3Rpb25BcmdzOiB7IHZpc3VhbExpbmU6IGZhbHNlIH19LFxuICAgIHsga2V5czogJ1gnLCB0eXBlOiAnb3BlcmF0b3JNb3Rpb24nLCBvcGVyYXRvcjogJ2RlbGV0ZScsIG1vdGlvbjogJ21vdmVCeUNoYXJhY3RlcnMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlIH0sIG9wZXJhdG9yTW90aW9uQXJnczogeyB2aXN1YWxMaW5lOiB0cnVlIH19LFxuICAgIHsga2V5czogJ0QnLCB0eXBlOiAnb3BlcmF0b3JNb3Rpb24nLCBvcGVyYXRvcjogJ2RlbGV0ZScsIG1vdGlvbjogJ21vdmVUb0VvbCcsIG1vdGlvbkFyZ3M6IHsgaW5jbHVzaXZlOiB0cnVlIH0sIGNvbnRleHQ6ICdub3JtYWwnfSxcbiAgICB7IGtleXM6ICdEJywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdkZWxldGUnLCBvcGVyYXRvckFyZ3M6IHsgbGluZXdpc2U6IHRydWUgfSwgY29udGV4dDogJ3Zpc3VhbCd9LFxuICAgIHsga2V5czogJ1knLCB0eXBlOiAnb3BlcmF0b3JNb3Rpb24nLCBvcGVyYXRvcjogJ3lhbmsnLCBtb3Rpb246ICdleHBhbmRUb0xpbmUnLCBtb3Rpb25BcmdzOiB7IGxpbmV3aXNlOiB0cnVlIH0sIGNvbnRleHQ6ICdub3JtYWwnfSxcbiAgICB7IGtleXM6ICdZJywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICd5YW5rJywgb3BlcmF0b3JBcmdzOiB7IGxpbmV3aXNlOiB0cnVlIH0sIGNvbnRleHQ6ICd2aXN1YWwnfSxcbiAgICB7IGtleXM6ICdDJywgdHlwZTogJ29wZXJhdG9yTW90aW9uJywgb3BlcmF0b3I6ICdjaGFuZ2UnLCBtb3Rpb246ICdtb3ZlVG9Fb2wnLCBtb3Rpb25BcmdzOiB7IGluY2x1c2l2ZTogdHJ1ZSB9LCBjb250ZXh0OiAnbm9ybWFsJ30sXG4gICAgeyBrZXlzOiAnQycsIHR5cGU6ICdvcGVyYXRvcicsIG9wZXJhdG9yOiAnY2hhbmdlJywgb3BlcmF0b3JBcmdzOiB7IGxpbmV3aXNlOiB0cnVlIH0sIGNvbnRleHQ6ICd2aXN1YWwnfSxcbiAgICB7IGtleXM6ICd+JywgdHlwZTogJ29wZXJhdG9yTW90aW9uJywgb3BlcmF0b3I6ICdjaGFuZ2VDYXNlJywgbW90aW9uOiAnbW92ZUJ5Q2hhcmFjdGVycycsIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSB9LCBvcGVyYXRvckFyZ3M6IHsgc2hvdWxkTW92ZUN1cnNvcjogdHJ1ZSB9LCBjb250ZXh0OiAnbm9ybWFsJ30sXG4gICAgeyBrZXlzOiAnficsIHR5cGU6ICdvcGVyYXRvcicsIG9wZXJhdG9yOiAnY2hhbmdlQ2FzZScsIGNvbnRleHQ6ICd2aXN1YWwnfSxcbiAgICB7IGtleXM6ICc8Qy13PicsIHR5cGU6ICdvcGVyYXRvck1vdGlvbicsIG9wZXJhdG9yOiAnZGVsZXRlJywgbW90aW9uOiAnbW92ZUJ5V29yZHMnLCBtb3Rpb25BcmdzOiB7IGZvcndhcmQ6IGZhbHNlLCB3b3JkRW5kOiBmYWxzZSB9LCBjb250ZXh0OiAnaW5zZXJ0JyB9LFxuICAgIC8vaWdub3JlIEMtdyBpbiBub3JtYWwgbW9kZVxuICAgIHsga2V5czogJzxDLXc+JywgdHlwZTogJ2lkbGUnLCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIC8vIEFjdGlvbnNcbiAgICB7IGtleXM6ICc8Qy1pPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdqdW1wTGlzdFdhbGsnLCBhY3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnPEMtbz4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnanVtcExpc3RXYWxrJywgYWN0aW9uQXJnczogeyBmb3J3YXJkOiBmYWxzZSB9fSxcbiAgICB7IGtleXM6ICc8Qy1lPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdzY3JvbGwnLCBhY3Rpb25BcmdzOiB7IGZvcndhcmQ6IHRydWUsIGxpbmV3aXNlOiB0cnVlIH19LFxuICAgIHsga2V5czogJzxDLXk+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Njcm9sbCcsIGFjdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIGxpbmV3aXNlOiB0cnVlIH19LFxuICAgIHsga2V5czogJ2EnLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnZW50ZXJJbnNlcnRNb2RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGluc2VydEF0OiAnY2hhckFmdGVyJyB9LCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ0EnLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnZW50ZXJJbnNlcnRNb2RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGluc2VydEF0OiAnZW9sJyB9LCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ0EnLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnZW50ZXJJbnNlcnRNb2RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGluc2VydEF0OiAnZW5kT2ZTZWxlY3RlZEFyZWEnIH0sIGNvbnRleHQ6ICd2aXN1YWwnIH0sXG4gICAgeyBrZXlzOiAnaScsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdlbnRlckluc2VydE1vZGUnLCBpc0VkaXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHsgaW5zZXJ0QXQ6ICdpbnBsYWNlJyB9LCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ2dpJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ2xhc3RFZGl0JyB9LCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ0knLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnZW50ZXJJbnNlcnRNb2RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGluc2VydEF0OiAnZmlyc3ROb25CbGFuayd9LCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ2dJJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2VudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBpbnNlcnRBdDogJ2JvbCd9LCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ0knLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnZW50ZXJJbnNlcnRNb2RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGluc2VydEF0OiAnc3RhcnRPZlNlbGVjdGVkQXJlYScgfSwgY29udGV4dDogJ3Zpc3VhbCcgfSxcbiAgICB7IGtleXM6ICdvJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ25ld0xpbmVBbmRFbnRlckluc2VydE1vZGUnLCBpc0VkaXQ6IHRydWUsIGludGVybGFjZUluc2VydFJlcGVhdDogdHJ1ZSwgYWN0aW9uQXJnczogeyBhZnRlcjogdHJ1ZSB9LCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ08nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnbmV3TGluZUFuZEVudGVySW5zZXJ0TW9kZScsIGlzRWRpdDogdHJ1ZSwgaW50ZXJsYWNlSW5zZXJ0UmVwZWF0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGFmdGVyOiBmYWxzZSB9LCBjb250ZXh0OiAnbm9ybWFsJyB9LFxuICAgIHsga2V5czogJ3YnLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAndG9nZ2xlVmlzdWFsTW9kZScgfSxcbiAgICB7IGtleXM6ICdWJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3RvZ2dsZVZpc3VhbE1vZGUnLCBhY3Rpb25BcmdzOiB7IGxpbmV3aXNlOiB0cnVlIH19LFxuICAgIHsga2V5czogJzxDLXY+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3RvZ2dsZVZpc3VhbE1vZGUnLCBhY3Rpb25BcmdzOiB7IGJsb2Nrd2lzZTogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICc8Qy1xPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICd0b2dnbGVWaXN1YWxNb2RlJywgYWN0aW9uQXJnczogeyBibG9ja3dpc2U6IHRydWUgfX0sXG4gICAgeyBrZXlzOiAnZ3YnLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAncmVzZWxlY3RMYXN0U2VsZWN0aW9uJyB9LFxuICAgIHsga2V5czogJ0onLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnam9pbkxpbmVzJywgaXNFZGl0OiB0cnVlIH0sXG4gICAgeyBrZXlzOiAnZ0onLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnam9pbkxpbmVzJywgYWN0aW9uQXJnczogeyBrZWVwU3BhY2VzOiB0cnVlIH0sIGlzRWRpdDogdHJ1ZSB9LFxuICAgIHsga2V5czogJ3AnLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAncGFzdGUnLCBpc0VkaXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHsgYWZ0ZXI6IHRydWUsIGlzRWRpdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICdQJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Bhc3RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IGFmdGVyOiBmYWxzZSwgaXNFZGl0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ3I8Y2hhcmFjdGVyPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdyZXBsYWNlJywgaXNFZGl0OiB0cnVlIH0sXG4gICAgeyBrZXlzOiAnQDxjaGFyYWN0ZXI+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3JlcGxheU1hY3JvJyB9LFxuICAgIHsga2V5czogJ3E8Y2hhcmFjdGVyPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdlbnRlck1hY3JvUmVjb3JkTW9kZScgfSxcbiAgICAvLyBIYW5kbGUgUmVwbGFjZS1tb2RlIGFzIGEgc3BlY2lhbCBjYXNlIG9mIGluc2VydCBtb2RlLlxuICAgIHsga2V5czogJ1InLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnZW50ZXJJbnNlcnRNb2RlJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7IHJlcGxhY2U6IHRydWUgfSwgY29udGV4dDogJ25vcm1hbCd9LFxuICAgIHsga2V5czogJ1InLCB0eXBlOiAnb3BlcmF0b3InLCBvcGVyYXRvcjogJ2NoYW5nZScsIG9wZXJhdG9yQXJnczogeyBsaW5ld2lzZTogdHJ1ZSwgZnVsbExpbmU6IHRydWUgfSwgY29udGV4dDogJ3Zpc3VhbCcsIGV4aXRWaXN1YWxCbG9jazogdHJ1ZX0sXG4gICAgeyBrZXlzOiAndScsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICd1bmRvJywgY29udGV4dDogJ25vcm1hbCcgfSxcbiAgICB7IGtleXM6ICd1JywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2VDYXNlJywgb3BlcmF0b3JBcmdzOiB7dG9Mb3dlcjogdHJ1ZX0sIGNvbnRleHQ6ICd2aXN1YWwnLCBpc0VkaXQ6IHRydWUgfSxcbiAgICB7IGtleXM6ICdVJywgdHlwZTogJ29wZXJhdG9yJywgb3BlcmF0b3I6ICdjaGFuZ2VDYXNlJywgb3BlcmF0b3JBcmdzOiB7dG9Mb3dlcjogZmFsc2V9LCBjb250ZXh0OiAndmlzdWFsJywgaXNFZGl0OiB0cnVlIH0sXG4gICAgeyBrZXlzOiAnPEMtcj4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAncmVkbycgfSxcbiAgICB7IGtleXM6ICdtPGNoYXJhY3Rlcj4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnc2V0TWFyaycgfSxcbiAgICB7IGtleXM6ICdcIjxjaGFyYWN0ZXI+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3NldFJlZ2lzdGVyJyB9LFxuICAgIHsga2V5czogJ3p6JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Njcm9sbFRvQ3Vyc29yJywgYWN0aW9uQXJnczogeyBwb3NpdGlvbjogJ2NlbnRlcicgfX0sXG4gICAgeyBrZXlzOiAnei4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnc2Nyb2xsVG9DdXJzb3InLCBhY3Rpb25BcmdzOiB7IHBvc2l0aW9uOiAnY2VudGVyJyB9LCBtb3Rpb246ICdtb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXInIH0sXG4gICAgeyBrZXlzOiAnenQnLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnc2Nyb2xsVG9DdXJzb3InLCBhY3Rpb25BcmdzOiB7IHBvc2l0aW9uOiAndG9wJyB9fSxcbiAgICB7IGtleXM6ICd6PENSPicsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdzY3JvbGxUb0N1cnNvcicsIGFjdGlvbkFyZ3M6IHsgcG9zaXRpb246ICd0b3AnIH0sIG1vdGlvbjogJ21vdmVUb0ZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcicgfSxcbiAgICB7IGtleXM6ICd6LScsIHR5cGU6ICdhY3Rpb24nLCBhY3Rpb246ICdzY3JvbGxUb0N1cnNvcicsIGFjdGlvbkFyZ3M6IHsgcG9zaXRpb246ICdib3R0b20nIH19LFxuICAgIHsga2V5czogJ3piJywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ3Njcm9sbFRvQ3Vyc29yJywgYWN0aW9uQXJnczogeyBwb3NpdGlvbjogJ2JvdHRvbScgfSwgbW90aW9uOiAnbW92ZVRvRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyJyB9LFxuICAgIHsga2V5czogJy4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAncmVwZWF0TGFzdEVkaXQnIH0sXG4gICAgeyBrZXlzOiAnPEMtYT4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnaW5jcmVtZW50TnVtYmVyVG9rZW4nLCBpc0VkaXQ6IHRydWUsIGFjdGlvbkFyZ3M6IHtpbmNyZWFzZTogdHJ1ZSwgYmFja3RyYWNrOiBmYWxzZX19LFxuICAgIHsga2V5czogJzxDLXg+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2luY3JlbWVudE51bWJlclRva2VuJywgaXNFZGl0OiB0cnVlLCBhY3Rpb25BcmdzOiB7aW5jcmVhc2U6IGZhbHNlLCBiYWNrdHJhY2s6IGZhbHNlfX0sXG4gICAgeyBrZXlzOiAnPEMtdD4nLCB0eXBlOiAnYWN0aW9uJywgYWN0aW9uOiAnaW5kZW50JywgYWN0aW9uQXJnczogeyBpbmRlbnRSaWdodDogdHJ1ZSB9LCBjb250ZXh0OiAnaW5zZXJ0JyB9LFxuICAgIHsga2V5czogJzxDLWQ+JywgdHlwZTogJ2FjdGlvbicsIGFjdGlvbjogJ2luZGVudCcsIGFjdGlvbkFyZ3M6IHsgaW5kZW50UmlnaHQ6IGZhbHNlIH0sIGNvbnRleHQ6ICdpbnNlcnQnIH0sXG4gICAgLy8gVGV4dCBvYmplY3QgbW90aW9uc1xuICAgIHsga2V5czogJ2E8Y2hhcmFjdGVyPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICd0ZXh0T2JqZWN0TWFuaXB1bGF0aW9uJyB9LFxuICAgIHsga2V5czogJ2k8Y2hhcmFjdGVyPicsIHR5cGU6ICdtb3Rpb24nLCBtb3Rpb246ICd0ZXh0T2JqZWN0TWFuaXB1bGF0aW9uJywgbW90aW9uQXJnczogeyB0ZXh0T2JqZWN0SW5uZXI6IHRydWUgfX0sXG4gICAgLy8gU2VhcmNoXG4gICAgeyBrZXlzOiAnLycsIHR5cGU6ICdzZWFyY2gnLCBzZWFyY2hBcmdzOiB7IGZvcndhcmQ6IHRydWUsIHF1ZXJ5U3JjOiAncHJvbXB0JywgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICc/JywgdHlwZTogJ3NlYXJjaCcsIHNlYXJjaEFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIHF1ZXJ5U3JjOiAncHJvbXB0JywgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICB7IGtleXM6ICcqJywgdHlwZTogJ3NlYXJjaCcsIHNlYXJjaEFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgcXVlcnlTcmM6ICd3b3JkVW5kZXJDdXJzb3InLCB3aG9sZVdvcmRPbmx5OiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJyMnLCB0eXBlOiAnc2VhcmNoJywgc2VhcmNoQXJnczogeyBmb3J3YXJkOiBmYWxzZSwgcXVlcnlTcmM6ICd3b3JkVW5kZXJDdXJzb3InLCB3aG9sZVdvcmRPbmx5OiB0cnVlLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ2cqJywgdHlwZTogJ3NlYXJjaCcsIHNlYXJjaEFyZ3M6IHsgZm9yd2FyZDogdHJ1ZSwgcXVlcnlTcmM6ICd3b3JkVW5kZXJDdXJzb3InLCB0b0p1bXBsaXN0OiB0cnVlIH19LFxuICAgIHsga2V5czogJ2cjJywgdHlwZTogJ3NlYXJjaCcsIHNlYXJjaEFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIHF1ZXJ5U3JjOiAnd29yZFVuZGVyQ3Vyc29yJywgdG9KdW1wbGlzdDogdHJ1ZSB9fSxcbiAgICAvLyBFeCBjb21tYW5kXG4gICAgeyBrZXlzOiAnOicsIHR5cGU6ICdleCcgfVxuICBdO1xuICB2YXIgZGVmYXVsdEtleW1hcExlbmd0aCA9IGRlZmF1bHRLZXltYXAubGVuZ3RoO1xuXG4gIC8qKlxuICAgKiBFeCBjb21tYW5kc1xuICAgKiBDYXJlIG11c3QgYmUgdGFrZW4gd2hlbiBhZGRpbmcgdG8gdGhlIGRlZmF1bHQgRXggY29tbWFuZCBtYXAuIEZvciBhbnlcbiAgICogcGFpciBvZiBjb21tYW5kcyB0aGF0IGhhdmUgYSBzaGFyZWQgcHJlZml4LCBhdCBsZWFzdCBvbmUgb2YgdGhlaXJcbiAgICogc2hvcnROYW1lcyBtdXN0IG5vdCBtYXRjaCB0aGUgcHJlZml4IG9mIHRoZSBvdGhlciBjb21tYW5kLlxuICAgKi9cbiAgdmFyIGRlZmF1bHRFeENvbW1hbmRNYXAgPSBbXG4gICAgeyBuYW1lOiAnY29sb3JzY2hlbWUnLCBzaG9ydE5hbWU6ICdjb2xvJyB9LFxuICAgIHsgbmFtZTogJ21hcCcgfSxcbiAgICB7IG5hbWU6ICdpbWFwJywgc2hvcnROYW1lOiAnaW0nIH0sXG4gICAgeyBuYW1lOiAnbm1hcCcsIHNob3J0TmFtZTogJ25tJyB9LFxuICAgIHsgbmFtZTogJ3ZtYXAnLCBzaG9ydE5hbWU6ICd2bScgfSxcbiAgICB7IG5hbWU6ICd1bm1hcCcgfSxcbiAgICB7IG5hbWU6ICd3cml0ZScsIHNob3J0TmFtZTogJ3cnIH0sXG4gICAgeyBuYW1lOiAndW5kbycsIHNob3J0TmFtZTogJ3UnIH0sXG4gICAgeyBuYW1lOiAncmVkbycsIHNob3J0TmFtZTogJ3JlZCcgfSxcbiAgICB7IG5hbWU6ICdzZXQnLCBzaG9ydE5hbWU6ICdzZScgfSxcbiAgICB7IG5hbWU6ICdzZXRsb2NhbCcsIHNob3J0TmFtZTogJ3NldGwnIH0sXG4gICAgeyBuYW1lOiAnc2V0Z2xvYmFsJywgc2hvcnROYW1lOiAnc2V0ZycgfSxcbiAgICB7IG5hbWU6ICdzb3J0Jywgc2hvcnROYW1lOiAnc29yJyB9LFxuICAgIHsgbmFtZTogJ3N1YnN0aXR1dGUnLCBzaG9ydE5hbWU6ICdzJywgcG9zc2libHlBc3luYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogJ25vaGxzZWFyY2gnLCBzaG9ydE5hbWU6ICdub2gnIH0sXG4gICAgeyBuYW1lOiAneWFuaycsIHNob3J0TmFtZTogJ3knIH0sXG4gICAgeyBuYW1lOiAnZGVsbWFya3MnLCBzaG9ydE5hbWU6ICdkZWxtJyB9LFxuICAgIHsgbmFtZTogJ3JlZ2lzdGVycycsIHNob3J0TmFtZTogJ3JlZycsIGV4Y2x1ZGVGcm9tQ29tbWFuZEhpc3Rvcnk6IHRydWUgfSxcbiAgICB7IG5hbWU6ICd2Z2xvYmFsJywgc2hvcnROYW1lOiAndicgfSxcbiAgICB7IG5hbWU6ICdnbG9iYWwnLCBzaG9ydE5hbWU6ICdnJyB9XG4gIF07XG5cbiAgdmFyIFBvcyA9IENvZGVNaXJyb3IuUG9zO1xuXG4gIHZhciBWaW0gPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBlbnRlclZpbU1vZGUoY20pIHtcbiAgICAgIGNtLnNldE9wdGlvbignZGlzYWJsZUlucHV0JywgdHJ1ZSk7XG4gICAgICBjbS5zZXRPcHRpb24oJ3Nob3dDdXJzb3JXaGVuU2VsZWN0aW5nJywgZmFsc2UpO1xuICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcIm5vcm1hbFwifSk7XG4gICAgICBjbS5vbignY3Vyc29yQWN0aXZpdHknLCBvbkN1cnNvckFjdGl2aXR5KTtcbiAgICAgIG1heWJlSW5pdFZpbVN0YXRlKGNtKTtcbiAgICAgIENvZGVNaXJyb3Iub24oY20uZ2V0SW5wdXRGaWVsZCgpLCAncGFzdGUnLCBnZXRPblBhc3RlRm4oY20pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZWF2ZVZpbU1vZGUoY20pIHtcbiAgICAgIGNtLnNldE9wdGlvbignZGlzYWJsZUlucHV0JywgZmFsc2UpO1xuICAgICAgY20ub2ZmKCdjdXJzb3JBY3Rpdml0eScsIG9uQ3Vyc29yQWN0aXZpdHkpO1xuICAgICAgQ29kZU1pcnJvci5vZmYoY20uZ2V0SW5wdXRGaWVsZCgpLCAncGFzdGUnLCBnZXRPblBhc3RlRm4oY20pKTtcbiAgICAgIGNtLnN0YXRlLnZpbSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0YWNoVmltTWFwKGNtLCBuZXh0KSB7XG4gICAgICBpZiAodGhpcyA9PSBDb2RlTWlycm9yLmtleU1hcC52aW0pIHtcbiAgICAgICAgQ29kZU1pcnJvci5ybUNsYXNzKGNtLmdldFdyYXBwZXJFbGVtZW50KCksIFwiY20tZmF0LWN1cnNvclwiKTtcbiAgICAgICAgaWYgKGNtLmdldE9wdGlvbihcImlucHV0U3R5bGVcIikgPT0gXCJjb250ZW50ZWRpdGFibGVcIiAmJiBkb2N1bWVudC5ib2R5LnN0eWxlLmNhcmV0Q29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgIGRpc2FibGVGYXRDdXJzb3JNYXJrKGNtKTtcbiAgICAgICAgICBjbS5nZXRJbnB1dEZpZWxkKCkuc3R5bGUuY2FyZXRDb2xvciA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXh0IHx8IG5leHQuYXR0YWNoICE9IGF0dGFjaFZpbU1hcClcbiAgICAgICAgbGVhdmVWaW1Nb2RlKGNtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0YWNoVmltTWFwKGNtLCBwcmV2KSB7XG4gICAgICBpZiAodGhpcyA9PSBDb2RlTWlycm9yLmtleU1hcC52aW0pIHtcbiAgICAgICAgQ29kZU1pcnJvci5hZGRDbGFzcyhjbS5nZXRXcmFwcGVyRWxlbWVudCgpLCBcImNtLWZhdC1jdXJzb3JcIik7XG4gICAgICAgIGlmIChjbS5nZXRPcHRpb24oXCJpbnB1dFN0eWxlXCIpID09IFwiY29udGVudGVkaXRhYmxlXCIgJiYgZG9jdW1lbnQuYm9keS5zdHlsZS5jYXJldENvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICBlbmFibGVGYXRDdXJzb3JNYXJrKGNtKTtcbiAgICAgICAgICBjbS5nZXRJbnB1dEZpZWxkKCkuc3R5bGUuY2FyZXRDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXByZXYgfHwgcHJldi5hdHRhY2ggIT0gYXR0YWNoVmltTWFwKVxuICAgICAgICBlbnRlclZpbU1vZGUoY20pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZhdEN1cnNvck1hcmsoY20pIHtcbiAgICAgIGlmICghY20uc3RhdGUuZmF0Q3Vyc29yTWFya3MpIHJldHVybjtcbiAgICAgIGNsZWFyRmF0Q3Vyc29yTWFyayhjbSk7XG4gICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgcmVzdWx0ID0gW11cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpIHtcbiAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IGNtLmdldExpbmUocmFuZ2UuYW5jaG9yLmxpbmUpLmxlbmd0aDtcbiAgICAgICAgICBpZiAocmFuZ2UuYW5jaG9yLmNoIDwgbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY20ubWFya1RleHQocmFuZ2UuYW5jaG9yLCBQb3MocmFuZ2UuYW5jaG9yLmxpbmUsIHJhbmdlLmFuY2hvci5jaCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsYXNzTmFtZTogXCJjbS1mYXQtY3Vyc29yLW1hcmtcIn0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY20ubWFya1RleHQoUG9zKHJhbmdlLmFuY2hvci5saW5lLCBsaW5lTGVuZ3RoIC0gMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MocmFuZ2UuYW5jaG9yLmxpbmUsIGxpbmVMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsYXNzTmFtZTogXCJjbS1mYXQtY3Vyc29yLW1hcmtcIn0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNtLnN0YXRlLmZhdEN1cnNvck1hcmtzID0gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyRmF0Q3Vyc29yTWFyayhjbSkge1xuICAgICAgdmFyIG1hcmtzID0gY20uc3RhdGUuZmF0Q3Vyc29yTWFya3M7XG4gICAgICBpZiAobWFya3MpIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIG1hcmtzW2ldLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5hYmxlRmF0Q3Vyc29yTWFyayhjbSkge1xuICAgICAgY20uc3RhdGUuZmF0Q3Vyc29yTWFya3MgPSBbXTtcbiAgICAgIHVwZGF0ZUZhdEN1cnNvck1hcmsoY20pXG4gICAgICBjbS5vbihcImN1cnNvckFjdGl2aXR5XCIsIHVwZGF0ZUZhdEN1cnNvck1hcmspXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzYWJsZUZhdEN1cnNvck1hcmsoY20pIHtcbiAgICAgIGNsZWFyRmF0Q3Vyc29yTWFyayhjbSk7XG4gICAgICBjbS5vZmYoXCJjdXJzb3JBY3Rpdml0eVwiLCB1cGRhdGVGYXRDdXJzb3JNYXJrKTtcbiAgICAgIC8vIGV4cGxpY2l0bHkgc2V0IGZhdEN1cnNvck1hcmtzIHRvIG51bGwgYmVjYXVzZSBldmVudCBsaXN0ZW5lciBhYm92ZVxuICAgICAgLy8gY2FuIGJlIGludm9rZSBhZnRlciByZW1vdmluZyBpdCwgaWYgb2ZmIGlzIGNhbGxlZCBmcm9tIG9wZXJhdGlvblxuICAgICAgY20uc3RhdGUuZmF0Q3Vyc29yTWFya3MgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIERlcHJlY2F0ZWQsIHNpbXBseSBzZXR0aW5nIHRoZSBrZXltYXAgd29ya3MgYWdhaW4uXG4gICAgQ29kZU1pcnJvci5kZWZpbmVPcHRpb24oJ3ZpbU1vZGUnLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCwgcHJldikge1xuICAgICAgaWYgKHZhbCAmJiBjbS5nZXRPcHRpb24oXCJrZXlNYXBcIikgIT0gXCJ2aW1cIilcbiAgICAgICAgY20uc2V0T3B0aW9uKFwia2V5TWFwXCIsIFwidmltXCIpO1xuICAgICAgZWxzZSBpZiAoIXZhbCAmJiBwcmV2ICE9IENvZGVNaXJyb3IuSW5pdCAmJiAvXnZpbS8udGVzdChjbS5nZXRPcHRpb24oXCJrZXlNYXBcIikpKVxuICAgICAgICBjbS5zZXRPcHRpb24oXCJrZXlNYXBcIiwgXCJkZWZhdWx0XCIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY21LZXkoa2V5LCBjbSkge1xuICAgICAgaWYgKCFjbSkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgICBpZiAodGhpc1trZXldKSB7IHJldHVybiB0aGlzW2tleV07IH1cbiAgICAgIHZhciB2aW1LZXkgPSBjbUtleVRvVmltS2V5KGtleSk7XG4gICAgICBpZiAoIXZpbUtleSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgY21kID0gQ29kZU1pcnJvci5WaW0uZmluZEtleShjbSwgdmltS2V5KTtcbiAgICAgIGlmICh0eXBlb2YgY21kID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sICd2aW0ta2V5cHJlc3MnLCB2aW1LZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNtZDtcbiAgICB9XG5cbiAgICB2YXIgbW9kaWZpZXJzID0ge1NoaWZ0OidTJyxDdHJsOidDJyxBbHQ6J0EnLENtZDonRCcsTW9kOidBJyxDYXBzTG9jazonJ307XG4gICAgdmFyIHNwZWNpYWxLZXlzID0ge0VudGVyOidDUicsQmFja3NwYWNlOidCUycsRGVsZXRlOidEZWwnLEluc2VydDonSW5zJ307XG4gICAgZnVuY3Rpb24gY21LZXlUb1ZpbUtleShrZXkpIHtcbiAgICAgIGlmIChrZXkuY2hhckF0KDApID09ICdcXCcnKSB7XG4gICAgICAgIC8vIEtleXByZXNzIGNoYXJhY3RlciBiaW5kaW5nIG9mIGZvcm1hdCBcIidhJ1wiXG4gICAgICAgIHJldHVybiBrZXkuY2hhckF0KDEpO1xuICAgICAgfVxuICAgICAgdmFyIHBpZWNlcyA9IGtleS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgICB2YXIgbGFzdFBpZWNlID0gcGllY2VzW3BpZWNlcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChwaWVjZXMubGVuZ3RoID09IDEgJiYgcGllY2VzWzBdLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIE5vLW1vZGlmaWVyIGJpbmRpbmdzIHVzZSBsaXRlcmFsIGNoYXJhY3RlciBiaW5kaW5ncyBhYm92ZS4gU2tpcC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwaWVjZXMubGVuZ3RoID09IDIgJiYgcGllY2VzWzBdID09ICdTaGlmdCcgJiYgbGFzdFBpZWNlLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIElnbm9yZSBTaGlmdCtjaGFyIGJpbmRpbmdzIGFzIHRoZXkgc2hvdWxkIGJlIGhhbmRsZWQgYnkgbGl0ZXJhbCBjaGFyYWN0ZXIuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwaWVjZSA9IHBpZWNlc1tpXTtcbiAgICAgICAgaWYgKHBpZWNlIGluIG1vZGlmaWVycykgeyBwaWVjZXNbaV0gPSBtb2RpZmllcnNbcGllY2VdOyB9XG4gICAgICAgIGVsc2UgeyBoYXNDaGFyYWN0ZXIgPSB0cnVlOyB9XG4gICAgICAgIGlmIChwaWVjZSBpbiBzcGVjaWFsS2V5cykgeyBwaWVjZXNbaV0gPSBzcGVjaWFsS2V5c1twaWVjZV07IH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFzQ2hhcmFjdGVyKSB7XG4gICAgICAgIC8vIFZpbSBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVyIG9ubHkga2V5cy5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogQ3VycmVudCBiaW5kaW5ncyBleHBlY3QgdGhlIGNoYXJhY3RlciB0byBiZSBsb3dlciBjYXNlLCBidXRcbiAgICAgIC8vIGl0IGxvb2tzIGxpa2UgdmltIGtleSBub3RhdGlvbiB1c2VzIHVwcGVyIGNhc2UuXG4gICAgICBpZiAoaXNVcHBlckNhc2UobGFzdFBpZWNlKSkge1xuICAgICAgICBwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdID0gbGFzdFBpZWNlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJzwnICsgcGllY2VzLmpvaW4oJy0nKSArICc+JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRPblBhc3RlRm4oY20pIHtcbiAgICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgICBpZiAoIXZpbS5vblBhc3RlRm4pIHtcbiAgICAgICAgdmltLm9uUGFzdGVGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdmltLmluc2VydE1vZGUpIHtcbiAgICAgICAgICAgIGNtLnNldEN1cnNvcihvZmZzZXRDdXJzb3IoY20uZ2V0Q3Vyc29yKCksIDAsIDEpKTtcbiAgICAgICAgICAgIGFjdGlvbnMuZW50ZXJJbnNlcnRNb2RlKGNtLCB7fSwgdmltKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmltLm9uUGFzdGVGbjtcbiAgICB9XG5cbiAgICB2YXIgbnVtYmVyUmVnZXggPSAvW1xcZF0vO1xuICAgIHZhciB3b3JkQ2hhclRlc3QgPSBbQ29kZU1pcnJvci5pc1dvcmRDaGFyLCBmdW5jdGlvbihjaCkge1xuICAgICAgcmV0dXJuIGNoICYmICFDb2RlTWlycm9yLmlzV29yZENoYXIoY2gpICYmICEvXFxzLy50ZXN0KGNoKTtcbiAgICB9XSwgYmlnV29yZENoYXJUZXN0ID0gW2Z1bmN0aW9uKGNoKSB7XG4gICAgICByZXR1cm4gL1xcUy8udGVzdChjaCk7XG4gICAgfV07XG4gICAgZnVuY3Rpb24gbWFrZUtleVJhbmdlKHN0YXJ0LCBzaXplKSB7XG4gICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBzaXplOyBpKyspIHtcbiAgICAgICAga2V5cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIHZhciB1cHBlckNhc2VBbHBoYWJldCA9IG1ha2VLZXlSYW5nZSg2NSwgMjYpO1xuICAgIHZhciBsb3dlckNhc2VBbHBoYWJldCA9IG1ha2VLZXlSYW5nZSg5NywgMjYpO1xuICAgIHZhciBudW1iZXJzID0gbWFrZUtleVJhbmdlKDQ4LCAxMCk7XG4gICAgdmFyIHZhbGlkTWFya3MgPSBbXS5jb25jYXQodXBwZXJDYXNlQWxwaGFiZXQsIGxvd2VyQ2FzZUFscGhhYmV0LCBudW1iZXJzLCBbJzwnLCAnPiddKTtcbiAgICB2YXIgdmFsaWRSZWdpc3RlcnMgPSBbXS5jb25jYXQodXBwZXJDYXNlQWxwaGFiZXQsIGxvd2VyQ2FzZUFscGhhYmV0LCBudW1iZXJzLCBbJy0nLCAnXCInLCAnLicsICc6JywgJ18nLCAnLyddKTtcblxuICAgIGZ1bmN0aW9uIGlzTGluZShjbSwgbGluZSkge1xuICAgICAgcmV0dXJuIGxpbmUgPj0gY20uZmlyc3RMaW5lKCkgJiYgbGluZSA8PSBjbS5sYXN0TGluZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xvd2VyQ2FzZShrKSB7XG4gICAgICByZXR1cm4gKC9eW2Etel0kLykudGVzdChrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNNYXRjaGFibGVTeW1ib2woaykge1xuICAgICAgcmV0dXJuICcoKVtde30nLmluZGV4T2YoaykgIT0gLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKGspIHtcbiAgICAgIHJldHVybiBudW1iZXJSZWdleC50ZXN0KGspO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1VwcGVyQ2FzZShrKSB7XG4gICAgICByZXR1cm4gKC9eW0EtWl0kLykudGVzdChrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlU3RyaW5nKGspIHtcbiAgICAgIHJldHVybiAoL15cXHMqJC8pLnRlc3Qoayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRW5kT2ZTZW50ZW5jZVN5bWJvbChrKSB7XG4gICAgICByZXR1cm4gJy4/IScuaW5kZXhPZihrKSAhPSAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5BcnJheSh2YWwsIGFycikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSA9PSB2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgZnVuY3Rpb24gZGVmaW5lT3B0aW9uKG5hbWUsIGRlZmF1bHRWYWx1ZSwgdHlwZSwgYWxpYXNlcywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2RlZmF1bHRWYWx1ZSBpcyByZXF1aXJlZCB1bmxlc3MgY2FsbGJhY2sgaXMgcHJvdmlkZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICghdHlwZSkgeyB0eXBlID0gJ3N0cmluZyc7IH1cbiAgICAgIG9wdGlvbnNbbmFtZV0gPSB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgIH07XG4gICAgICBpZiAoYWxpYXNlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsaWFzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvcHRpb25zW2FsaWFzZXNbaV1dID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBzZXRPcHRpb24obmFtZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPcHRpb24obmFtZSwgdmFsdWUsIGNtLCBjZmcpIHtcbiAgICAgIHZhciBvcHRpb24gPSBvcHRpb25zW25hbWVdO1xuICAgICAgY2ZnID0gY2ZnIHx8IHt9O1xuICAgICAgdmFyIHNjb3BlID0gY2ZnLnNjb3BlO1xuICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignVW5rbm93biBvcHRpb246ICcgKyBuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb24udHlwZSA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudDogJyArIG5hbWUgKyAnPScgKyB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gQm9vbGVhbiBvcHRpb25zIGFyZSBzZXQgdG8gdHJ1ZSBpZiB2YWx1ZSBpcyBub3QgZGVmaW5lZC5cbiAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb24uY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHNjb3BlICE9PSAnbG9jYWwnKSB7XG4gICAgICAgICAgb3B0aW9uLmNhbGxiYWNrKHZhbHVlLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY29wZSAhPT0gJ2dsb2JhbCcgJiYgY20pIHtcbiAgICAgICAgICBvcHRpb24uY2FsbGJhY2sodmFsdWUsIGNtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNjb3BlICE9PSAnbG9jYWwnKSB7XG4gICAgICAgICAgb3B0aW9uLnZhbHVlID0gb3B0aW9uLnR5cGUgPT0gJ2Jvb2xlYW4nID8gISF2YWx1ZSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY29wZSAhPT0gJ2dsb2JhbCcgJiYgY20pIHtcbiAgICAgICAgICBjbS5zdGF0ZS52aW0ub3B0aW9uc1tuYW1lXSA9IHt2YWx1ZTogdmFsdWV9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0T3B0aW9uKG5hbWUsIGNtLCBjZmcpIHtcbiAgICAgIHZhciBvcHRpb24gPSBvcHRpb25zW25hbWVdO1xuICAgICAgY2ZnID0gY2ZnIHx8IHt9O1xuICAgICAgdmFyIHNjb3BlID0gY2ZnLnNjb3BlO1xuICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignVW5rbm93biBvcHRpb246ICcgKyBuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb24uY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGxvY2FsID0gY20gJiYgb3B0aW9uLmNhbGxiYWNrKHVuZGVmaW5lZCwgY20pO1xuICAgICAgICBpZiAoc2NvcGUgIT09ICdnbG9iYWwnICYmIGxvY2FsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3BlICE9PSAnbG9jYWwnKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbi5jYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsb2NhbCA9IChzY29wZSAhPT0gJ2dsb2JhbCcpICYmIChjbSAmJiBjbS5zdGF0ZS52aW0ub3B0aW9uc1tuYW1lXSk7XG4gICAgICAgIHJldHVybiAobG9jYWwgfHwgKHNjb3BlICE9PSAnbG9jYWwnKSAmJiBvcHRpb24gfHwge30pLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlZmluZU9wdGlvbignZmlsZXR5cGUnLCB1bmRlZmluZWQsICdzdHJpbmcnLCBbJ2Z0J10sIGZ1bmN0aW9uKG5hbWUsIGNtKSB7XG4gICAgICAvLyBPcHRpb24gaXMgbG9jYWwuIERvIG5vdGhpbmcgZm9yIGdsb2JhbC5cbiAgICAgIGlmIChjbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSAnZmlsZXR5cGUnIG9wdGlvbiBwcm94aWVzIHRvIHRoZSBDb2RlTWlycm9yICdtb2RlJyBvcHRpb24uXG4gICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBtb2RlID0gY20uZ2V0T3B0aW9uKCdtb2RlJyk7XG4gICAgICAgIHJldHVybiBtb2RlID09ICdudWxsJyA/ICcnIDogbW9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtb2RlID0gbmFtZSA9PSAnJyA/ICdudWxsJyA6IG5hbWU7XG4gICAgICAgIGNtLnNldE9wdGlvbignbW9kZScsIG1vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGNyZWF0ZUNpcmN1bGFySnVtcExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzaXplID0gMTAwO1xuICAgICAgdmFyIHBvaW50ZXIgPSAtMTtcbiAgICAgIHZhciBoZWFkID0gMDtcbiAgICAgIHZhciB0YWlsID0gMDtcbiAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICBmdW5jdGlvbiBhZGQoY20sIG9sZEN1ciwgbmV3Q3VyKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcG9pbnRlciAlIHNpemU7XG4gICAgICAgIHZhciBjdXJNYXJrID0gYnVmZmVyW2N1cnJlbnRdO1xuICAgICAgICBmdW5jdGlvbiB1c2VOZXh0U2xvdChjdXJzb3IpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9ICsrcG9pbnRlciAlIHNpemU7XG4gICAgICAgICAgdmFyIHRyYXNoTWFyayA9IGJ1ZmZlcltuZXh0XTtcbiAgICAgICAgICBpZiAodHJhc2hNYXJrKSB7XG4gICAgICAgICAgICB0cmFzaE1hcmsuY2xlYXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyW25leHRdID0gY20uc2V0Qm9va21hcmsoY3Vyc29yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyTWFyaykge1xuICAgICAgICAgIHZhciBtYXJrUG9zID0gY3VyTWFyay5maW5kKCk7XG4gICAgICAgICAgLy8gYXZvaWQgcmVjb3JkaW5nIHJlZHVuZGFudCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICBpZiAobWFya1BvcyAmJiAhY3Vyc29yRXF1YWwobWFya1Bvcywgb2xkQ3VyKSkge1xuICAgICAgICAgICAgdXNlTmV4dFNsb3Qob2xkQ3VyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXNlTmV4dFNsb3Qob2xkQ3VyKTtcbiAgICAgICAgfVxuICAgICAgICB1c2VOZXh0U2xvdChuZXdDdXIpO1xuICAgICAgICBoZWFkID0gcG9pbnRlcjtcbiAgICAgICAgdGFpbCA9IHBvaW50ZXIgLSBzaXplICsgMTtcbiAgICAgICAgaWYgKHRhaWwgPCAwKSB7XG4gICAgICAgICAgdGFpbCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1vdmUoY20sIG9mZnNldCkge1xuICAgICAgICBwb2ludGVyICs9IG9mZnNldDtcbiAgICAgICAgaWYgKHBvaW50ZXIgPiBoZWFkKSB7XG4gICAgICAgICAgcG9pbnRlciA9IGhlYWQ7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRlciA8IHRhaWwpIHtcbiAgICAgICAgICBwb2ludGVyID0gdGFpbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFyayA9IGJ1ZmZlclsoc2l6ZSArIHBvaW50ZXIpICUgc2l6ZV07XG4gICAgICAgIC8vIHNraXAgbWFya3MgdGhhdCBhcmUgdGVtcG9yYXJpbHkgcmVtb3ZlZCBmcm9tIHRleHQgYnVmZmVyXG4gICAgICAgIGlmIChtYXJrICYmICFtYXJrLmZpbmQoKSkge1xuICAgICAgICAgIHZhciBpbmMgPSBvZmZzZXQgPiAwID8gMSA6IC0xO1xuICAgICAgICAgIHZhciBuZXdDdXI7XG4gICAgICAgICAgdmFyIG9sZEN1ciA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBvaW50ZXIgKz0gaW5jO1xuICAgICAgICAgICAgbWFyayA9IGJ1ZmZlclsoc2l6ZSArIHBvaW50ZXIpICUgc2l6ZV07XG4gICAgICAgICAgICAvLyBza2lwIG1hcmtzIHRoYXQgYXJlIHRoZSBzYW1lIGFzIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChtYXJrICYmXG4gICAgICAgICAgICAgICAgKG5ld0N1ciA9IG1hcmsuZmluZCgpKSAmJlxuICAgICAgICAgICAgICAgICFjdXJzb3JFcXVhbChvbGRDdXIsIG5ld0N1cikpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAocG9pbnRlciA8IGhlYWQgJiYgcG9pbnRlciA+IHRhaWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZmluZChjbSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBvbGRQb2ludGVyID0gcG9pbnRlcjtcbiAgICAgICAgdmFyIG1hcmsgPSBtb3ZlKGNtLCBvZmZzZXQpO1xuICAgICAgICBwb2ludGVyID0gb2xkUG9pbnRlcjtcbiAgICAgICAgcmV0dXJuIG1hcmsgJiYgbWFyay5maW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWNoZWRDdXJzb3I6IHVuZGVmaW5lZCwgLy91c2VkIGZvciAjIGFuZCAqIGp1bXBzXG4gICAgICAgIGFkZDogYWRkLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBtb3ZlOiBtb3ZlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIGFuIG9iamVjdCB0byB0cmFjayB0aGUgY2hhbmdlcyBhc3NvY2lhdGVkIGluc2VydCBtb2RlLiAgSXRcbiAgICAvLyBjbG9uZXMgdGhlIG9iamVjdCB0aGF0IGlzIHBhc3NlZCBpbiwgb3IgY3JlYXRlcyBhbiBlbXB0eSBvYmplY3Qgb25lIGlmXG4gICAgLy8gbm9uZSBpcyBwcm92aWRlZC5cbiAgICB2YXIgY3JlYXRlSW5zZXJ0TW9kZUNoYW5nZXMgPSBmdW5jdGlvbihjKSB7XG4gICAgICBpZiAoYykge1xuICAgICAgICAvLyBDb3B5IGNvbnN0cnVjdGlvblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYW5nZXM6IGMuY2hhbmdlcyxcbiAgICAgICAgICBleHBlY3RDdXJzb3JBY3Rpdml0eUZvckNoYW5nZTogYy5leHBlY3RDdXJzb3JBY3Rpdml0eUZvckNoYW5nZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gQ2hhbmdlIGxpc3RcbiAgICAgICAgY2hhbmdlczogW10sXG4gICAgICAgIC8vIFNldCB0byB0cnVlIG9uIGNoYW5nZSwgZmFsc2Ugb24gY3Vyc29yQWN0aXZpdHkuXG4gICAgICAgIGV4cGVjdEN1cnNvckFjdGl2aXR5Rm9yQ2hhbmdlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gTWFjcm9Nb2RlU3RhdGUoKSB7XG4gICAgICB0aGlzLmxhdGVzdFJlZ2lzdGVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNSZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVwbGF5U2VhcmNoUXVlcmllcyA9IFtdO1xuICAgICAgdGhpcy5vblJlY29yZGluZ0RvbmUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcyA9IGNyZWF0ZUluc2VydE1vZGVDaGFuZ2VzKCk7XG4gICAgfVxuICAgIE1hY3JvTW9kZVN0YXRlLnByb3RvdHlwZSA9IHtcbiAgICAgIGV4aXRNYWNyb1JlY29yZE1vZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgICAgaWYgKG1hY3JvTW9kZVN0YXRlLm9uUmVjb3JkaW5nRG9uZSkge1xuICAgICAgICAgIG1hY3JvTW9kZVN0YXRlLm9uUmVjb3JkaW5nRG9uZSgpOyAvLyBjbG9zZSBkaWFsb2dcbiAgICAgICAgfVxuICAgICAgICBtYWNyb01vZGVTdGF0ZS5vblJlY29yZGluZ0RvbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIG1hY3JvTW9kZVN0YXRlLmlzUmVjb3JkaW5nID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgZW50ZXJNYWNyb1JlY29yZE1vZGU6IGZ1bmN0aW9uKGNtLCByZWdpc3Rlck5hbWUpIHtcbiAgICAgICAgdmFyIHJlZ2lzdGVyID1cbiAgICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5nZXRSZWdpc3RlcihyZWdpc3Rlck5hbWUpO1xuICAgICAgICBpZiAocmVnaXN0ZXIpIHtcbiAgICAgICAgICByZWdpc3Rlci5jbGVhcigpO1xuICAgICAgICAgIHRoaXMubGF0ZXN0UmVnaXN0ZXIgPSByZWdpc3Rlck5hbWU7XG4gICAgICAgICAgaWYgKGNtLm9wZW5EaWFsb2cpIHtcbiAgICAgICAgICAgIHRoaXMub25SZWNvcmRpbmdEb25lID0gY20ub3BlbkRpYWxvZyhcbiAgICAgICAgICAgICAgICAnKHJlY29yZGluZylbJytyZWdpc3Rlck5hbWUrJ10nLCBudWxsLCB7Ym90dG9tOnRydWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pc1JlY29yZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF5YmVJbml0VmltU3RhdGUoY20pIHtcbiAgICAgIGlmICghY20uc3RhdGUudmltKSB7XG4gICAgICAgIC8vIFN0b3JlIGluc3RhbmNlIHN0YXRlIGluIHRoZSBDb2RlTWlycm9yIG9iamVjdC5cbiAgICAgICAgY20uc3RhdGUudmltID0ge1xuICAgICAgICAgIGlucHV0U3RhdGU6IG5ldyBJbnB1dFN0YXRlKCksXG4gICAgICAgICAgLy8gVmltJ3MgaW5wdXQgc3RhdGUgdGhhdCB0cmlnZ2VyZWQgdGhlIGxhc3QgZWRpdCwgdXNlZCB0byByZXBlYXRcbiAgICAgICAgICAvLyBtb3Rpb25zIGFuZCBvcGVyYXRvcnMgd2l0aCAnLicuXG4gICAgICAgICAgbGFzdEVkaXRJbnB1dFN0YXRlOiB1bmRlZmluZWQsXG4gICAgICAgICAgLy8gVmltJ3MgYWN0aW9uIGNvbW1hbmQgYmVmb3JlIHRoZSBsYXN0IGVkaXQsIHVzZWQgdG8gcmVwZWF0IGFjdGlvbnNcbiAgICAgICAgICAvLyB3aXRoICcuJyBhbmQgaW5zZXJ0IG1vZGUgcmVwZWF0LlxuICAgICAgICAgIGxhc3RFZGl0QWN0aW9uQ29tbWFuZDogdW5kZWZpbmVkLFxuICAgICAgICAgIC8vIFdoZW4gdXNpbmcgamsgZm9yIG5hdmlnYXRpb24sIGlmIHlvdSBtb3ZlIGZyb20gYSBsb25nZXIgbGluZSB0byBhXG4gICAgICAgICAgLy8gc2hvcnRlciBsaW5lLCB0aGUgY3Vyc29yIG1heSBjbGlwIHRvIHRoZSBlbmQgb2YgdGhlIHNob3J0ZXIgbGluZS5cbiAgICAgICAgICAvLyBJZiBqIGlzIHByZXNzZWQgYWdhaW4gYW5kIGN1cnNvciBnb2VzIHRvIHRoZSBuZXh0IGxpbmUsIHRoZVxuICAgICAgICAgIC8vIGN1cnNvciBzaG91bGQgZ28gYmFjayB0byBpdHMgaG9yaXpvbnRhbCBwb3NpdGlvbiBvbiB0aGUgbG9uZ2VyXG4gICAgICAgICAgLy8gbGluZSBpZiBpdCBjYW4uIFRoaXMgaXMgdG8ga2VlcCB0cmFjayBvZiB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbi5cbiAgICAgICAgICBsYXN0SFBvczogLTEsXG4gICAgICAgICAgLy8gRG9pbmcgdGhlIHNhbWUgd2l0aCBzY3JlZW4tcG9zaXRpb24gZm9yIGdqL2drXG4gICAgICAgICAgbGFzdEhTUG9zOiAtMSxcbiAgICAgICAgICAvLyBUaGUgbGFzdCBtb3Rpb24gY29tbWFuZCBydW4uIENsZWFyZWQgaWYgYSBub24tbW90aW9uIGNvbW1hbmQgZ2V0c1xuICAgICAgICAgIC8vIGV4ZWN1dGVkIGluIGJldHdlZW4uXG4gICAgICAgICAgbGFzdE1vdGlvbjogbnVsbCxcbiAgICAgICAgICBtYXJrczoge30sXG4gICAgICAgICAgLy8gTWFyayBmb3IgcmVuZGVyaW5nIGZha2UgY3Vyc29yIGZvciB2aXN1YWwgbW9kZS5cbiAgICAgICAgICBmYWtlQ3Vyc29yOiBudWxsLFxuICAgICAgICAgIGluc2VydE1vZGU6IGZhbHNlLFxuICAgICAgICAgIC8vIFJlcGVhdCBjb3VudCBmb3IgY2hhbmdlcyBtYWRlIGluIGluc2VydCBtb2RlLCB0cmlnZ2VyZWQgYnkga2V5XG4gICAgICAgICAgLy8gc2VxdWVuY2VzIGxpa2UgMyxpLiBPbmx5IGV4aXN0cyB3aGVuIGluc2VydE1vZGUgaXMgdHJ1ZS5cbiAgICAgICAgICBpbnNlcnRNb2RlUmVwZWF0OiB1bmRlZmluZWQsXG4gICAgICAgICAgdmlzdWFsTW9kZTogZmFsc2UsXG4gICAgICAgICAgLy8gSWYgd2UgYXJlIGluIHZpc3VhbCBsaW5lIG1vZGUuIE5vIGVmZmVjdCBpZiB2aXN1YWxNb2RlIGlzIGZhbHNlLlxuICAgICAgICAgIHZpc3VhbExpbmU6IGZhbHNlLFxuICAgICAgICAgIHZpc3VhbEJsb2NrOiBmYWxzZSxcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgIGxhc3RQYXN0ZWRUZXh0OiBudWxsLFxuICAgICAgICAgIHNlbDoge30sXG4gICAgICAgICAgLy8gQnVmZmVyLWxvY2FsL3dpbmRvdy1sb2NhbCB2YWx1ZXMgb2YgdmltIG9wdGlvbnMuXG4gICAgICAgICAgb3B0aW9uczoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbS5zdGF0ZS52aW07XG4gICAgfVxuICAgIHZhciB2aW1HbG9iYWxTdGF0ZTtcbiAgICBmdW5jdGlvbiByZXNldFZpbUdsb2JhbFN0YXRlKCkge1xuICAgICAgdmltR2xvYmFsU3RhdGUgPSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeS5cbiAgICAgICAgc2VhcmNoUXVlcnk6IG51bGwsXG4gICAgICAgIC8vIFdoZXRoZXIgd2UgYXJlIHNlYXJjaGluZyBiYWNrd2FyZHMuXG4gICAgICAgIHNlYXJjaElzUmV2ZXJzZWQ6IGZhbHNlLFxuICAgICAgICAvLyBSZXBsYWNlIHBhcnQgb2YgdGhlIGxhc3Qgc3Vic3RpdHV0ZWQgcGF0dGVyblxuICAgICAgICBsYXN0U3Vic3RpdHV0ZVJlcGxhY2VQYXJ0OiB1bmRlZmluZWQsXG4gICAgICAgIGp1bXBMaXN0OiBjcmVhdGVDaXJjdWxhckp1bXBMaXN0KCksXG4gICAgICAgIG1hY3JvTW9kZVN0YXRlOiBuZXcgTWFjcm9Nb2RlU3RhdGUsXG4gICAgICAgIC8vIFJlY29yZGluZyBsYXRlc3QgZiwgdCwgRiBvciBUIG1vdGlvbiBjb21tYW5kLlxuICAgICAgICBsYXN0Q2hhcmFjdGVyU2VhcmNoOiB7aW5jcmVtZW50OjAsIGZvcndhcmQ6dHJ1ZSwgc2VsZWN0ZWRDaGFyYWN0ZXI6Jyd9LFxuICAgICAgICByZWdpc3RlckNvbnRyb2xsZXI6IG5ldyBSZWdpc3RlckNvbnRyb2xsZXIoe30pLFxuICAgICAgICAvLyBzZWFyY2ggaGlzdG9yeSBidWZmZXJcbiAgICAgICAgc2VhcmNoSGlzdG9yeUNvbnRyb2xsZXI6IG5ldyBIaXN0b3J5Q29udHJvbGxlcigpLFxuICAgICAgICAvLyBleCBDb21tYW5kIGhpc3RvcnkgYnVmZmVyXG4gICAgICAgIGV4Q29tbWFuZEhpc3RvcnlDb250cm9sbGVyIDogbmV3IEhpc3RvcnlDb250cm9sbGVyKClcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBvcHRpb25OYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICAgIG9wdGlvbi52YWx1ZSA9IG9wdGlvbi5kZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhc3RJbnNlcnRNb2RlS2V5VGltZXI7XG4gICAgdmFyIHZpbUFwaT0ge1xuICAgICAgYnVpbGRLZXlNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUT0RPOiBDb252ZXJ0IGtleW1hcCBpbnRvIGRpY3Rpb25hcnkgZm9ybWF0IGZvciBmYXN0IGxvb2t1cC5cbiAgICAgIH0sXG4gICAgICAvLyBUZXN0aW5nIGhvb2ssIHRob3VnaCBpdCBtaWdodCBiZSB1c2VmdWwgdG8gZXhwb3NlIHRoZSByZWdpc3RlclxuICAgICAgLy8gY29udHJvbGxlciBhbnl3YXkuXG4gICAgICBnZXRSZWdpc3RlckNvbnRyb2xsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyO1xuICAgICAgfSxcbiAgICAgIC8vIFRlc3RpbmcgaG9vay5cbiAgICAgIHJlc2V0VmltR2xvYmFsU3RhdGVfOiByZXNldFZpbUdsb2JhbFN0YXRlLFxuXG4gICAgICAvLyBUZXN0aW5nIGhvb2suXG4gICAgICBnZXRWaW1HbG9iYWxTdGF0ZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmltR2xvYmFsU3RhdGU7XG4gICAgICB9LFxuXG4gICAgICAvLyBUZXN0aW5nIGhvb2suXG4gICAgICBtYXliZUluaXRWaW1TdGF0ZV86IG1heWJlSW5pdFZpbVN0YXRlLFxuXG4gICAgICBzdXBwcmVzc0Vycm9yTG9nZ2luZzogZmFsc2UsXG5cbiAgICAgIEluc2VydE1vZGVLZXk6IEluc2VydE1vZGVLZXksXG4gICAgICBtYXA6IGZ1bmN0aW9uKGxocywgcmhzLCBjdHgpIHtcbiAgICAgICAgLy8gQWRkIHVzZXIgZGVmaW5lZCBrZXkgYmluZGluZ3MuXG4gICAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIubWFwKGxocywgcmhzLCBjdHgpO1xuICAgICAgfSxcbiAgICAgIHVubWFwOiBmdW5jdGlvbihsaHMsIGN0eCkge1xuICAgICAgICBleENvbW1hbmREaXNwYXRjaGVyLnVubWFwKGxocywgY3R4KTtcbiAgICAgIH0sXG4gICAgICAvLyBOb24tcmVjdXJzaXZlIG1hcCBmdW5jdGlvbi5cbiAgICAgIC8vIE5PVEU6IFRoaXMgd2lsbCBub3QgY3JlYXRlIG1hcHBpbmdzIHRvIGtleSBtYXBzIHRoYXQgYXJlbid0IHByZXNlbnRcbiAgICAgIC8vIGluIHRoZSBkZWZhdWx0IGtleSBtYXAuIFNlZSBUT0RPIGF0IGJvdHRvbSBvZiBmdW5jdGlvbi5cbiAgICAgIG5vcmVtYXA6IGZ1bmN0aW9uKGxocywgcmhzLCBjdHgpIHtcbiAgICAgICAgZnVuY3Rpb24gdG9DdHhBcnJheShjdHgpIHtcbiAgICAgICAgICByZXR1cm4gY3R4ID8gW2N0eF0gOiBbJ25vcm1hbCcsICdpbnNlcnQnLCAndmlzdWFsJ107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0eHNUb01hcCA9IHRvQ3R4QXJyYXkoY3R4KTtcbiAgICAgICAgLy8gTG9vayB0aHJvdWdoIGFsbCBhY3R1YWwgZGVmYXVsdHMgdG8gZmluZCBhIG1hcCBjYW5kaWRhdGUuXG4gICAgICAgIHZhciBhY3R1YWxMZW5ndGggPSBkZWZhdWx0S2V5bWFwLmxlbmd0aCwgb3JpZ0xlbmd0aCA9IGRlZmF1bHRLZXltYXBMZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSBhY3R1YWxMZW5ndGggLSBvcmlnTGVuZ3RoO1xuICAgICAgICAgICAgIGkgPCBhY3R1YWxMZW5ndGggJiYgY3R4c1RvTWFwLmxlbmd0aDtcbiAgICAgICAgICAgICBpKyspIHtcbiAgICAgICAgICB2YXIgbWFwcGluZyA9IGRlZmF1bHRLZXltYXBbaV07XG4gICAgICAgICAgLy8gT21pdCBtYXBwaW5ncyB0aGF0IG9wZXJhdGUgaW4gdGhlIHdyb25nIGNvbnRleHQocykgYW5kIHRob3NlIG9mIGludmFsaWQgdHlwZS5cbiAgICAgICAgICBpZiAobWFwcGluZy5rZXlzID09IHJocyAmJlxuICAgICAgICAgICAgICAoIWN0eCB8fCAhbWFwcGluZy5jb250ZXh0IHx8IG1hcHBpbmcuY29udGV4dCA9PT0gY3R4KSAmJlxuICAgICAgICAgICAgICBtYXBwaW5nLnR5cGUuc3Vic3RyKDAsIDIpICE9PSAnZXgnICYmXG4gICAgICAgICAgICAgIG1hcHBpbmcudHlwZS5zdWJzdHIoMCwgMykgIT09ICdrZXknKSB7XG4gICAgICAgICAgICAvLyBNYWtlIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBvcmlnaW5hbCBrZXltYXAgZW50cnkuXG4gICAgICAgICAgICB2YXIgbmV3TWFwcGluZyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgbmV3TWFwcGluZ1trZXldID0gbWFwcGluZ1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTW9kaWZ5IGl0IHBvaW50IHRvIHRoZSBuZXcgbWFwcGluZyB3aXRoIHRoZSBwcm9wZXIgY29udGV4dC5cbiAgICAgICAgICAgIG5ld01hcHBpbmcua2V5cyA9IGxocztcbiAgICAgICAgICAgIGlmIChjdHggJiYgIW5ld01hcHBpbmcuY29udGV4dCkge1xuICAgICAgICAgICAgICBuZXdNYXBwaW5nLmNvbnRleHQgPSBjdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGtleW1hcCB3aXRoIGEgaGlnaGVyIHByaW9yaXR5IHRoYW4gdGhlIG9yaWdpbmFsLlxuICAgICAgICAgICAgdGhpcy5fbWFwQ29tbWFuZChuZXdNYXBwaW5nKTtcbiAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgbWFwcGVkIGNvbnRleHRzIGFzIGNvbXBsZXRlLlxuICAgICAgICAgICAgdmFyIG1hcHBlZEN0eHMgPSB0b0N0eEFycmF5KG1hcHBpbmcuY29udGV4dCk7XG4gICAgICAgICAgICBjdHhzVG9NYXAgPSBjdHhzVG9NYXAuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBtYXBwZWRDdHhzLmluZGV4T2YoZWwpID09PSAtMTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IENyZWF0ZSBub24tcmVjdXJzaXZlIGtleVRvS2V5IG1hcHBpbmdzIGZvciB0aGUgdW5tYXBwZWQgY29udGV4dHMgb25jZSB0aG9zZSBleGlzdC5cbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgYWxsIHVzZXItZGVmaW5lZCBtYXBwaW5ncyBmb3IgdGhlIHByb3ZpZGVkIGNvbnRleHQuXG4gICAgICBtYXBjbGVhcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIC8vIFBhcnRpdGlvbiB0aGUgZXhpc3Rpbmcga2V5bWFwIGludG8gdXNlci1kZWZpbmVkIGFuZCB0cnVlIGRlZmF1bHRzLlxuICAgICAgICB2YXIgYWN0dWFsTGVuZ3RoID0gZGVmYXVsdEtleW1hcC5sZW5ndGgsXG4gICAgICAgICAgICBvcmlnTGVuZ3RoID0gZGVmYXVsdEtleW1hcExlbmd0aDtcbiAgICAgICAgdmFyIHVzZXJLZXltYXAgPSBkZWZhdWx0S2V5bWFwLnNsaWNlKDAsIGFjdHVhbExlbmd0aCAtIG9yaWdMZW5ndGgpO1xuICAgICAgICBkZWZhdWx0S2V5bWFwID0gZGVmYXVsdEtleW1hcC5zbGljZShhY3R1YWxMZW5ndGggLSBvcmlnTGVuZ3RoKTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgIC8vIElmIGEgc3BlY2lmaWMgY29udGV4dCBpcyBiZWluZyBjbGVhcmVkLCB3ZSBuZWVkIHRvIGtlZXAgbWFwcGluZ3NcbiAgICAgICAgICAvLyBmcm9tIGFsbCBvdGhlciBjb250ZXh0cy5cbiAgICAgICAgICBmb3IgKHZhciBpID0gdXNlcktleW1hcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIG1hcHBpbmcgPSB1c2VyS2V5bWFwW2ldO1xuICAgICAgICAgICAgaWYgKGN0eCAhPT0gbWFwcGluZy5jb250ZXh0KSB7XG4gICAgICAgICAgICAgIGlmIChtYXBwaW5nLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBDb21tYW5kKG1hcHBpbmcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGBtYXBwaW5nYCBhcHBsaWVzIHRvIGFsbCBjb250ZXh0cyBzbyBjcmVhdGUga2V5bWFwIGNvcGllc1xuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIGNvbnRleHQgZXhjZXB0IHRoZSBvbmUgYmVpbmcgY2xlYXJlZC5cbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dHMgPSBbJ25vcm1hbCcsICdpbnNlcnQnLCAndmlzdWFsJ107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBjb250ZXh0cykge1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHRzW2pdICE9PSBjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld01hcHBpbmcgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXdNYXBwaW5nW2tleV0gPSBtYXBwaW5nW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3TWFwcGluZy5jb250ZXh0ID0gY29udGV4dHNbal07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcENvbW1hbmQobmV3TWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVE9ETzogRXhwb3NlIHNldE9wdGlvbiBhbmQgZ2V0T3B0aW9uIGFzIGluc3RhbmNlIG1ldGhvZHMuIE5lZWQgdG8gZGVjaWRlIGhvdyB0byBuYW1lc3BhY2VcbiAgICAgIC8vIHRoZW0sIG9yIHNvbWVob3cgbWFrZSB0aGVtIHdvcmsgd2l0aCB0aGUgZXhpc3RpbmcgQ29kZU1pcnJvciBzZXRPcHRpb24vZ2V0T3B0aW9uIEFQSS5cbiAgICAgIHNldE9wdGlvbjogc2V0T3B0aW9uLFxuICAgICAgZ2V0T3B0aW9uOiBnZXRPcHRpb24sXG4gICAgICBkZWZpbmVPcHRpb246IGRlZmluZU9wdGlvbixcbiAgICAgIGRlZmluZUV4OiBmdW5jdGlvbihuYW1lLCBwcmVmaXgsIGZ1bmMpe1xuICAgICAgICBpZiAoIXByZWZpeCkge1xuICAgICAgICAgIHByZWZpeCA9IG5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyhWaW0uZGVmaW5lRXgpIFwiJytwcmVmaXgrJ1wiIGlzIG5vdCBhIHByZWZpeCBvZiBcIicrbmFtZSsnXCIsIGNvbW1hbmQgbm90IHJlZ2lzdGVyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBleENvbW1hbmRzW25hbWVdPWZ1bmM7XG4gICAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIuY29tbWFuZE1hcF9bcHJlZml4XT17bmFtZTpuYW1lLCBzaG9ydE5hbWU6cHJlZml4LCB0eXBlOidhcGknfTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVLZXk6IGZ1bmN0aW9uIChjbSwga2V5LCBvcmlnaW4pIHtcbiAgICAgICAgdmFyIGNvbW1hbmQgPSB0aGlzLmZpbmRLZXkoY20sIGtleSwgb3JpZ2luKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBpcyB0aGUgb3V0ZXJtb3N0IGZ1bmN0aW9uIGNhbGxlZCBieSBDb2RlTWlycm9yLCBhZnRlciBrZXlzIGhhdmVcbiAgICAgICAqIGJlZW4gbWFwcGVkIHRvIHRoZWlyIFZpbSBlcXVpdmFsZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBGaW5kcyBhIGNvbW1hbmQgYmFzZWQgb24gdGhlIGtleSAoYW5kIGNhY2hlZCBrZXlzIGlmIHRoZXJlIGlzIGFcbiAgICAgICAqIG11bHRpLWtleSBzZXF1ZW5jZSkuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgbm8ga2V5IGlzIG1hdGNoZWQsIGEgbm9vcFxuICAgICAgICogZnVuY3Rpb24gaWYgYSBwYXJ0aWFsIG1hdGNoIGlzIGZvdW5kIChtdWx0aS1rZXkpLCBhbmQgYSBmdW5jdGlvbiB0b1xuICAgICAgICogZXhlY3V0ZSB0aGUgYm91bmQgY29tbWFuZCBpZiBhIGEga2V5IGlzIG1hdGNoZWQuIFRoZSBmdW5jdGlvbiBhbHdheXNcbiAgICAgICAqIHJldHVybnMgdHJ1ZS5cbiAgICAgICAqL1xuICAgICAgZmluZEtleTogZnVuY3Rpb24oY20sIGtleSwgb3JpZ2luKSB7XG4gICAgICAgIHZhciB2aW0gPSBtYXliZUluaXRWaW1TdGF0ZShjbSk7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1hY3JvUmVjb3JkaW5nKCkge1xuICAgICAgICAgIHZhciBtYWNyb01vZGVTdGF0ZSA9IHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlO1xuICAgICAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1JlY29yZGluZykge1xuICAgICAgICAgICAgaWYgKGtleSA9PSAncScpIHtcbiAgICAgICAgICAgICAgbWFjcm9Nb2RlU3RhdGUuZXhpdE1hY3JvUmVjb3JkTW9kZSgpO1xuICAgICAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcmlnaW4gIT0gJ21hcHBpbmcnKSB7XG4gICAgICAgICAgICAgIGxvZ0tleShtYWNyb01vZGVTdGF0ZSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRXNjKCkge1xuICAgICAgICAgIGlmIChrZXkgPT0gJzxFc2M+Jykge1xuICAgICAgICAgICAgLy8gQ2xlYXIgaW5wdXQgc3RhdGUgYW5kIGdldCBiYWNrIHRvIG5vcm1hbCBtb2RlLlxuICAgICAgICAgICAgY2xlYXJJbnB1dFN0YXRlKGNtKTtcbiAgICAgICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgICAgICBleGl0VmlzdWFsTW9kZShjbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZpbS5pbnNlcnRNb2RlKSB7XG4gICAgICAgICAgICAgIGV4aXRJbnNlcnRNb2RlKGNtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkb0tleVRvS2V5KGtleXMpIHtcbiAgICAgICAgICAvLyBUT0RPOiBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgd2hpbGUgKGtleXMpIHtcbiAgICAgICAgICAgIC8vIFB1bGwgb2ZmIG9uZSBjb21tYW5kIGtleSwgd2hpY2ggaXMgZWl0aGVyIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgICAgLy8gb3IgYSBzcGVjaWFsIHNlcXVlbmNlIHdyYXBwZWQgaW4gJzwnIGFuZCAnPicsIGUuZy4gJzxTcGFjZT4nLlxuICAgICAgICAgICAgbWF0Y2ggPSAoLzxcXHcrLS4rPz58PFxcdys+fC4vKS5leGVjKGtleXMpO1xuICAgICAgICAgICAga2V5ID0gbWF0Y2hbMF07XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5zdWJzdHJpbmcobWF0Y2guaW5kZXggKyBrZXkubGVuZ3RoKTtcbiAgICAgICAgICAgIENvZGVNaXJyb3IuVmltLmhhbmRsZUtleShjbSwga2V5LCAnbWFwcGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUtleUluc2VydE1vZGUoKSB7XG4gICAgICAgICAgaWYgKGhhbmRsZUVzYygpKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgdmFyIGtleXMgPSB2aW0uaW5wdXRTdGF0ZS5rZXlCdWZmZXIgPSB2aW0uaW5wdXRTdGF0ZS5rZXlCdWZmZXIgKyBrZXk7XG4gICAgICAgICAgdmFyIGtleXNBcmVDaGFycyA9IGtleS5sZW5ndGggPT0gMTtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBjb21tYW5kRGlzcGF0Y2hlci5tYXRjaENvbW1hbmQoa2V5cywgZGVmYXVsdEtleW1hcCwgdmltLmlucHV0U3RhdGUsICdpbnNlcnQnKTtcbiAgICAgICAgICAvLyBOZWVkIHRvIGNoZWNrIGFsbCBrZXkgc3Vic3RyaW5ncyBpbiBpbnNlcnQgbW9kZS5cbiAgICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiAxICYmIG1hdGNoLnR5cGUgIT0gJ2Z1bGwnKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IHZpbS5pbnB1dFN0YXRlLmtleUJ1ZmZlciA9IGtleXMuc2xpY2UoMSk7XG4gICAgICAgICAgICB2YXIgdGhpc01hdGNoID0gY29tbWFuZERpc3BhdGNoZXIubWF0Y2hDb21tYW5kKGtleXMsIGRlZmF1bHRLZXltYXAsIHZpbS5pbnB1dFN0YXRlLCAnaW5zZXJ0Jyk7XG4gICAgICAgICAgICBpZiAodGhpc01hdGNoLnR5cGUgIT0gJ25vbmUnKSB7IG1hdGNoID0gdGhpc01hdGNoOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXRjaC50eXBlID09ICdub25lJykgeyBjbGVhcklucHV0U3RhdGUoY20pOyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICBlbHNlIGlmIChtYXRjaC50eXBlID09ICdwYXJ0aWFsJykge1xuICAgICAgICAgICAgaWYgKGxhc3RJbnNlcnRNb2RlS2V5VGltZXIpIHsgd2luZG93LmNsZWFyVGltZW91dChsYXN0SW5zZXJ0TW9kZUtleVRpbWVyKTsgfVxuICAgICAgICAgICAgbGFzdEluc2VydE1vZGVLZXlUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgaWYgKHZpbS5pbnNlcnRNb2RlICYmIHZpbS5pbnB1dFN0YXRlLmtleUJ1ZmZlcikgeyBjbGVhcklucHV0U3RhdGUoY20pOyB9IH0sXG4gICAgICAgICAgICAgIGdldE9wdGlvbignaW5zZXJ0TW9kZUVzY0tleXNUaW1lb3V0JykpO1xuICAgICAgICAgICAgcmV0dXJuICFrZXlzQXJlQ2hhcnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxhc3RJbnNlcnRNb2RlS2V5VGltZXIpIHsgd2luZG93LmNsZWFyVGltZW91dChsYXN0SW5zZXJ0TW9kZUtleVRpbWVyKTsgfVxuICAgICAgICAgIGlmIChrZXlzQXJlQ2hhcnMpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25zID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaGVyZSA9IHNlbGVjdGlvbnNbaV0uaGVhZDtcbiAgICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKCcnLCBvZmZzZXRDdXJzb3IoaGVyZSwgMCwgLShrZXlzLmxlbmd0aCAtIDEpKSwgaGVyZSwgJytpbnB1dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLmNoYW5nZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsZWFySW5wdXRTdGF0ZShjbSk7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLmNvbW1hbmQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVLZXlOb25JbnNlcnRNb2RlKCkge1xuICAgICAgICAgIGlmIChoYW5kbGVNYWNyb1JlY29yZGluZygpIHx8IGhhbmRsZUVzYygpKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgICB2YXIga2V5cyA9IHZpbS5pbnB1dFN0YXRlLmtleUJ1ZmZlciA9IHZpbS5pbnB1dFN0YXRlLmtleUJ1ZmZlciArIGtleTtcbiAgICAgICAgICBpZiAoL15bMS05XVxcZCokLy50ZXN0KGtleXMpKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgICB2YXIga2V5c01hdGNoZXIgPSAvXihcXGQqKSguKikkLy5leGVjKGtleXMpO1xuICAgICAgICAgIGlmICgha2V5c01hdGNoZXIpIHsgY2xlYXJJbnB1dFN0YXRlKGNtKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSB2aW0udmlzdWFsTW9kZSA/ICd2aXN1YWwnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25vcm1hbCc7XG4gICAgICAgICAgdmFyIG1hdGNoID0gY29tbWFuZERpc3BhdGNoZXIubWF0Y2hDb21tYW5kKGtleXNNYXRjaGVyWzJdIHx8IGtleXNNYXRjaGVyWzFdLCBkZWZhdWx0S2V5bWFwLCB2aW0uaW5wdXRTdGF0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKG1hdGNoLnR5cGUgPT0gJ25vbmUnKSB7IGNsZWFySW5wdXRTdGF0ZShjbSk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgIGVsc2UgaWYgKG1hdGNoLnR5cGUgPT0gJ3BhcnRpYWwnKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgICB2aW0uaW5wdXRTdGF0ZS5rZXlCdWZmZXIgPSAnJztcbiAgICAgICAgICB2YXIga2V5c01hdGNoZXIgPSAvXihcXGQqKSguKikkLy5leGVjKGtleXMpO1xuICAgICAgICAgIGlmIChrZXlzTWF0Y2hlclsxXSAmJiBrZXlzTWF0Y2hlclsxXSAhPSAnMCcpIHtcbiAgICAgICAgICAgIHZpbS5pbnB1dFN0YXRlLnB1c2hSZXBlYXREaWdpdChrZXlzTWF0Y2hlclsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXRjaC5jb21tYW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbW1hbmQ7XG4gICAgICAgIGlmICh2aW0uaW5zZXJ0TW9kZSkgeyBjb21tYW5kID0gaGFuZGxlS2V5SW5zZXJ0TW9kZSgpOyB9XG4gICAgICAgIGVsc2UgeyBjb21tYW5kID0gaGFuZGxlS2V5Tm9uSW5zZXJ0TW9kZSgpOyB9XG4gICAgICAgIGlmIChjb21tYW5kID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiAhdmltLmluc2VydE1vZGUgJiYga2V5Lmxlbmd0aCA9PT0gMSA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gVE9ETzogTG9vayBpbnRvIHVzaW5nIENvZGVNaXJyb3IncyBtdWx0aS1rZXkgaGFuZGxpbmcuXG4gICAgICAgICAgLy8gUmV0dXJuIG5vLW9wIHNpbmNlIHdlIGFyZSBjYWNoaW5nIHRoZSBrZXkuIENvdW50cyBhcyBoYW5kbGVkLCBidXRcbiAgICAgICAgICAvLyBkb24ndCB3YW50IGFjdCBvbiBpdCBqdXN0IHlldC5cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNtLmN1ck9wLmlzVmltT3AgPSB0cnVlO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kLnR5cGUgPT0gJ2tleVRvS2V5Jykge1xuICAgICAgICAgICAgICAgICAgZG9LZXlUb0tleShjb21tYW5kLnRvS2V5cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbW1hbmREaXNwYXRjaGVyLnByb2Nlc3NDb21tYW5kKGNtLCB2aW0sIGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIFZJTSBzdGF0ZSBpbiBjYXNlIGl0J3MgaW4gYSBiYWQgc3RhdGUuXG4gICAgICAgICAgICAgICAgY20uc3RhdGUudmltID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG1heWJlSW5pdFZpbVN0YXRlKGNtKTtcbiAgICAgICAgICAgICAgICBpZiAoIUNvZGVNaXJyb3IuVmltLnN1cHByZXNzRXJyb3JMb2dnaW5nKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlWydsb2cnXShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYW5kbGVFeDogZnVuY3Rpb24oY20sIGlucHV0KSB7XG4gICAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIucHJvY2Vzc0NvbW1hbmQoY20sIGlucHV0KTtcbiAgICAgIH0sXG5cbiAgICAgIGRlZmluZU1vdGlvbjogZGVmaW5lTW90aW9uLFxuICAgICAgZGVmaW5lQWN0aW9uOiBkZWZpbmVBY3Rpb24sXG4gICAgICBkZWZpbmVPcGVyYXRvcjogZGVmaW5lT3BlcmF0b3IsXG4gICAgICBtYXBDb21tYW5kOiBtYXBDb21tYW5kLFxuICAgICAgX21hcENvbW1hbmQ6IF9tYXBDb21tYW5kLFxuXG4gICAgICBkZWZpbmVSZWdpc3RlcjogZGVmaW5lUmVnaXN0ZXIsXG5cbiAgICAgIGV4aXRWaXN1YWxNb2RlOiBleGl0VmlzdWFsTW9kZSxcbiAgICAgIGV4aXRJbnNlcnRNb2RlOiBleGl0SW5zZXJ0TW9kZVxuICAgIH07XG5cbiAgICAvLyBSZXByZXNlbnRzIHRoZSBjdXJyZW50IGlucHV0IHN0YXRlLlxuICAgIGZ1bmN0aW9uIElucHV0U3RhdGUoKSB7XG4gICAgICB0aGlzLnByZWZpeFJlcGVhdCA9IFtdO1xuICAgICAgdGhpcy5tb3Rpb25SZXBlYXQgPSBbXTtcblxuICAgICAgdGhpcy5vcGVyYXRvciA9IG51bGw7XG4gICAgICB0aGlzLm9wZXJhdG9yQXJncyA9IG51bGw7XG4gICAgICB0aGlzLm1vdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLm1vdGlvbkFyZ3MgPSBudWxsO1xuICAgICAgdGhpcy5rZXlCdWZmZXIgPSBbXTsgLy8gRm9yIG1hdGNoaW5nIG11bHRpLWtleSBjb21tYW5kcy5cbiAgICAgIHRoaXMucmVnaXN0ZXJOYW1lID0gbnVsbDsgLy8gRGVmYXVsdHMgdG8gdGhlIHVubmFtZWQgcmVnaXN0ZXIuXG4gICAgfVxuICAgIElucHV0U3RhdGUucHJvdG90eXBlLnB1c2hSZXBlYXREaWdpdCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGlmICghdGhpcy5vcGVyYXRvcikge1xuICAgICAgICB0aGlzLnByZWZpeFJlcGVhdCA9IHRoaXMucHJlZml4UmVwZWF0LmNvbmNhdChuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW90aW9uUmVwZWF0ID0gdGhpcy5tb3Rpb25SZXBlYXQuY29uY2F0KG4pO1xuICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRTdGF0ZS5wcm90b3R5cGUuZ2V0UmVwZWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVwZWF0ID0gMDtcbiAgICAgIGlmICh0aGlzLnByZWZpeFJlcGVhdC5sZW5ndGggPiAwIHx8IHRoaXMubW90aW9uUmVwZWF0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVwZWF0ID0gMTtcbiAgICAgICAgaWYgKHRoaXMucHJlZml4UmVwZWF0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXBlYXQgKj0gcGFyc2VJbnQodGhpcy5wcmVmaXhSZXBlYXQuam9pbignJyksIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb3Rpb25SZXBlYXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlcGVhdCAqPSBwYXJzZUludCh0aGlzLm1vdGlvblJlcGVhdC5qb2luKCcnKSwgMTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwZWF0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbGVhcklucHV0U3RhdGUoY20sIHJlYXNvbikge1xuICAgICAgY20uc3RhdGUudmltLmlucHV0U3RhdGUgPSBuZXcgSW5wdXRTdGF0ZSgpO1xuICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sICd2aW0tY29tbWFuZC1kb25lJywgcmVhc29uKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIFJlZ2lzdGVyIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBjb3B5IGFuZCBwYXN0ZSByZWdpc3RlcnMuICBCZXNpZGVzXG4gICAgICogdGV4dCwgYSByZWdpc3RlciBtdXN0IHN0b3JlIHdoZXRoZXIgaXQgaXMgbGluZXdpc2UgKGkuZS4sIHdoZW4gaXQgaXNcbiAgICAgKiBwYXN0ZWQsIHNob3VsZCBpdCBpbnNlcnQgaXRzZWxmIGludG8gYSBuZXcgbGluZSwgb3Igc2hvdWxkIHRoZSB0ZXh0IGJlXG4gICAgICogaW5zZXJ0ZWQgYXQgdGhlIGN1cnNvciBwb3NpdGlvbi4pXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVnaXN0ZXIodGV4dCwgbGluZXdpc2UsIGJsb2Nrd2lzZSkge1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgdGhpcy5rZXlCdWZmZXIgPSBbdGV4dCB8fCAnJ107XG4gICAgICB0aGlzLmluc2VydE1vZGVDaGFuZ2VzID0gW107XG4gICAgICB0aGlzLnNlYXJjaFF1ZXJpZXMgPSBbXTtcbiAgICAgIHRoaXMubGluZXdpc2UgPSAhIWxpbmV3aXNlO1xuICAgICAgdGhpcy5ibG9ja3dpc2UgPSAhIWJsb2Nrd2lzZTtcbiAgICB9XG4gICAgUmVnaXN0ZXIucHJvdG90eXBlID0ge1xuICAgICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCwgbGluZXdpc2UsIGJsb2Nrd2lzZSkge1xuICAgICAgICB0aGlzLmtleUJ1ZmZlciA9IFt0ZXh0IHx8ICcnXTtcbiAgICAgICAgdGhpcy5saW5ld2lzZSA9ICEhbGluZXdpc2U7XG4gICAgICAgIHRoaXMuYmxvY2t3aXNlID0gISFibG9ja3dpc2U7XG4gICAgICB9LFxuICAgICAgcHVzaFRleHQ6IGZ1bmN0aW9uKHRleHQsIGxpbmV3aXNlKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgcmVnaXN0ZXIgaGFzIGV2ZXIgYmVlbiBzZXQgdG8gbGluZXdpc2UsIHVzZSBsaW5ld2lzZS5cbiAgICAgICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmxpbmV3aXNlKSB7XG4gICAgICAgICAgICB0aGlzLmtleUJ1ZmZlci5wdXNoKCdcXG4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5saW5ld2lzZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXlCdWZmZXIucHVzaCh0ZXh0KTtcbiAgICAgIH0sXG4gICAgICBwdXNoSW5zZXJ0TW9kZUNoYW5nZXM6IGZ1bmN0aW9uKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRNb2RlQ2hhbmdlcy5wdXNoKGNyZWF0ZUluc2VydE1vZGVDaGFuZ2VzKGNoYW5nZXMpKTtcbiAgICAgIH0sXG4gICAgICBwdXNoU2VhcmNoUXVlcnk6IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMuc2VhcmNoUXVlcmllcy5wdXNoKHF1ZXJ5KTtcbiAgICAgIH0sXG4gICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMua2V5QnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuaW5zZXJ0TW9kZUNoYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWFyY2hRdWVyaWVzID0gW107XG4gICAgICAgIHRoaXMubGluZXdpc2UgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleUJ1ZmZlci5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhbiBleHRlcm5hbCByZWdpc3Rlci5cbiAgICAgKlxuICAgICAqIFRoZSBuYW1lIHNob3VsZCBiZSBhIHNpbmdsZSBjaGFyYWN0ZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSByZWdpc3Rlci5cbiAgICAgKiBUaGUgcmVnaXN0ZXIgc2hvdWxkIHN1cHBvcnQgc2V0VGV4dCwgcHVzaFRleHQsIGNsZWFyLCBhbmQgdG9TdHJpbmcoKS4gU2VlIFJlZ2lzdGVyXG4gICAgICogZm9yIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmluZVJlZ2lzdGVyKG5hbWUsIHJlZ2lzdGVyKSB7XG4gICAgICB2YXIgcmVnaXN0ZXJzID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLnJlZ2lzdGVycztcbiAgICAgIGlmICghbmFtZSB8fCBuYW1lLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdSZWdpc3RlciBuYW1lIG11c3QgYmUgMSBjaGFyYWN0ZXInKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWdpc3RlcnNbbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1JlZ2lzdGVyIGFscmVhZHkgZGVmaW5lZCAnICsgbmFtZSk7XG4gICAgICB9XG4gICAgICByZWdpc3RlcnNbbmFtZV0gPSByZWdpc3RlcjtcbiAgICAgIHZhbGlkUmVnaXN0ZXJzLnB1c2gobmFtZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiB2aW0gcmVnaXN0ZXJzIGFsbG93IHlvdSB0byBrZWVwIG1hbnkgaW5kZXBlbmRlbnQgY29weSBhbmQgcGFzdGUgYnVmZmVycy5cbiAgICAgKiBTZWUgaHR0cDovL3VzZXZpbS5jb20vMjAxMi8wNC8xMy9yZWdpc3RlcnMvIGZvciBhbiBpbnRyb2R1Y3Rpb24uXG4gICAgICpcbiAgICAgKiBSZWdpc3RlckNvbnRyb2xsZXIga2VlcHMgdGhlIHN0YXRlIG9mIGFsbCB0aGUgcmVnaXN0ZXJzLiAgQW4gaW5pdGlhbFxuICAgICAqIHN0YXRlIG1heSBiZSBwYXNzZWQgaW4uICBUaGUgdW5uYW1lZCByZWdpc3RlciAnXCInIHdpbGwgYWx3YXlzIGJlXG4gICAgICogb3ZlcnJpZGRlbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWdpc3RlckNvbnRyb2xsZXIocmVnaXN0ZXJzKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVycyA9IHJlZ2lzdGVycztcbiAgICAgIHRoaXMudW5uYW1lZFJlZ2lzdGVyID0gcmVnaXN0ZXJzWydcIiddID0gbmV3IFJlZ2lzdGVyKCk7XG4gICAgICByZWdpc3RlcnNbJy4nXSA9IG5ldyBSZWdpc3RlcigpO1xuICAgICAgcmVnaXN0ZXJzWyc6J10gPSBuZXcgUmVnaXN0ZXIoKTtcbiAgICAgIHJlZ2lzdGVyc1snLyddID0gbmV3IFJlZ2lzdGVyKCk7XG4gICAgfVxuICAgIFJlZ2lzdGVyQ29udHJvbGxlci5wcm90b3R5cGUgPSB7XG4gICAgICBwdXNoVGV4dDogZnVuY3Rpb24ocmVnaXN0ZXJOYW1lLCBvcGVyYXRvciwgdGV4dCwgbGluZXdpc2UsIGJsb2Nrd2lzZSkge1xuICAgICAgICAvLyBUaGUgYmxhY2sgaG9sZSByZWdpc3RlciwgXCJfLCBtZWFucyBkZWxldGUveWFuayB0byBub3doZXJlLlxuICAgICAgICBpZiAocmVnaXN0ZXJOYW1lID09PSAnXycpIHJldHVybjtcbiAgICAgICAgaWYgKGxpbmV3aXNlICYmIHRleHQuY2hhckF0KHRleHQubGVuZ3RoIC0gMSkgIT09ICdcXG4nKXtcbiAgICAgICAgICB0ZXh0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvd2VyY2FzZSBhbmQgdXBwZXJjYXNlIHJlZ2lzdGVycyByZWZlciB0byB0aGUgc2FtZSByZWdpc3Rlci5cbiAgICAgICAgLy8gVXBwZXJjYXNlIGp1c3QgbWVhbnMgYXBwZW5kLlxuICAgICAgICB2YXIgcmVnaXN0ZXIgPSB0aGlzLmlzVmFsaWRSZWdpc3RlcihyZWdpc3Rlck5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuZ2V0UmVnaXN0ZXIocmVnaXN0ZXJOYW1lKSA6IG51bGw7XG4gICAgICAgIC8vIGlmIG5vIHJlZ2lzdGVyL2FuIGludmFsaWQgcmVnaXN0ZXIgd2FzIHNwZWNpZmllZCwgdGhpbmdzIGdvIHRvIHRoZVxuICAgICAgICAvLyBkZWZhdWx0IHJlZ2lzdGVyc1xuICAgICAgICBpZiAoIXJlZ2lzdGVyKSB7XG4gICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSAneWFuayc6XG4gICAgICAgICAgICAgIC8vIFRoZSAwIHJlZ2lzdGVyIGNvbnRhaW5zIHRoZSB0ZXh0IGZyb20gdGhlIG1vc3QgcmVjZW50IHlhbmsuXG4gICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJzWycwJ10gPSBuZXcgUmVnaXN0ZXIodGV4dCwgbGluZXdpc2UsIGJsb2Nrd2lzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NoYW5nZSc6XG4gICAgICAgICAgICAgIGlmICh0ZXh0LmluZGV4T2YoJ1xcbicpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVsZXRlIGxlc3MgdGhhbiAxIGxpbmUuIFVwZGF0ZSB0aGUgc21hbGwgZGVsZXRlIHJlZ2lzdGVyLlxuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJzWyctJ10gPSBuZXcgUmVnaXN0ZXIodGV4dCwgbGluZXdpc2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IGRvd24gdGhlIGNvbnRlbnRzIG9mIHRoZSBudW1iZXJlZCByZWdpc3RlcnMgYW5kIHB1dCB0aGVcbiAgICAgICAgICAgICAgICAvLyBkZWxldGVkIHRleHQgaW50byByZWdpc3RlciAxLlxuICAgICAgICAgICAgICAgIHRoaXMuc2hpZnROdW1lcmljUmVnaXN0ZXJzXygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJzWycxJ10gPSBuZXcgUmVnaXN0ZXIodGV4dCwgbGluZXdpc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHVubmFtZWQgcmVnaXN0ZXIgaXMgc2V0IHRvIHdoYXQganVzdCBoYXBwZW5lZFxuICAgICAgICAgIHRoaXMudW5uYW1lZFJlZ2lzdGVyLnNldFRleHQodGV4dCwgbGluZXdpc2UsIGJsb2Nrd2lzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UndmUgZ290dGVuIHRvIHRoaXMgcG9pbnQsIHdlJ3ZlIGFjdHVhbGx5IHNwZWNpZmllZCBhIHJlZ2lzdGVyXG4gICAgICAgIHZhciBhcHBlbmQgPSBpc1VwcGVyQ2FzZShyZWdpc3Rlck5hbWUpO1xuICAgICAgICBpZiAoYXBwZW5kKSB7XG4gICAgICAgICAgcmVnaXN0ZXIucHVzaFRleHQodGV4dCwgbGluZXdpc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZ2lzdGVyLnNldFRleHQodGV4dCwgbGluZXdpc2UsIGJsb2Nrd2lzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHVubmFtZWQgcmVnaXN0ZXIgYWx3YXlzIGhhcyB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgbGFzdCB1c2VkXG4gICAgICAgIC8vIHJlZ2lzdGVyLlxuICAgICAgICB0aGlzLnVubmFtZWRSZWdpc3Rlci5zZXRUZXh0KHJlZ2lzdGVyLnRvU3RyaW5nKCksIGxpbmV3aXNlKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXRzIHRoZSByZWdpc3RlciBuYW1lZCBAbmFtZS4gIElmIG9uZSBvZiBAbmFtZSBkb2Vzbid0IGFscmVhZHkgZXhpc3QsXG4gICAgICAvLyBjcmVhdGUgaXQuICBJZiBAbmFtZSBpcyBpbnZhbGlkLCByZXR1cm4gdGhlIHVubmFtZWRSZWdpc3Rlci5cbiAgICAgIGdldFJlZ2lzdGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkUmVnaXN0ZXIobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51bm5hbWVkUmVnaXN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLnJlZ2lzdGVyc1tuYW1lXSkge1xuICAgICAgICAgIHRoaXMucmVnaXN0ZXJzW25hbWVdID0gbmV3IFJlZ2lzdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJzW25hbWVdO1xuICAgICAgfSxcbiAgICAgIGlzVmFsaWRSZWdpc3RlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZSAmJiBpbkFycmF5KG5hbWUsIHZhbGlkUmVnaXN0ZXJzKTtcbiAgICAgIH0sXG4gICAgICBzaGlmdE51bWVyaWNSZWdpc3RlcnNfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDk7IGkgPj0gMjsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZWdpc3RlcnNbaV0gPSB0aGlzLmdldFJlZ2lzdGVyKCcnICsgKGkgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIEhpc3RvcnlDb250cm9sbGVyKCkge1xuICAgICAgICB0aGlzLmhpc3RvcnlCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IDA7XG4gICAgICAgIHRoaXMuaW5pdGlhbFByZWZpeCA9IG51bGw7XG4gICAgfVxuICAgIEhpc3RvcnlDb250cm9sbGVyLnByb3RvdHlwZSA9IHtcbiAgICAgIC8vIHRoZSBpbnB1dCBhcmd1bWVudCBoZXJlIGFjdHMgYSB1c2VyIGVudGVyZWQgcHJlZml4IGZvciBhIHNtYWxsIHRpbWVcbiAgICAgIC8vIHVudGlsIHdlIHN0YXJ0IGF1dG9jb21wbGV0aW9uIGluIHdoaWNoIGNhc2UgaXQgaXMgdGhlIGF1dG9jb21wbGV0ZWQuXG4gICAgICBuZXh0TWF0Y2g6IGZ1bmN0aW9uIChpbnB1dCwgdXApIHtcbiAgICAgICAgdmFyIGhpc3RvcnlCdWZmZXIgPSB0aGlzLmhpc3RvcnlCdWZmZXI7XG4gICAgICAgIHZhciBkaXIgPSB1cCA/IC0xIDogMTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFByZWZpeCA9PT0gbnVsbCkgdGhpcy5pbml0aWFsUHJlZml4ID0gaW5wdXQ7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLml0ZXJhdG9yICsgZGlyOyB1cCA/IGkgPj0gMCA6IGkgPCBoaXN0b3J5QnVmZmVyLmxlbmd0aDsgaSs9IGRpcikge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gaGlzdG9yeUJ1ZmZlcltpXTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBlbGVtZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsUHJlZml4ID09IGVsZW1lbnQuc3Vic3RyaW5nKDAsIGopKSB7XG4gICAgICAgICAgICAgIHRoaXMuaXRlcmF0b3IgPSBpO1xuICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdWxkIHJldHVybiB0aGUgdXNlciBpbnB1dCBpbiBjYXNlIHdlIHJlYWNoIHRoZSBlbmQgb2YgYnVmZmVyLlxuICAgICAgICBpZiAoaSA+PSBoaXN0b3J5QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuaXRlcmF0b3IgPSBoaXN0b3J5QnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiB0aGUgbGFzdCBhdXRvY29tcGxldGVkIHF1ZXJ5IG9yIGV4Q29tbWFuZCBhcyBpdCBpcy5cbiAgICAgICAgaWYgKGkgPCAwICkgcmV0dXJuIGlucHV0O1xuICAgICAgfSxcbiAgICAgIHB1c2hJbnB1dDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5oaXN0b3J5QnVmZmVyLmluZGV4T2YoaW5wdXQpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkgdGhpcy5oaXN0b3J5QnVmZmVyLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGlmIChpbnB1dC5sZW5ndGgpIHRoaXMuaGlzdG9yeUJ1ZmZlci5wdXNoKGlucHV0KTtcbiAgICAgIH0sXG4gICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbFByZWZpeCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSB0aGlzLmhpc3RvcnlCdWZmZXIubGVuZ3RoO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNvbW1hbmREaXNwYXRjaGVyID0ge1xuICAgICAgbWF0Y2hDb21tYW5kOiBmdW5jdGlvbihrZXlzLCBrZXlNYXAsIGlucHV0U3RhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBjb21tYW5kTWF0Y2hlcyhrZXlzLCBrZXlNYXAsIGNvbnRleHQsIGlucHV0U3RhdGUpO1xuICAgICAgICBpZiAoIW1hdGNoZXMuZnVsbCAmJiAhbWF0Y2hlcy5wYXJ0aWFsKSB7XG4gICAgICAgICAgcmV0dXJuIHt0eXBlOiAnbm9uZSd9O1xuICAgICAgICB9IGVsc2UgaWYgKCFtYXRjaGVzLmZ1bGwgJiYgbWF0Y2hlcy5wYXJ0aWFsKSB7XG4gICAgICAgICAgcmV0dXJuIHt0eXBlOiAncGFydGlhbCd9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJlc3RNYXRjaDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmZ1bGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBtYXRjaGVzLmZ1bGxbaV07XG4gICAgICAgICAgaWYgKCFiZXN0TWF0Y2gpIHtcbiAgICAgICAgICAgIGJlc3RNYXRjaCA9IG1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdE1hdGNoLmtleXMuc2xpY2UoLTExKSA9PSAnPGNoYXJhY3Rlcj4nKSB7XG4gICAgICAgICAgdmFyIGNoYXJhY3RlciA9IGxhc3RDaGFyKGtleXMpO1xuICAgICAgICAgIGlmICghY2hhcmFjdGVyKSByZXR1cm4ge3R5cGU6ICdub25lJ307XG4gICAgICAgICAgaW5wdXRTdGF0ZS5zZWxlY3RlZENoYXJhY3RlciA9IGNoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3R5cGU6ICdmdWxsJywgY29tbWFuZDogYmVzdE1hdGNofTtcbiAgICAgIH0sXG4gICAgICBwcm9jZXNzQ29tbWFuZDogZnVuY3Rpb24oY20sIHZpbSwgY29tbWFuZCkge1xuICAgICAgICB2aW0uaW5wdXRTdGF0ZS5yZXBlYXRPdmVycmlkZSA9IGNvbW1hbmQucmVwZWF0T3ZlcnJpZGU7XG4gICAgICAgIHN3aXRjaCAoY29tbWFuZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnbW90aW9uJzpcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc01vdGlvbihjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29wZXJhdG9yJzpcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc09wZXJhdG9yKGNtLCB2aW0sIGNvbW1hbmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb3BlcmF0b3JNb3Rpb24nOlxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzT3BlcmF0b3JNb3Rpb24oY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhY3Rpb24nOlxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQWN0aW9uKGNtLCB2aW0sIGNvbW1hbmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2VhcmNoJzpcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1NlYXJjaChjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2V4JzpcbiAgICAgICAgICBjYXNlICdrZXlUb0V4JzpcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0V4KGNtLCB2aW0sIGNvbW1hbmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvY2Vzc01vdGlvbjogZnVuY3Rpb24oY20sIHZpbSwgY29tbWFuZCkge1xuICAgICAgICB2aW0uaW5wdXRTdGF0ZS5tb3Rpb24gPSBjb21tYW5kLm1vdGlvbjtcbiAgICAgICAgdmltLmlucHV0U3RhdGUubW90aW9uQXJncyA9IGNvcHlBcmdzKGNvbW1hbmQubW90aW9uQXJncyk7XG4gICAgICAgIHRoaXMuZXZhbElucHV0KGNtLCB2aW0pO1xuICAgICAgfSxcbiAgICAgIHByb2Nlc3NPcGVyYXRvcjogZnVuY3Rpb24oY20sIHZpbSwgY29tbWFuZCkge1xuICAgICAgICB2YXIgaW5wdXRTdGF0ZSA9IHZpbS5pbnB1dFN0YXRlO1xuICAgICAgICBpZiAoaW5wdXRTdGF0ZS5vcGVyYXRvcikge1xuICAgICAgICAgIGlmIChpbnB1dFN0YXRlLm9wZXJhdG9yID09IGNvbW1hbmQub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIC8vIFR5cGluZyBhbiBvcGVyYXRvciB0d2ljZSBsaWtlICdkZCcgbWFrZXMgdGhlIG9wZXJhdG9yIG9wZXJhdGVcbiAgICAgICAgICAgIC8vIGxpbmV3aXNlXG4gICAgICAgICAgICBpbnB1dFN0YXRlLm1vdGlvbiA9ICdleHBhbmRUb0xpbmUnO1xuICAgICAgICAgICAgaW5wdXRTdGF0ZS5tb3Rpb25BcmdzID0geyBsaW5ld2lzZTogdHJ1ZSB9O1xuICAgICAgICAgICAgdGhpcy5ldmFsSW5wdXQoY20sIHZpbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIDIgZGlmZmVyZW50IG9wZXJhdG9ycyBpbiBhIHJvdyBkb2Vzbid0IG1ha2Ugc2Vuc2UuXG4gICAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnB1dFN0YXRlLm9wZXJhdG9yID0gY29tbWFuZC5vcGVyYXRvcjtcbiAgICAgICAgaW5wdXRTdGF0ZS5vcGVyYXRvckFyZ3MgPSBjb3B5QXJncyhjb21tYW5kLm9wZXJhdG9yQXJncyk7XG4gICAgICAgIGlmIChjb21tYW5kLmV4aXRWaXN1YWxCbG9jaykge1xuICAgICAgICAgICAgdmltLnZpc3VhbEJsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICB1cGRhdGVDbVNlbGVjdGlvbihjbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgLy8gT3BlcmF0aW5nIG9uIGEgc2VsZWN0aW9uIGluIHZpc3VhbCBtb2RlLiBXZSBkb24ndCBuZWVkIGEgbW90aW9uLlxuICAgICAgICAgIHRoaXMuZXZhbElucHV0KGNtLCB2aW0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvY2Vzc09wZXJhdG9yTW90aW9uOiBmdW5jdGlvbihjbSwgdmltLCBjb21tYW5kKSB7XG4gICAgICAgIHZhciB2aXN1YWxNb2RlID0gdmltLnZpc3VhbE1vZGU7XG4gICAgICAgIHZhciBvcGVyYXRvck1vdGlvbkFyZ3MgPSBjb3B5QXJncyhjb21tYW5kLm9wZXJhdG9yTW90aW9uQXJncyk7XG4gICAgICAgIGlmIChvcGVyYXRvck1vdGlvbkFyZ3MpIHtcbiAgICAgICAgICAvLyBPcGVyYXRvciBtb3Rpb25zIG1heSBoYXZlIHNwZWNpYWwgYmVoYXZpb3IgaW4gdmlzdWFsIG1vZGUuXG4gICAgICAgICAgaWYgKHZpc3VhbE1vZGUgJiYgb3BlcmF0b3JNb3Rpb25BcmdzLnZpc3VhbExpbmUpIHtcbiAgICAgICAgICAgIHZpbS52aXN1YWxMaW5lID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzT3BlcmF0b3IoY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICAgIGlmICghdmlzdWFsTW9kZSkge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc01vdGlvbihjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb2Nlc3NBY3Rpb246IGZ1bmN0aW9uKGNtLCB2aW0sIGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIGlucHV0U3RhdGUgPSB2aW0uaW5wdXRTdGF0ZTtcbiAgICAgICAgdmFyIHJlcGVhdCA9IGlucHV0U3RhdGUuZ2V0UmVwZWF0KCk7XG4gICAgICAgIHZhciByZXBlYXRJc0V4cGxpY2l0ID0gISFyZXBlYXQ7XG4gICAgICAgIHZhciBhY3Rpb25BcmdzID0gY29weUFyZ3MoY29tbWFuZC5hY3Rpb25BcmdzKSB8fCB7fTtcbiAgICAgICAgaWYgKGlucHV0U3RhdGUuc2VsZWN0ZWRDaGFyYWN0ZXIpIHtcbiAgICAgICAgICBhY3Rpb25BcmdzLnNlbGVjdGVkQ2hhcmFjdGVyID0gaW5wdXRTdGF0ZS5zZWxlY3RlZENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBY3Rpb25zIG1heSBvciBtYXkgbm90IGhhdmUgbW90aW9ucyBhbmQgb3BlcmF0b3JzLiBEbyB0aGVzZSBmaXJzdC5cbiAgICAgICAgaWYgKGNvbW1hbmQub3BlcmF0b3IpIHtcbiAgICAgICAgICB0aGlzLnByb2Nlc3NPcGVyYXRvcihjbSwgdmltLCBjb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC5tb3Rpb24pIHtcbiAgICAgICAgICB0aGlzLnByb2Nlc3NNb3Rpb24oY20sIHZpbSwgY29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQubW90aW9uIHx8IGNvbW1hbmQub3BlcmF0b3IpIHtcbiAgICAgICAgICB0aGlzLmV2YWxJbnB1dChjbSwgdmltKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25BcmdzLnJlcGVhdCA9IHJlcGVhdCB8fCAxO1xuICAgICAgICBhY3Rpb25BcmdzLnJlcGVhdElzRXhwbGljaXQgPSByZXBlYXRJc0V4cGxpY2l0O1xuICAgICAgICBhY3Rpb25BcmdzLnJlZ2lzdGVyTmFtZSA9IGlucHV0U3RhdGUucmVnaXN0ZXJOYW1lO1xuICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICB2aW0ubGFzdE1vdGlvbiA9IG51bGw7XG4gICAgICAgIGlmIChjb21tYW5kLmlzRWRpdCkge1xuICAgICAgICAgIHRoaXMucmVjb3JkTGFzdEVkaXQodmltLCBpbnB1dFN0YXRlLCBjb21tYW5kKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25zW2NvbW1hbmQuYWN0aW9uXShjbSwgYWN0aW9uQXJncywgdmltKTtcbiAgICAgIH0sXG4gICAgICBwcm9jZXNzU2VhcmNoOiBmdW5jdGlvbihjbSwgdmltLCBjb21tYW5kKSB7XG4gICAgICAgIGlmICghY20uZ2V0U2VhcmNoQ3Vyc29yKSB7XG4gICAgICAgICAgLy8gU2VhcmNoIGRlcGVuZHMgb24gU2VhcmNoQ3Vyc29yLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9yd2FyZCA9IGNvbW1hbmQuc2VhcmNoQXJncy5mb3J3YXJkO1xuICAgICAgICB2YXIgd2hvbGVXb3JkT25seSA9IGNvbW1hbmQuc2VhcmNoQXJncy53aG9sZVdvcmRPbmx5O1xuICAgICAgICBnZXRTZWFyY2hTdGF0ZShjbSkuc2V0UmV2ZXJzZWQoIWZvcndhcmQpO1xuICAgICAgICB2YXIgcHJvbXB0UHJlZml4ID0gKGZvcndhcmQpID8gJy8nIDogJz8nO1xuICAgICAgICB2YXIgb3JpZ2luYWxRdWVyeSA9IGdldFNlYXJjaFN0YXRlKGNtKS5nZXRRdWVyeSgpO1xuICAgICAgICB2YXIgb3JpZ2luYWxTY3JvbGxQb3MgPSBjbS5nZXRTY3JvbGxJbmZvKCk7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVF1ZXJ5KHF1ZXJ5LCBpZ25vcmVDYXNlLCBzbWFydENhc2UpIHtcbiAgICAgICAgICB2aW1HbG9iYWxTdGF0ZS5zZWFyY2hIaXN0b3J5Q29udHJvbGxlci5wdXNoSW5wdXQocXVlcnkpO1xuICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLnNlYXJjaEhpc3RvcnlDb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVwZGF0ZVNlYXJjaFF1ZXJ5KGNtLCBxdWVyeSwgaWdub3JlQ2FzZSwgc21hcnRDYXNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgcmVnZXg6ICcgKyBxdWVyeSk7XG4gICAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb21tYW5kRGlzcGF0Y2hlci5wcm9jZXNzTW90aW9uKGNtLCB2aW0sIHtcbiAgICAgICAgICAgIHR5cGU6ICdtb3Rpb24nLFxuICAgICAgICAgICAgbW90aW9uOiAnZmluZE5leHQnLFxuICAgICAgICAgICAgbW90aW9uQXJnczogeyBmb3J3YXJkOiB0cnVlLCB0b0p1bXBsaXN0OiBjb21tYW5kLnNlYXJjaEFyZ3MudG9KdW1wbGlzdCB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Qcm9tcHRDbG9zZShxdWVyeSkge1xuICAgICAgICAgIGNtLnNjcm9sbFRvKG9yaWdpbmFsU2Nyb2xsUG9zLmxlZnQsIG9yaWdpbmFsU2Nyb2xsUG9zLnRvcCk7XG4gICAgICAgICAgaGFuZGxlUXVlcnkocXVlcnksIHRydWUgLyoqIGlnbm9yZUNhc2UgKi8sIHRydWUgLyoqIHNtYXJ0Q2FzZSAqLyk7XG4gICAgICAgICAgdmFyIG1hY3JvTW9kZVN0YXRlID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGU7XG4gICAgICAgICAgaWYgKG1hY3JvTW9kZVN0YXRlLmlzUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICBsb2dTZWFyY2hRdWVyeShtYWNyb01vZGVTdGF0ZSwgcXVlcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblByb21wdEtleVVwKGUsIHF1ZXJ5LCBjbG9zZSkge1xuICAgICAgICAgIHZhciBrZXlOYW1lID0gQ29kZU1pcnJvci5rZXlOYW1lKGUpLCB1cCwgb2Zmc2V0O1xuICAgICAgICAgIGlmIChrZXlOYW1lID09ICdVcCcgfHwga2V5TmFtZSA9PSAnRG93bicpIHtcbiAgICAgICAgICAgIHVwID0ga2V5TmFtZSA9PSAnVXAnID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZS50YXJnZXQgPyBlLnRhcmdldC5zZWxlY3Rpb25FbmQgOiAwO1xuICAgICAgICAgICAgcXVlcnkgPSB2aW1HbG9iYWxTdGF0ZS5zZWFyY2hIaXN0b3J5Q29udHJvbGxlci5uZXh0TWF0Y2gocXVlcnksIHVwKSB8fCAnJztcbiAgICAgICAgICAgIGNsb3NlKHF1ZXJ5KTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgJiYgZS50YXJnZXQpIGUudGFyZ2V0LnNlbGVjdGlvbkVuZCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0LCBlLnRhcmdldC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIGtleU5hbWUgIT0gJ0xlZnQnICYmIGtleU5hbWUgIT0gJ1JpZ2h0JyAmJiBrZXlOYW1lICE9ICdDdHJsJyAmJiBrZXlOYW1lICE9ICdBbHQnICYmIGtleU5hbWUgIT0gJ1NoaWZ0JylcbiAgICAgICAgICAgICAgdmltR2xvYmFsU3RhdGUuc2VhcmNoSGlzdG9yeUNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhcnNlZFF1ZXJ5O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZWRRdWVyeSA9IHVwZGF0ZVNlYXJjaFF1ZXJ5KGNtLCBxdWVyeSxcbiAgICAgICAgICAgICAgICB0cnVlIC8qKiBpZ25vcmVDYXNlICovLCB0cnVlIC8qKiBzbWFydENhc2UgKi8pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgYmFkIHJlZ2V4ZXMgZm9yIGluY3JlbWVudGFsIHNlYXJjaC5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnNlZFF1ZXJ5KSB7XG4gICAgICAgICAgICBjbS5zY3JvbGxJbnRvVmlldyhmaW5kTmV4dChjbSwgIWZvcndhcmQsIHBhcnNlZFF1ZXJ5KSwgMzApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhclNlYXJjaEhpZ2hsaWdodChjbSk7XG4gICAgICAgICAgICBjbS5zY3JvbGxUbyhvcmlnaW5hbFNjcm9sbFBvcy5sZWZ0LCBvcmlnaW5hbFNjcm9sbFBvcy50b3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblByb21wdEtleURvd24oZSwgcXVlcnksIGNsb3NlKSB7XG4gICAgICAgICAgdmFyIGtleU5hbWUgPSBDb2RlTWlycm9yLmtleU5hbWUoZSk7XG4gICAgICAgICAgaWYgKGtleU5hbWUgPT0gJ0VzYycgfHwga2V5TmFtZSA9PSAnQ3RybC1DJyB8fCBrZXlOYW1lID09ICdDdHJsLVsnIHx8XG4gICAgICAgICAgICAgIChrZXlOYW1lID09ICdCYWNrc3BhY2UnICYmIHF1ZXJ5ID09ICcnKSkge1xuICAgICAgICAgICAgdmltR2xvYmFsU3RhdGUuc2VhcmNoSGlzdG9yeUNvbnRyb2xsZXIucHVzaElucHV0KHF1ZXJ5KTtcbiAgICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLnNlYXJjaEhpc3RvcnlDb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICAgICAgICB1cGRhdGVTZWFyY2hRdWVyeShjbSwgb3JpZ2luYWxRdWVyeSk7XG4gICAgICAgICAgICBjbGVhclNlYXJjaEhpZ2hsaWdodChjbSk7XG4gICAgICAgICAgICBjbS5zY3JvbGxUbyhvcmlnaW5hbFNjcm9sbFBvcy5sZWZ0LCBvcmlnaW5hbFNjcm9sbFBvcy50b3ApO1xuICAgICAgICAgICAgQ29kZU1pcnJvci5lX3N0b3AoZSk7XG4gICAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIGNtLmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChrZXlOYW1lID09ICdVcCcgfHwga2V5TmFtZSA9PSAnRG93bicpIHtcbiAgICAgICAgICAgIENvZGVNaXJyb3IuZV9zdG9wKGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5TmFtZSA9PSAnQ3RybC1VJykge1xuICAgICAgICAgICAgLy8gQ3RybC1VIGNsZWFycyBpbnB1dC5cbiAgICAgICAgICAgIENvZGVNaXJyb3IuZV9zdG9wKGUpO1xuICAgICAgICAgICAgY2xvc2UoJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvbW1hbmQuc2VhcmNoQXJncy5xdWVyeVNyYykge1xuICAgICAgICAgIGNhc2UgJ3Byb21wdCc6XG4gICAgICAgICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgICAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbWFjcm9Nb2RlU3RhdGUucmVwbGF5U2VhcmNoUXVlcmllcy5zaGlmdCgpO1xuICAgICAgICAgICAgICBoYW5kbGVRdWVyeShxdWVyeSwgdHJ1ZSAvKiogaWdub3JlQ2FzZSAqLywgZmFsc2UgLyoqIHNtYXJ0Q2FzZSAqLyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzaG93UHJvbXB0KGNtLCB7XG4gICAgICAgICAgICAgICAgICBvbkNsb3NlOiBvblByb21wdENsb3NlLFxuICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcm9tcHRQcmVmaXgsXG4gICAgICAgICAgICAgICAgICBkZXNjOiAnKEphdmFTY3JpcHQgcmVnZXhwKScsXG4gICAgICAgICAgICAgICAgICBvbktleVVwOiBvblByb21wdEtleVVwLFxuICAgICAgICAgICAgICAgICAgb25LZXlEb3duOiBvblByb21wdEtleURvd25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd3b3JkVW5kZXJDdXJzb3InOlxuICAgICAgICAgICAgdmFyIHdvcmQgPSBleHBhbmRXb3JkVW5kZXJDdXJzb3IoY20sIGZhbHNlIC8qKiBpbmNsdXNpdmUgKi8sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvKiogZm9yd2FyZCAqLywgZmFsc2UgLyoqIGJpZ1dvcmQgKi8sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvKiogbm9TeW1ib2wgKi8pO1xuICAgICAgICAgICAgdmFyIGlzS2V5d29yZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXdvcmQpIHtcbiAgICAgICAgICAgICAgd29yZCA9IGV4cGFuZFdvcmRVbmRlckN1cnNvcihjbSwgZmFsc2UgLyoqIGluY2x1c2l2ZSAqLyxcbiAgICAgICAgICAgICAgICAgIHRydWUgLyoqIGZvcndhcmQgKi8sIGZhbHNlIC8qKiBiaWdXb3JkICovLFxuICAgICAgICAgICAgICAgICAgZmFsc2UgLyoqIG5vU3ltYm9sICovKTtcbiAgICAgICAgICAgICAgaXNLZXl3b3JkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXdvcmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gY20uZ2V0TGluZSh3b3JkLnN0YXJ0LmxpbmUpLnN1YnN0cmluZyh3b3JkLnN0YXJ0LmNoLFxuICAgICAgICAgICAgICAgIHdvcmQuZW5kLmNoKTtcbiAgICAgICAgICAgIGlmIChpc0tleXdvcmQgJiYgd2hvbGVXb3JkT25seSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gJ1xcXFxiJyArIHF1ZXJ5ICsgJ1xcXFxiJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHF1ZXJ5ID0gZXNjYXBlUmVnZXgocXVlcnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWNoZWRDdXJzb3IgaXMgdXNlZCB0byBzYXZlIHRoZSBvbGQgcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAgICAgICAgLy8gd2hlbiAqIG9yICMgY2F1c2VzIHZpbSB0byBzZWVrIGZvciB0aGUgbmVhcmVzdCB3b3JkIGFuZCBzaGlmdFxuICAgICAgICAgICAgLy8gdGhlIGN1cnNvciBiZWZvcmUgZW50ZXJpbmcgdGhlIG1vdGlvbi5cbiAgICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLmp1bXBMaXN0LmNhY2hlZEN1cnNvciA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgY20uc2V0Q3Vyc29yKHdvcmQuc3RhcnQpO1xuXG4gICAgICAgICAgICBoYW5kbGVRdWVyeShxdWVyeSwgdHJ1ZSAvKiogaWdub3JlQ2FzZSAqLywgZmFsc2UgLyoqIHNtYXJ0Q2FzZSAqLyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb2Nlc3NFeDogZnVuY3Rpb24oY20sIHZpbSwgY29tbWFuZCkge1xuICAgICAgICBmdW5jdGlvbiBvblByb21wdENsb3NlKGlucHV0KSB7XG4gICAgICAgICAgLy8gR2l2ZSB0aGUgcHJvbXB0IHNvbWUgdGltZSB0byBjbG9zZSBzbyB0aGF0IGlmIHByb2Nlc3NDb21tYW5kIHNob3dzXG4gICAgICAgICAgLy8gYW4gZXJyb3IsIHRoZSBlbGVtZW50cyBkb24ndCBvdmVybGFwLlxuICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLmV4Q29tbWFuZEhpc3RvcnlDb250cm9sbGVyLnB1c2hJbnB1dChpbnB1dCk7XG4gICAgICAgICAgdmltR2xvYmFsU3RhdGUuZXhDb21tYW5kSGlzdG9yeUNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgICAgICBleENvbW1hbmREaXNwYXRjaGVyLnByb2Nlc3NDb21tYW5kKGNtLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Qcm9tcHRLZXlEb3duKGUsIGlucHV0LCBjbG9zZSkge1xuICAgICAgICAgIHZhciBrZXlOYW1lID0gQ29kZU1pcnJvci5rZXlOYW1lKGUpLCB1cCwgb2Zmc2V0O1xuICAgICAgICAgIGlmIChrZXlOYW1lID09ICdFc2MnIHx8IGtleU5hbWUgPT0gJ0N0cmwtQycgfHwga2V5TmFtZSA9PSAnQ3RybC1bJyB8fFxuICAgICAgICAgICAgICAoa2V5TmFtZSA9PSAnQmFja3NwYWNlJyAmJiBpbnB1dCA9PSAnJykpIHtcbiAgICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLmV4Q29tbWFuZEhpc3RvcnlDb250cm9sbGVyLnB1c2hJbnB1dChpbnB1dCk7XG4gICAgICAgICAgICB2aW1HbG9iYWxTdGF0ZS5leENvbW1hbmRIaXN0b3J5Q29udHJvbGxlci5yZXNldCgpO1xuICAgICAgICAgICAgQ29kZU1pcnJvci5lX3N0b3AoZSk7XG4gICAgICAgICAgICBjbGVhcklucHV0U3RhdGUoY20pO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIGNtLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXlOYW1lID09ICdVcCcgfHwga2V5TmFtZSA9PSAnRG93bicpIHtcbiAgICAgICAgICAgIENvZGVNaXJyb3IuZV9zdG9wKGUpO1xuICAgICAgICAgICAgdXAgPSBrZXlOYW1lID09ICdVcCcgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICBvZmZzZXQgPSBlLnRhcmdldCA/IGUudGFyZ2V0LnNlbGVjdGlvbkVuZCA6IDA7XG4gICAgICAgICAgICBpbnB1dCA9IHZpbUdsb2JhbFN0YXRlLmV4Q29tbWFuZEhpc3RvcnlDb250cm9sbGVyLm5leHRNYXRjaChpbnB1dCwgdXApIHx8ICcnO1xuICAgICAgICAgICAgY2xvc2UoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCAmJiBlLnRhcmdldCkgZS50YXJnZXQuc2VsZWN0aW9uRW5kID0gZS50YXJnZXQuc2VsZWN0aW9uU3RhcnQgPSBNYXRoLm1pbihvZmZzZXQsIGUudGFyZ2V0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChrZXlOYW1lID09ICdDdHJsLVUnKSB7XG4gICAgICAgICAgICAvLyBDdHJsLVUgY2xlYXJzIGlucHV0LlxuICAgICAgICAgICAgQ29kZU1pcnJvci5lX3N0b3AoZSk7XG4gICAgICAgICAgICBjbG9zZSgnJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgga2V5TmFtZSAhPSAnTGVmdCcgJiYga2V5TmFtZSAhPSAnUmlnaHQnICYmIGtleU5hbWUgIT0gJ0N0cmwnICYmIGtleU5hbWUgIT0gJ0FsdCcgJiYga2V5TmFtZSAhPSAnU2hpZnQnKVxuICAgICAgICAgICAgICB2aW1HbG9iYWxTdGF0ZS5leENvbW1hbmRIaXN0b3J5Q29udHJvbGxlci5yZXNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC50eXBlID09ICdrZXlUb0V4Jykge1xuICAgICAgICAgIC8vIEhhbmRsZSB1c2VyIGRlZmluZWQgRXggdG8gRXggbWFwcGluZ3NcbiAgICAgICAgICBleENvbW1hbmREaXNwYXRjaGVyLnByb2Nlc3NDb21tYW5kKGNtLCBjb21tYW5kLmV4QXJncy5pbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgICBzaG93UHJvbXB0KGNtLCB7IG9uQ2xvc2U6IG9uUHJvbXB0Q2xvc2UsIHByZWZpeDogJzonLCB2YWx1ZTogJ1xcJzwsXFwnPicsXG4gICAgICAgICAgICAgICAgb25LZXlEb3duOiBvblByb21wdEtleURvd24sIHNlbGVjdFZhbHVlT25PcGVuOiBmYWxzZX0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaG93UHJvbXB0KGNtLCB7IG9uQ2xvc2U6IG9uUHJvbXB0Q2xvc2UsIHByZWZpeDogJzonLFxuICAgICAgICAgICAgICAgIG9uS2V5RG93bjogb25Qcm9tcHRLZXlEb3dufSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXZhbElucHV0OiBmdW5jdGlvbihjbSwgdmltKSB7XG4gICAgICAgIC8vIElmIHRoZSBtb3Rpb24gY29tbWFuZCBpcyBzZXQsIGV4ZWN1dGUgYm90aCB0aGUgb3BlcmF0b3IgYW5kIG1vdGlvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHJldHVybi5cbiAgICAgICAgdmFyIGlucHV0U3RhdGUgPSB2aW0uaW5wdXRTdGF0ZTtcbiAgICAgICAgdmFyIG1vdGlvbiA9IGlucHV0U3RhdGUubW90aW9uO1xuICAgICAgICB2YXIgbW90aW9uQXJncyA9IGlucHV0U3RhdGUubW90aW9uQXJncyB8fCB7fTtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gaW5wdXRTdGF0ZS5vcGVyYXRvcjtcbiAgICAgICAgdmFyIG9wZXJhdG9yQXJncyA9IGlucHV0U3RhdGUub3BlcmF0b3JBcmdzIHx8IHt9O1xuICAgICAgICB2YXIgcmVnaXN0ZXJOYW1lID0gaW5wdXRTdGF0ZS5yZWdpc3Rlck5hbWU7XG4gICAgICAgIHZhciBzZWwgPSB2aW0uc2VsO1xuICAgICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgY20gYW5kIHZpbSBzZWxlY3Rpb25zIGFyZSBpZGVudGljYWwgb3V0c2lkZSB2aXN1YWwgbW9kZS5cbiAgICAgICAgdmFyIG9yaWdIZWFkID0gY29weUN1cnNvcih2aW0udmlzdWFsTW9kZSA/IGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIHNlbC5oZWFkKTogY20uZ2V0Q3Vyc29yKCdoZWFkJykpO1xuICAgICAgICB2YXIgb3JpZ0FuY2hvciA9IGNvcHlDdXJzb3IodmltLnZpc3VhbE1vZGUgPyBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBzZWwuYW5jaG9yKSA6IGNtLmdldEN1cnNvcignYW5jaG9yJykpO1xuICAgICAgICB2YXIgb2xkSGVhZCA9IGNvcHlDdXJzb3Iob3JpZ0hlYWQpO1xuICAgICAgICB2YXIgb2xkQW5jaG9yID0gY29weUN1cnNvcihvcmlnQW5jaG9yKTtcbiAgICAgICAgdmFyIG5ld0hlYWQsIG5ld0FuY2hvcjtcbiAgICAgICAgdmFyIHJlcGVhdDtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgdGhpcy5yZWNvcmRMYXN0RWRpdCh2aW0sIGlucHV0U3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dFN0YXRlLnJlcGVhdE92ZXJyaWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBJZiByZXBlYXRPdmVycmlkZSBpcyBzcGVjaWZpZWQsIHRoYXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZVxuICAgICAgICAgIC8vIGlucHV0IHN0YXRlJ3MgcmVwZWF0LiBVc2VkIGJ5IEV4IG1vZGUgYW5kIGNhbiBiZSB1c2VyIGRlZmluZWQuXG4gICAgICAgICAgcmVwZWF0ID0gaW5wdXRTdGF0ZS5yZXBlYXRPdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBlYXQgPSBpbnB1dFN0YXRlLmdldFJlcGVhdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBlYXQgPiAwICYmIG1vdGlvbkFyZ3MuZXhwbGljaXRSZXBlYXQpIHtcbiAgICAgICAgICBtb3Rpb25BcmdzLnJlcGVhdElzRXhwbGljaXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1vdGlvbkFyZ3Mubm9SZXBlYXQgfHxcbiAgICAgICAgICAgICghbW90aW9uQXJncy5leHBsaWNpdFJlcGVhdCAmJiByZXBlYXQgPT09IDApKSB7XG4gICAgICAgICAgcmVwZWF0ID0gMTtcbiAgICAgICAgICBtb3Rpb25BcmdzLnJlcGVhdElzRXhwbGljaXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRTdGF0ZS5zZWxlY3RlZENoYXJhY3Rlcikge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgY2hhcmFjdGVyIGlucHV0LCBzdGljayBpdCBpbiBhbGwgb2YgdGhlIGFyZyBhcnJheXMuXG4gICAgICAgICAgbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlciA9IG9wZXJhdG9yQXJncy5zZWxlY3RlZENoYXJhY3RlciA9XG4gICAgICAgICAgICAgIGlucHV0U3RhdGUuc2VsZWN0ZWRDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgbW90aW9uQXJncy5yZXBlYXQgPSByZXBlYXQ7XG4gICAgICAgIGNsZWFySW5wdXRTdGF0ZShjbSk7XG4gICAgICAgIGlmIChtb3Rpb24pIHtcbiAgICAgICAgICB2YXIgbW90aW9uUmVzdWx0ID0gbW90aW9uc1ttb3Rpb25dKGNtLCBvcmlnSGVhZCwgbW90aW9uQXJncywgdmltLCBpbnB1dFN0YXRlKTtcbiAgICAgICAgICB2aW0ubGFzdE1vdGlvbiA9IG1vdGlvbnNbbW90aW9uXTtcbiAgICAgICAgICBpZiAoIW1vdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW90aW9uQXJncy50b0p1bXBsaXN0KSB7XG4gICAgICAgICAgICB2YXIganVtcExpc3QgPSB2aW1HbG9iYWxTdGF0ZS5qdW1wTGlzdDtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IG1vdGlvbiBpcyAjIG9yICosIHVzZSBjYWNoZWRDdXJzb3JcbiAgICAgICAgICAgIHZhciBjYWNoZWRDdXJzb3IgPSBqdW1wTGlzdC5jYWNoZWRDdXJzb3I7XG4gICAgICAgICAgICBpZiAoY2FjaGVkQ3Vyc29yKSB7XG4gICAgICAgICAgICAgIHJlY29yZEp1bXBQb3NpdGlvbihjbSwgY2FjaGVkQ3Vyc29yLCBtb3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICBkZWxldGUganVtcExpc3QuY2FjaGVkQ3Vyc29yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjb3JkSnVtcFBvc2l0aW9uKGNtLCBvcmlnSGVhZCwgbW90aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vdGlvblJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBuZXdBbmNob3IgPSBtb3Rpb25SZXN1bHRbMF07XG4gICAgICAgICAgICBuZXdIZWFkID0gbW90aW9uUmVzdWx0WzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdIZWFkID0gbW90aW9uUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUT0RPOiBIYW5kbGUgbnVsbCByZXR1cm5zIGZyb20gbW90aW9uIGNvbW1hbmRzIGJldHRlci5cbiAgICAgICAgICBpZiAoIW5ld0hlYWQpIHtcbiAgICAgICAgICAgIG5ld0hlYWQgPSBjb3B5Q3Vyc29yKG9yaWdIZWFkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgICBpZiAoISh2aW0udmlzdWFsQmxvY2sgJiYgbmV3SGVhZC5jaCA9PT0gSW5maW5pdHkpKSB7XG4gICAgICAgICAgICAgIG5ld0hlYWQgPSBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBuZXdIZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdBbmNob3IpIHtcbiAgICAgICAgICAgICAgbmV3QW5jaG9yID0gY2xpcEN1cnNvclRvQ29udGVudChjbSwgbmV3QW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FuY2hvciA9IG5ld0FuY2hvciB8fCBvbGRBbmNob3I7XG4gICAgICAgICAgICBzZWwuYW5jaG9yID0gbmV3QW5jaG9yO1xuICAgICAgICAgICAgc2VsLmhlYWQgPSBuZXdIZWFkO1xuICAgICAgICAgICAgdXBkYXRlQ21TZWxlY3Rpb24oY20pO1xuICAgICAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPCcsXG4gICAgICAgICAgICAgICAgY3Vyc29ySXNCZWZvcmUobmV3QW5jaG9yLCBuZXdIZWFkKSA/IG5ld0FuY2hvclxuICAgICAgICAgICAgICAgICAgICA6IG5ld0hlYWQpO1xuICAgICAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPicsXG4gICAgICAgICAgICAgICAgY3Vyc29ySXNCZWZvcmUobmV3QW5jaG9yLCBuZXdIZWFkKSA/IG5ld0hlYWRcbiAgICAgICAgICAgICAgICAgICAgOiBuZXdBbmNob3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW9wZXJhdG9yKSB7XG4gICAgICAgICAgICBuZXdIZWFkID0gY2xpcEN1cnNvclRvQ29udGVudChjbSwgbmV3SGVhZCk7XG4gICAgICAgICAgICBjbS5zZXRDdXJzb3IobmV3SGVhZC5saW5lLCBuZXdIZWFkLmNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgaWYgKG9wZXJhdG9yQXJncy5sYXN0U2VsKSB7XG4gICAgICAgICAgICAvLyBSZXBsYXlpbmcgYSB2aXN1YWwgbW9kZSBvcGVyYXRpb25cbiAgICAgICAgICAgIG5ld0FuY2hvciA9IG9sZEFuY2hvcjtcbiAgICAgICAgICAgIHZhciBsYXN0U2VsID0gb3BlcmF0b3JBcmdzLmxhc3RTZWw7XG4gICAgICAgICAgICB2YXIgbGluZU9mZnNldCA9IE1hdGguYWJzKGxhc3RTZWwuaGVhZC5saW5lIC0gbGFzdFNlbC5hbmNob3IubGluZSk7XG4gICAgICAgICAgICB2YXIgY2hPZmZzZXQgPSBNYXRoLmFicyhsYXN0U2VsLmhlYWQuY2ggLSBsYXN0U2VsLmFuY2hvci5jaCk7XG4gICAgICAgICAgICBpZiAobGFzdFNlbC52aXN1YWxMaW5lKSB7XG4gICAgICAgICAgICAgIC8vIExpbmV3aXNlIFZpc3VhbCBtb2RlOiBUaGUgc2FtZSBudW1iZXIgb2YgbGluZXMuXG4gICAgICAgICAgICAgIG5ld0hlYWQgPSBQb3Mob2xkQW5jaG9yLmxpbmUgKyBsaW5lT2Zmc2V0LCBvbGRBbmNob3IuY2gpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0U2VsLnZpc3VhbEJsb2NrKSB7XG4gICAgICAgICAgICAgIC8vIEJsb2Nrd2lzZSBWaXN1YWwgbW9kZTogVGhlIHNhbWUgbnVtYmVyIG9mIGxpbmVzIGFuZCBjb2x1bW5zLlxuICAgICAgICAgICAgICBuZXdIZWFkID0gUG9zKG9sZEFuY2hvci5saW5lICsgbGluZU9mZnNldCwgb2xkQW5jaG9yLmNoICsgY2hPZmZzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0U2VsLmhlYWQubGluZSA9PSBsYXN0U2VsLmFuY2hvci5saW5lKSB7XG4gICAgICAgICAgICAgIC8vIE5vcm1hbCBWaXN1YWwgbW9kZSB3aXRoaW4gb25lIGxpbmU6IFRoZSBzYW1lIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBuZXdIZWFkID0gUG9zKG9sZEFuY2hvci5saW5lLCBvbGRBbmNob3IuY2ggKyBjaE9mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb3JtYWwgVmlzdWFsIG1vZGUgd2l0aCBzZXZlcmFsIGxpbmVzOiBUaGUgc2FtZSBudW1iZXIgb2YgbGluZXMsIGluIHRoZVxuICAgICAgICAgICAgICAvLyBsYXN0IGxpbmUgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgYXMgaW4gdGhlIGxhc3QgbGluZSB0aGUgbGFzdCB0aW1lLlxuICAgICAgICAgICAgICBuZXdIZWFkID0gUG9zKG9sZEFuY2hvci5saW5lICsgbGluZU9mZnNldCwgb2xkQW5jaG9yLmNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpbS52aXN1YWxNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpbS52aXN1YWxMaW5lID0gbGFzdFNlbC52aXN1YWxMaW5lO1xuICAgICAgICAgICAgdmltLnZpc3VhbEJsb2NrID0gbGFzdFNlbC52aXN1YWxCbG9jaztcbiAgICAgICAgICAgIHNlbCA9IHZpbS5zZWwgPSB7XG4gICAgICAgICAgICAgIGFuY2hvcjogbmV3QW5jaG9yLFxuICAgICAgICAgICAgICBoZWFkOiBuZXdIZWFkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXBkYXRlQ21TZWxlY3Rpb24oY20pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICAgIG9wZXJhdG9yQXJncy5sYXN0U2VsID0ge1xuICAgICAgICAgICAgICBhbmNob3I6IGNvcHlDdXJzb3Ioc2VsLmFuY2hvciksXG4gICAgICAgICAgICAgIGhlYWQ6IGNvcHlDdXJzb3Ioc2VsLmhlYWQpLFxuICAgICAgICAgICAgICB2aXN1YWxCbG9jazogdmltLnZpc3VhbEJsb2NrLFxuICAgICAgICAgICAgICB2aXN1YWxMaW5lOiB2aW0udmlzdWFsTGluZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGN1clN0YXJ0LCBjdXJFbmQsIGxpbmV3aXNlLCBtb2RlO1xuICAgICAgICAgIHZhciBjbVNlbDtcbiAgICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICAgIC8vIEluaXQgdmlzdWFsIG9wXG4gICAgICAgICAgICBjdXJTdGFydCA9IGN1cnNvck1pbihzZWwuaGVhZCwgc2VsLmFuY2hvcik7XG4gICAgICAgICAgICBjdXJFbmQgPSBjdXJzb3JNYXgoc2VsLmhlYWQsIHNlbC5hbmNob3IpO1xuICAgICAgICAgICAgbGluZXdpc2UgPSB2aW0udmlzdWFsTGluZSB8fCBvcGVyYXRvckFyZ3MubGluZXdpc2U7XG4gICAgICAgICAgICBtb2RlID0gdmltLnZpc3VhbEJsb2NrID8gJ2Jsb2NrJyA6XG4gICAgICAgICAgICAgICAgICAgbGluZXdpc2UgPyAnbGluZScgOlxuICAgICAgICAgICAgICAgICAgICdjaGFyJztcbiAgICAgICAgICAgIGNtU2VsID0gbWFrZUNtU2VsZWN0aW9uKGNtLCB7XG4gICAgICAgICAgICAgIGFuY2hvcjogY3VyU3RhcnQsXG4gICAgICAgICAgICAgIGhlYWQ6IGN1ckVuZFxuICAgICAgICAgICAgfSwgbW9kZSk7XG4gICAgICAgICAgICBpZiAobGluZXdpc2UpIHtcbiAgICAgICAgICAgICAgdmFyIHJhbmdlcyA9IGNtU2VsLnJhbmdlcztcbiAgICAgICAgICAgICAgaWYgKG1vZGUgPT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICAgIC8vIExpbmV3aXNlIG9wZXJhdG9ycyBpbiB2aXN1YWwgYmxvY2sgbW9kZSBleHRlbmQgdG8gZW5kIG9mIGxpbmVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmFuZ2VzW2ldLmhlYWQuY2ggPSBsaW5lTGVuZ3RoKGNtLCByYW5nZXNbaV0uaGVhZC5saW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgICByYW5nZXNbMF0uaGVhZCA9IFBvcyhyYW5nZXNbMF0uaGVhZC5saW5lICsgMSwgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW5pdCBtb3Rpb24gb3BcbiAgICAgICAgICAgIGN1clN0YXJ0ID0gY29weUN1cnNvcihuZXdBbmNob3IgfHwgb2xkQW5jaG9yKTtcbiAgICAgICAgICAgIGN1ckVuZCA9IGNvcHlDdXJzb3IobmV3SGVhZCB8fCBvbGRIZWFkKTtcbiAgICAgICAgICAgIGlmIChjdXJzb3JJc0JlZm9yZShjdXJFbmQsIGN1clN0YXJ0KSkge1xuICAgICAgICAgICAgICB2YXIgdG1wID0gY3VyU3RhcnQ7XG4gICAgICAgICAgICAgIGN1clN0YXJ0ID0gY3VyRW5kO1xuICAgICAgICAgICAgICBjdXJFbmQgPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5ld2lzZSA9IG1vdGlvbkFyZ3MubGluZXdpc2UgfHwgb3BlcmF0b3JBcmdzLmxpbmV3aXNlO1xuICAgICAgICAgICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgICAgICAgIC8vIEV4cGFuZCBzZWxlY3Rpb24gdG8gZW50aXJlIGxpbmUuXG4gICAgICAgICAgICAgIGV4cGFuZFNlbGVjdGlvblRvTGluZShjbSwgY3VyU3RhcnQsIGN1ckVuZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vdGlvbkFyZ3MuZm9yd2FyZCkge1xuICAgICAgICAgICAgICAvLyBDbGlwIHRvIHRyYWlsaW5nIG5ld2xpbmVzIG9ubHkgaWYgdGhlIG1vdGlvbiBnb2VzIGZvcndhcmQuXG4gICAgICAgICAgICAgIGNsaXBUb0xpbmUoY20sIGN1clN0YXJ0LCBjdXJFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZSA9ICdjaGFyJztcbiAgICAgICAgICAgIHZhciBleGNsdXNpdmUgPSAhbW90aW9uQXJncy5pbmNsdXNpdmUgfHwgbGluZXdpc2U7XG4gICAgICAgICAgICBjbVNlbCA9IG1ha2VDbVNlbGVjdGlvbihjbSwge1xuICAgICAgICAgICAgICBhbmNob3I6IGN1clN0YXJ0LFxuICAgICAgICAgICAgICBoZWFkOiBjdXJFbmRcbiAgICAgICAgICAgIH0sIG1vZGUsIGV4Y2x1c2l2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMoY21TZWwucmFuZ2VzLCBjbVNlbC5wcmltYXJ5KTtcbiAgICAgICAgICB2aW0ubGFzdE1vdGlvbiA9IG51bGw7XG4gICAgICAgICAgb3BlcmF0b3JBcmdzLnJlcGVhdCA9IHJlcGVhdDsgLy8gRm9yIGluZGVudCBpbiB2aXN1YWwgbW9kZS5cbiAgICAgICAgICBvcGVyYXRvckFyZ3MucmVnaXN0ZXJOYW1lID0gcmVnaXN0ZXJOYW1lO1xuICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgbGluZXdpc2UgYXMgaXQgYWZmZWN0cyBob3cgcGFzdGUgYW5kIGNoYW5nZSBiZWhhdmUuXG4gICAgICAgICAgb3BlcmF0b3JBcmdzLmxpbmV3aXNlID0gbGluZXdpc2U7XG4gICAgICAgICAgdmFyIG9wZXJhdG9yTW92ZVRvID0gb3BlcmF0b3JzW29wZXJhdG9yXShcbiAgICAgICAgICAgIGNtLCBvcGVyYXRvckFyZ3MsIGNtU2VsLnJhbmdlcywgb2xkQW5jaG9yLCBuZXdIZWFkKTtcbiAgICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICAgIGV4aXRWaXN1YWxNb2RlKGNtLCBvcGVyYXRvck1vdmVUbyAhPSBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wZXJhdG9yTW92ZVRvKSB7XG4gICAgICAgICAgICBjbS5zZXRDdXJzb3Iob3BlcmF0b3JNb3ZlVG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlY29yZExhc3RFZGl0OiBmdW5jdGlvbih2aW0sIGlucHV0U3RhdGUsIGFjdGlvbkNvbW1hbmQpIHtcbiAgICAgICAgdmFyIG1hY3JvTW9kZVN0YXRlID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGU7XG4gICAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZpbS5sYXN0RWRpdElucHV0U3RhdGUgPSBpbnB1dFN0YXRlO1xuICAgICAgICB2aW0ubGFzdEVkaXRBY3Rpb25Db21tYW5kID0gYWN0aW9uQ29tbWFuZDtcbiAgICAgICAgbWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLmNoYW5nZXMgPSBbXTtcbiAgICAgICAgbWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLmV4cGVjdEN1cnNvckFjdGl2aXR5Rm9yQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIG1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcy52aXN1YWxCbG9jayA9IHZpbS52aXN1YWxCbG9jayA/IHZpbS5zZWwuaGVhZC5saW5lIC0gdmltLnNlbC5hbmNob3IubGluZSA6IDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHR5cGVkZWYge09iamVjdHtsaW5lOm51bWJlcixjaDpudW1iZXJ9fSBDdXJzb3IgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlXG4gICAgICogICAgIHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IuXG4gICAgICovXG4gICAgLy8gQWxsIG9mIHRoZSBmdW5jdGlvbnMgYmVsb3cgcmV0dXJuIEN1cnNvciBvYmplY3RzLlxuICAgIHZhciBtb3Rpb25zID0ge1xuICAgICAgbW92ZVRvVG9wTGluZTogZnVuY3Rpb24oY20sIF9oZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICAgIHZhciBsaW5lID0gZ2V0VXNlclZpc2libGVMaW5lcyhjbSkudG9wICsgbW90aW9uQXJncy5yZXBlYXQgLTE7XG4gICAgICAgIHJldHVybiBQb3MobGluZSwgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGxpbmUpKSk7XG4gICAgICB9LFxuICAgICAgbW92ZVRvTWlkZGxlTGluZTogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZ2V0VXNlclZpc2libGVMaW5lcyhjbSk7XG4gICAgICAgIHZhciBsaW5lID0gTWF0aC5mbG9vcigocmFuZ2UudG9wICsgcmFuZ2UuYm90dG9tKSAqIDAuNSk7XG4gICAgICAgIHJldHVybiBQb3MobGluZSwgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGxpbmUpKSk7XG4gICAgICB9LFxuICAgICAgbW92ZVRvQm90dG9tTGluZTogZnVuY3Rpb24oY20sIF9oZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICAgIHZhciBsaW5lID0gZ2V0VXNlclZpc2libGVMaW5lcyhjbSkuYm90dG9tIC0gbW90aW9uQXJncy5yZXBlYXQgKzE7XG4gICAgICAgIHJldHVybiBQb3MobGluZSwgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGxpbmUpKSk7XG4gICAgICB9LFxuICAgICAgZXhwYW5kVG9MaW5lOiBmdW5jdGlvbihfY20sIGhlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgLy8gRXhwYW5kcyBmb3J3YXJkIHRvIGVuZCBvZiBsaW5lLCBhbmQgdGhlbiB0byBuZXh0IGxpbmUgaWYgcmVwZWF0IGlzXG4gICAgICAgIC8vID4xLiBEb2VzIG5vdCBoYW5kbGUgYmFja3dhcmQgbW90aW9uIVxuICAgICAgICB2YXIgY3VyID0gaGVhZDtcbiAgICAgICAgcmV0dXJuIFBvcyhjdXIubGluZSArIG1vdGlvbkFyZ3MucmVwZWF0IC0gMSwgSW5maW5pdHkpO1xuICAgICAgfSxcbiAgICAgIGZpbmROZXh0OiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0U2VhcmNoU3RhdGUoY20pO1xuICAgICAgICB2YXIgcXVlcnkgPSBzdGF0ZS5nZXRRdWVyeSgpO1xuICAgICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2ID0gIW1vdGlvbkFyZ3MuZm9yd2FyZDtcbiAgICAgICAgLy8gSWYgc2VhcmNoIGlzIGluaXRpYXRlZCB3aXRoID8gaW5zdGVhZCBvZiAvLCBuZWdhdGUgZGlyZWN0aW9uLlxuICAgICAgICBwcmV2ID0gKHN0YXRlLmlzUmV2ZXJzZWQoKSkgPyAhcHJldiA6IHByZXY7XG4gICAgICAgIGhpZ2hsaWdodFNlYXJjaE1hdGNoZXMoY20sIHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIGZpbmROZXh0KGNtLCBwcmV2LyoqIHByZXYgKi8sIHF1ZXJ5LCBtb3Rpb25BcmdzLnJlcGVhdCk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIG5leHQgb2NjdXJyZW5jZSBvZiB0aGUgc2VhcmNoIHF1ZXJ5LiBJZiB0aGUgY3Vyc29yIGlzIGN1cnJlbnRseVxuICAgICAgICogd2l0aGluIGEgbWF0Y2gsIHRoZW4gZmluZCBhbmQgc2VsZWN0IHRoZSBjdXJyZW50IG1hdGNoLiBPdGhlcndpc2UsIGZpbmQgdGhlIG5leHQgb2NjdXJyZW5jZSBpbiB0aGVcbiAgICAgICAqIGFwcHJvcHJpYXRlIGRpcmVjdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGRpZmZlcnMgZnJvbSBgZmluZE5leHRgIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAgICAgICAqXG4gICAgICAgKiAxLiBJbnN0ZWFkIG9mIG9ubHkgcmV0dXJuaW5nIHRoZSBcImZyb21cIiwgdGhpcyByZXR1cm5zIGEgXCJmcm9tXCIsIFwidG9cIiByYW5nZS5cbiAgICAgICAqIDIuIElmIHRoZSBjdXJzb3IgaXMgY3VycmVudGx5IGluc2lkZSBhIHNlYXJjaCBtYXRjaCwgdGhpcyBzZWxlY3RzIHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiAgICBpbnN0ZWFkIG9mIHRoZSBuZXh0IG1hdGNoLlxuICAgICAgICogMy4gSWYgdGhlcmUgaXMgbm8gYXNzb2NpYXRlZCBvcGVyYXRvciwgdGhpcyB3aWxsIHR1cm4gb24gdmlzdWFsIG1vZGUuXG4gICAgICAgKi9cbiAgICAgIGZpbmRBbmRTZWxlY3ROZXh0SW5jbHVzaXZlOiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MsIHZpbSwgcHJldklucHV0U3RhdGUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0U2VhcmNoU3RhdGUoY20pO1xuICAgICAgICB2YXIgcXVlcnkgPSBzdGF0ZS5nZXRRdWVyeSgpO1xuXG4gICAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldiA9ICFtb3Rpb25BcmdzLmZvcndhcmQ7XG4gICAgICAgIHByZXYgPSAoc3RhdGUuaXNSZXZlcnNlZCgpKSA/ICFwcmV2IDogcHJldjtcblxuICAgICAgICAvLyBuZXh0OiBbZnJvbSwgdG9dIHwgbnVsbFxuICAgICAgICB2YXIgbmV4dCA9IGZpbmROZXh0RnJvbUFuZFRvSW5jbHVzaXZlKGNtLCBwcmV2LCBxdWVyeSwgbW90aW9uQXJncy5yZXBlYXQsIHZpbSk7XG5cbiAgICAgICAgLy8gTm8gbWF0Y2hlcy5cbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBvcGVyYXRvciB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQsIHJldHVybiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICBpZiAocHJldklucHV0U3RhdGUub3BlcmF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgdGhhdCB0aGVyZSBpcyBubyBhY2NvbXBhbnlpbmcgb3BlcmF0b3IgLS0gbGV0J3NcbiAgICAgICAgLy8gZGVhbCB3aXRoIHZpc3VhbCBtb2RlIGluIG9yZGVyIHRvIHNlbGVjdCBhbiBhcHByb3ByaWF0ZSBtYXRjaC5cblxuICAgICAgICB2YXIgZnJvbSA9IG5leHRbMF07XG4gICAgICAgIC8vIEZvciB3aGF0ZXZlciByZWFzb24sIHdoZW4gd2UgdXNlIHRoZSBcInRvXCIgYXMgcmV0dXJuZWQgYnkgc2VhcmNoY3Vyc29yLmpzIGRpcmVjdGx5LFxuICAgICAgICAvLyB0aGUgcmVzdWx0aW5nIHNlbGVjdGlvbiBpcyBleHRlbmRlZCBieSAxIGNoYXIuIExldCdzIHNocmluayBpdCBzbyB0aGF0IG9ubHkgdGhlXG4gICAgICAgIC8vIG1hdGNoIGlzIHNlbGVjdGVkLlxuICAgICAgICB2YXIgdG8gPSBQb3MobmV4dFsxXS5saW5lLCBuZXh0WzFdLmNoIC0gMSk7XG5cbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgLy8gSWYgd2Ugd2VyZSBpbiB2aXN1YWxMaW5lIG9yIHZpc3VhbEJsb2NrIG1vZGUsIGdldCBvdXQgb2YgaXQuXG4gICAgICAgICAgaWYgKHZpbS52aXN1YWxMaW5lIHx8IHZpbS52aXN1YWxCbG9jaykge1xuICAgICAgICAgICAgdmltLnZpc3VhbExpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZpbS52aXN1YWxCbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcInZpc3VhbFwiLCBzdWJNb2RlOiBcIlwifSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluIHZpc3VhbCBtb2RlLCB3ZSBzaG91bGQgZXh0ZW5kIHRoZSBzZWxlY3Rpb24gdG8gaW5jbHVkZVxuICAgICAgICAgIC8vIHRoZSBzZWFyY2ggcmVzdWx0LlxuICAgICAgICAgIHZhciBhbmNob3IgPSB2aW0uc2VsLmFuY2hvcjtcbiAgICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNSZXZlcnNlZCgpKSB7XG4gICAgICAgICAgICAgIGlmIChtb3Rpb25BcmdzLmZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2FuY2hvciwgZnJvbV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gW2FuY2hvciwgdG9dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKG1vdGlvbkFyZ3MuZm9yd2FyZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbYW5jaG9yLCB0b107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gW2FuY2hvciwgZnJvbV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExldCdzIHR1cm4gdmlzdWFsIG1vZGUgb24uXG4gICAgICAgICAgdmltLnZpc3VhbE1vZGUgPSB0cnVlO1xuICAgICAgICAgIHZpbS52aXN1YWxMaW5lID0gZmFsc2U7XG4gICAgICAgICAgdmltLnZpc3VhbEJsb2NrID0gZmFsc2U7XG4gICAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcInZpc3VhbFwiLCBzdWJNb2RlOiBcIlwifSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJldiA/IFt0bywgZnJvbV0gOiBbZnJvbSwgdG9dO1xuICAgICAgfSxcbiAgICAgIGdvVG9NYXJrOiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICB2YXIgcG9zID0gZ2V0TWFya1BvcyhjbSwgdmltLCBtb3Rpb25BcmdzLnNlbGVjdGVkQ2hhcmFjdGVyKTtcbiAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgIHJldHVybiBtb3Rpb25BcmdzLmxpbmV3aXNlID8geyBsaW5lOiBwb3MubGluZSwgY2g6IGZpbmRGaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20uZ2V0TGluZShwb3MubGluZSkpIH0gOiBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgbW92ZVRvT3RoZXJIaWdobGlnaHRlZEVuZDogZnVuY3Rpb24oY20sIF9oZWFkLCBtb3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgaWYgKHZpbS52aXN1YWxCbG9jayAmJiBtb3Rpb25BcmdzLnNhbWVMaW5lKSB7XG4gICAgICAgICAgdmFyIHNlbCA9IHZpbS5zZWw7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIFBvcyhzZWwuYW5jaG9yLmxpbmUsIHNlbC5oZWFkLmNoKSksXG4gICAgICAgICAgICBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBQb3Moc2VsLmhlYWQubGluZSwgc2VsLmFuY2hvci5jaCkpXG4gICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gKFt2aW0uc2VsLmhlYWQsIHZpbS5zZWwuYW5jaG9yXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBqdW1wVG9NYXJrOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciBiZXN0ID0gaGVhZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3Rpb25BcmdzLnJlcGVhdDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1cnNvciA9IGJlc3Q7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIHZpbS5tYXJrcykge1xuICAgICAgICAgICAgaWYgKCFpc0xvd2VyQ2FzZShrZXkpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1hcmsgPSB2aW0ubWFya3Nba2V5XS5maW5kKCk7XG4gICAgICAgICAgICB2YXIgaXNXcm9uZ0RpcmVjdGlvbiA9IChtb3Rpb25BcmdzLmZvcndhcmQpID9cbiAgICAgICAgICAgICAgY3Vyc29ySXNCZWZvcmUobWFyaywgY3Vyc29yKSA6IGN1cnNvcklzQmVmb3JlKGN1cnNvciwgbWFyayk7XG5cbiAgICAgICAgICAgIGlmIChpc1dyb25nRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdGlvbkFyZ3MubGluZXdpc2UgJiYgKG1hcmsubGluZSA9PSBjdXJzb3IubGluZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlcXVhbCA9IGN1cnNvckVxdWFsKGN1cnNvciwgYmVzdCk7XG4gICAgICAgICAgICB2YXIgYmV0d2VlbiA9IChtb3Rpb25BcmdzLmZvcndhcmQpID9cbiAgICAgICAgICAgICAgY3Vyc29ySXNCZXR3ZWVuKGN1cnNvciwgbWFyaywgYmVzdCkgOlxuICAgICAgICAgICAgICBjdXJzb3JJc0JldHdlZW4oYmVzdCwgbWFyaywgY3Vyc29yKTtcblxuICAgICAgICAgICAgaWYgKGVxdWFsIHx8IGJldHdlZW4pIHtcbiAgICAgICAgICAgICAgYmVzdCA9IG1hcms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdGlvbkFyZ3MubGluZXdpc2UpIHtcbiAgICAgICAgICAvLyBWaW0gcGxhY2VzIHRoZSBjdXJzb3Igb24gdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBvZlxuICAgICAgICAgIC8vIHRoZSBsaW5lIGlmIHRoZXJlIGlzIG9uZSwgZWxzZSBpdCBwbGFjZXMgdGhlIGN1cnNvciBhdCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIGxpbmUsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBhIG1hcmsgd2FzIGZvdW5kLlxuICAgICAgICAgIGJlc3QgPSBQb3MoYmVzdC5saW5lLCBmaW5kRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLmdldExpbmUoYmVzdC5saW5lKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0O1xuICAgICAgfSxcbiAgICAgIG1vdmVCeUNoYXJhY3RlcnM6IGZ1bmN0aW9uKF9jbSwgaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgICB2YXIgY3VyID0gaGVhZDtcbiAgICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgICB2YXIgY2ggPSBtb3Rpb25BcmdzLmZvcndhcmQgPyBjdXIuY2ggKyByZXBlYXQgOiBjdXIuY2ggLSByZXBlYXQ7XG4gICAgICAgIHJldHVybiBQb3MoY3VyLmxpbmUsIGNoKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlQnlMaW5lczogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICB2YXIgY3VyID0gaGVhZDtcbiAgICAgICAgdmFyIGVuZENoID0gY3VyLmNoO1xuICAgICAgICAvLyBEZXBlbmRpbmcgd2hhdCBvdXIgbGFzdCBtb3Rpb24gd2FzLCB3ZSBtYXkgd2FudCB0byBkbyBkaWZmZXJlbnRcbiAgICAgICAgLy8gdGhpbmdzLiBJZiBvdXIgbGFzdCBtb3Rpb24gd2FzIG1vdmluZyB2ZXJ0aWNhbGx5LCB3ZSB3YW50IHRvXG4gICAgICAgIC8vIHByZXNlcnZlIHRoZSBIUG9zIGZyb20gb3VyIGxhc3QgaG9yaXpvbnRhbCBtb3ZlLiAgSWYgb3VyIGxhc3QgbW90aW9uXG4gICAgICAgIC8vIHdhcyBnb2luZyB0byB0aGUgZW5kIG9mIGEgbGluZSwgbW92aW5nIHZlcnRpY2FsbHkgd2Ugc2hvdWxkIGdvIHRvXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIGxpbmUsIGV0Yy5cbiAgICAgICAgc3dpdGNoICh2aW0ubGFzdE1vdGlvbikge1xuICAgICAgICAgIGNhc2UgdGhpcy5tb3ZlQnlMaW5lczpcbiAgICAgICAgICBjYXNlIHRoaXMubW92ZUJ5RGlzcGxheUxpbmVzOlxuICAgICAgICAgIGNhc2UgdGhpcy5tb3ZlQnlTY3JvbGw6XG4gICAgICAgICAgY2FzZSB0aGlzLm1vdmVUb0NvbHVtbjpcbiAgICAgICAgICBjYXNlIHRoaXMubW92ZVRvRW9sOlxuICAgICAgICAgICAgZW5kQ2ggPSB2aW0ubGFzdEhQb3M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmltLmxhc3RIUG9zID0gZW5kQ2g7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0Kyhtb3Rpb25BcmdzLnJlcGVhdE9mZnNldHx8MCk7XG4gICAgICAgIHZhciBsaW5lID0gbW90aW9uQXJncy5mb3J3YXJkID8gY3VyLmxpbmUgKyByZXBlYXQgOiBjdXIubGluZSAtIHJlcGVhdDtcbiAgICAgICAgdmFyIGZpcnN0ID0gY20uZmlyc3RMaW5lKCk7XG4gICAgICAgIHZhciBsYXN0ID0gY20ubGFzdExpbmUoKTtcbiAgICAgICAgdmFyIHBvc1YgPSBjbS5maW5kUG9zVihjdXIsIChtb3Rpb25BcmdzLmZvcndhcmQgPyByZXBlYXQgOiAtcmVwZWF0KSwgJ2xpbmUnLCB2aW0ubGFzdEhTUG9zKTtcbiAgICAgICAgdmFyIGhhc01hcmtlZFRleHQgPSBtb3Rpb25BcmdzLmZvcndhcmQgPyBwb3NWLmxpbmUgPiBsaW5lIDogcG9zVi5saW5lIDwgbGluZTtcbiAgICAgICAgaWYgKGhhc01hcmtlZFRleHQpIHtcbiAgICAgICAgICBsaW5lID0gcG9zVi5saW5lO1xuICAgICAgICAgIGVuZENoID0gcG9zVi5jaDtcbiAgICAgICAgfVxuICAgICAgICAvLyBWaW0gZ28gdG8gbGluZSBiZWdpbiBvciBsaW5lIGVuZCB3aGVuIGN1cnNvciBhdCBmaXJzdC9sYXN0IGxpbmUgYW5kXG4gICAgICAgIC8vIG1vdmUgdG8gcHJldmlvdXMvbmV4dCBsaW5lIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgaWYgKGxpbmUgPCBmaXJzdCAmJiBjdXIubGluZSA9PSBmaXJzdCl7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubW92ZVRvU3RhcnRPZkxpbmUoY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGluZSA+IGxhc3QgJiYgY3VyLmxpbmUgPT0gbGFzdCl7XG4gICAgICAgICAgICByZXR1cm4gbW92ZVRvRW9sKGNtLCBoZWFkLCBtb3Rpb25BcmdzLCB2aW0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3Rpb25BcmdzLnRvRmlyc3RDaGFyKXtcbiAgICAgICAgICBlbmRDaD1maW5kRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLmdldExpbmUobGluZSkpO1xuICAgICAgICAgIHZpbS5sYXN0SFBvcyA9IGVuZENoO1xuICAgICAgICB9XG4gICAgICAgIHZpbS5sYXN0SFNQb3MgPSBjbS5jaGFyQ29vcmRzKFBvcyhsaW5lLCBlbmRDaCksJ2RpdicpLmxlZnQ7XG4gICAgICAgIHJldHVybiBQb3MobGluZSwgZW5kQ2gpO1xuICAgICAgfSxcbiAgICAgIG1vdmVCeURpc3BsYXlMaW5lczogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICB2YXIgY3VyID0gaGVhZDtcbiAgICAgICAgc3dpdGNoICh2aW0ubGFzdE1vdGlvbikge1xuICAgICAgICAgIGNhc2UgdGhpcy5tb3ZlQnlEaXNwbGF5TGluZXM6XG4gICAgICAgICAgY2FzZSB0aGlzLm1vdmVCeVNjcm9sbDpcbiAgICAgICAgICBjYXNlIHRoaXMubW92ZUJ5TGluZXM6XG4gICAgICAgICAgY2FzZSB0aGlzLm1vdmVUb0NvbHVtbjpcbiAgICAgICAgICBjYXNlIHRoaXMubW92ZVRvRW9sOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZpbS5sYXN0SFNQb3MgPSBjbS5jaGFyQ29vcmRzKGN1ciwnZGl2JykubGVmdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVwZWF0ID0gbW90aW9uQXJncy5yZXBlYXQ7XG4gICAgICAgIHZhciByZXM9Y20uZmluZFBvc1YoY3VyLChtb3Rpb25BcmdzLmZvcndhcmQgPyByZXBlYXQgOiAtcmVwZWF0KSwnbGluZScsdmltLmxhc3RIU1Bvcyk7XG4gICAgICAgIGlmIChyZXMuaGl0U2lkZSkge1xuICAgICAgICAgIGlmIChtb3Rpb25BcmdzLmZvcndhcmQpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Q2hhckNvb3JkcyA9IGNtLmNoYXJDb29yZHMocmVzLCAnZGl2Jyk7XG4gICAgICAgICAgICB2YXIgZ29hbENvb3JkcyA9IHsgdG9wOiBsYXN0Q2hhckNvb3Jkcy50b3AgKyA4LCBsZWZ0OiB2aW0ubGFzdEhTUG9zIH07XG4gICAgICAgICAgICB2YXIgcmVzID0gY20uY29vcmRzQ2hhcihnb2FsQ29vcmRzLCAnZGl2Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXNDb29yZHMgPSBjbS5jaGFyQ29vcmRzKFBvcyhjbS5maXJzdExpbmUoKSwgMCksICdkaXYnKTtcbiAgICAgICAgICAgIHJlc0Nvb3Jkcy5sZWZ0ID0gdmltLmxhc3RIU1BvcztcbiAgICAgICAgICAgIHJlcyA9IGNtLmNvb3Jkc0NoYXIocmVzQ29vcmRzLCAnZGl2Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpbS5sYXN0SFBvcyA9IHJlcy5jaDtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0sXG4gICAgICBtb3ZlQnlQYWdlOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgICAvLyBDb2RlTWlycm9yIG9ubHkgZXhwb3NlcyBmdW5jdGlvbnMgdGhhdCBtb3ZlIHRoZSBjdXJzb3IgcGFnZSBkb3duLCBzb1xuICAgICAgICAvLyBkb2luZyB0aGlzIGJhZCBoYWNrIHRvIG1vdmUgdGhlIGN1cnNvciBhbmQgbW92ZSBpdCBiYWNrLiBldmFsSW5wdXRcbiAgICAgICAgLy8gd2lsbCBtb3ZlIHRoZSBjdXJzb3IgdG8gd2hlcmUgaXQgc2hvdWxkIGJlIGluIHRoZSBlbmQuXG4gICAgICAgIHZhciBjdXJTdGFydCA9IGhlYWQ7XG4gICAgICAgIHZhciByZXBlYXQgPSBtb3Rpb25BcmdzLnJlcGVhdDtcbiAgICAgICAgcmV0dXJuIGNtLmZpbmRQb3NWKGN1clN0YXJ0LCAobW90aW9uQXJncy5mb3J3YXJkID8gcmVwZWF0IDogLXJlcGVhdCksICdwYWdlJyk7XG4gICAgICB9LFxuICAgICAgbW92ZUJ5UGFyYWdyYXBoOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgICB2YXIgZGlyID0gbW90aW9uQXJncy5mb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICByZXR1cm4gZmluZFBhcmFncmFwaChjbSwgaGVhZCwgbW90aW9uQXJncy5yZXBlYXQsIGRpcik7XG4gICAgICB9LFxuICAgICAgbW92ZUJ5U2VudGVuY2U6IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICAgIHZhciBkaXIgPSBtb3Rpb25BcmdzLmZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgIHJldHVybiBmaW5kU2VudGVuY2UoY20sIGhlYWQsIG1vdGlvbkFyZ3MucmVwZWF0LCBkaXIpO1xuICAgICAgfSxcbiAgICAgIG1vdmVCeVNjcm9sbDogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICB2YXIgc2Nyb2xsYm94ID0gY20uZ2V0U2Nyb2xsSW5mbygpO1xuICAgICAgICB2YXIgY3VyRW5kID0gbnVsbDtcbiAgICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgICBpZiAoIXJlcGVhdCkge1xuICAgICAgICAgIHJlcGVhdCA9IHNjcm9sbGJveC5jbGllbnRIZWlnaHQgLyAoMiAqIGNtLmRlZmF1bHRUZXh0SGVpZ2h0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnID0gY20uY2hhckNvb3JkcyhoZWFkLCAnbG9jYWwnKTtcbiAgICAgICAgbW90aW9uQXJncy5yZXBlYXQgPSByZXBlYXQ7XG4gICAgICAgIHZhciBjdXJFbmQgPSBtb3Rpb25zLm1vdmVCeURpc3BsYXlMaW5lcyhjbSwgaGVhZCwgbW90aW9uQXJncywgdmltKTtcbiAgICAgICAgaWYgKCFjdXJFbmQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVzdCA9IGNtLmNoYXJDb29yZHMoY3VyRW5kLCAnbG9jYWwnKTtcbiAgICAgICAgY20uc2Nyb2xsVG8obnVsbCwgc2Nyb2xsYm94LnRvcCArIGRlc3QudG9wIC0gb3JpZy50b3ApO1xuICAgICAgICByZXR1cm4gY3VyRW5kO1xuICAgICAgfSxcbiAgICAgIG1vdmVCeVdvcmRzOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgICByZXR1cm4gbW92ZVRvV29yZChjbSwgaGVhZCwgbW90aW9uQXJncy5yZXBlYXQsICEhbW90aW9uQXJncy5mb3J3YXJkLFxuICAgICAgICAgICAgISFtb3Rpb25BcmdzLndvcmRFbmQsICEhbW90aW9uQXJncy5iaWdXb3JkKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlVGlsbENoYXJhY3RlcjogZnVuY3Rpb24oY20sIF9oZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICAgIHZhciByZXBlYXQgPSBtb3Rpb25BcmdzLnJlcGVhdDtcbiAgICAgICAgdmFyIGN1ckVuZCA9IG1vdmVUb0NoYXJhY3RlcihjbSwgcmVwZWF0LCBtb3Rpb25BcmdzLmZvcndhcmQsXG4gICAgICAgICAgICBtb3Rpb25BcmdzLnNlbGVjdGVkQ2hhcmFjdGVyKTtcbiAgICAgICAgdmFyIGluY3JlbWVudCA9IG1vdGlvbkFyZ3MuZm9yd2FyZCA/IC0xIDogMTtcbiAgICAgICAgcmVjb3JkTGFzdENoYXJhY3RlclNlYXJjaChpbmNyZW1lbnQsIG1vdGlvbkFyZ3MpO1xuICAgICAgICBpZiAoIWN1ckVuZCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGN1ckVuZC5jaCArPSBpbmNyZW1lbnQ7XG4gICAgICAgIHJldHVybiBjdXJFbmQ7XG4gICAgICB9LFxuICAgICAgbW92ZVRvQ2hhcmFjdGVyOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncykge1xuICAgICAgICB2YXIgcmVwZWF0ID0gbW90aW9uQXJncy5yZXBlYXQ7XG4gICAgICAgIHJlY29yZExhc3RDaGFyYWN0ZXJTZWFyY2goMCwgbW90aW9uQXJncyk7XG4gICAgICAgIHJldHVybiBtb3ZlVG9DaGFyYWN0ZXIoY20sIHJlcGVhdCwgbW90aW9uQXJncy5mb3J3YXJkLFxuICAgICAgICAgICAgbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlcikgfHwgaGVhZDtcbiAgICAgIH0sXG4gICAgICBtb3ZlVG9TeW1ib2w6IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzKSB7XG4gICAgICAgIHZhciByZXBlYXQgPSBtb3Rpb25BcmdzLnJlcGVhdDtcbiAgICAgICAgcmV0dXJuIGZpbmRTeW1ib2woY20sIHJlcGVhdCwgbW90aW9uQXJncy5mb3J3YXJkLFxuICAgICAgICAgICAgbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlcikgfHwgaGVhZDtcbiAgICAgIH0sXG4gICAgICBtb3ZlVG9Db2x1bW46IGZ1bmN0aW9uKGNtLCBoZWFkLCBtb3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgdmFyIHJlcGVhdCA9IG1vdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgICAvLyByZXBlYXQgaXMgZXF1aXZhbGVudCB0byB3aGljaCBjb2x1bW4gd2Ugd2FudCB0byBtb3ZlIHRvIVxuICAgICAgICB2aW0ubGFzdEhQb3MgPSByZXBlYXQgLSAxO1xuICAgICAgICB2aW0ubGFzdEhTUG9zID0gY20uY2hhckNvb3JkcyhoZWFkLCdkaXYnKS5sZWZ0O1xuICAgICAgICByZXR1cm4gbW92ZVRvQ29sdW1uKGNtLCByZXBlYXQpO1xuICAgICAgfSxcbiAgICAgIG1vdmVUb0VvbDogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICByZXR1cm4gbW92ZVRvRW9sKGNtLCBoZWFkLCBtb3Rpb25BcmdzLCB2aW0sIGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXI6IGZ1bmN0aW9uKGNtLCBoZWFkKSB7XG4gICAgICAgIC8vIEdvIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZSB3aGVyZSB0aGUgdGV4dCBiZWdpbnMsIG9yIHRoZSBlbmQgZm9yXG4gICAgICAgIC8vIHdoaXRlc3BhY2Utb25seSBsaW5lc1xuICAgICAgICB2YXIgY3Vyc29yID0gaGVhZDtcbiAgICAgICAgcmV0dXJuIFBvcyhjdXJzb3IubGluZSxcbiAgICAgICAgICAgICAgICAgICBmaW5kRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLmdldExpbmUoY3Vyc29yLmxpbmUpKSk7XG4gICAgICB9LFxuICAgICAgbW92ZVRvTWF0Y2hlZFN5bWJvbDogZnVuY3Rpb24oY20sIGhlYWQpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IGhlYWQ7XG4gICAgICAgIHZhciBsaW5lID0gY3Vyc29yLmxpbmU7XG4gICAgICAgIHZhciBjaCA9IGN1cnNvci5jaDtcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gY20uZ2V0TGluZShsaW5lKTtcbiAgICAgICAgdmFyIHN5bWJvbDtcbiAgICAgICAgZm9yICg7IGNoIDwgbGluZVRleHQubGVuZ3RoOyBjaCsrKSB7XG4gICAgICAgICAgc3ltYm9sID0gbGluZVRleHQuY2hhckF0KGNoKTtcbiAgICAgICAgICBpZiAoc3ltYm9sICYmIGlzTWF0Y2hhYmxlU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGNtLmdldFRva2VuVHlwZUF0KFBvcyhsaW5lLCBjaCArIDEpKTtcbiAgICAgICAgICAgIGlmIChzdHlsZSAhPT0gXCJzdHJpbmdcIiAmJiBzdHlsZSAhPT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA8IGxpbmVUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIE9ubHkgaW5jbHVkZSBhbmdsZSBicmFja2V0cyBpbiBhbmFseXNpcyBpZiB0aGV5IGFyZSBiZWluZyBtYXRjaGVkLlxuICAgICAgICAgIHZhciByZSA9IChjaCA9PT0gJzwnIHx8IGNoID09PSAnPicpID8gL1soKXt9W1xcXTw+XS8gOiAvWygpe31bXFxdXS87XG4gICAgICAgICAgdmFyIG1hdGNoZWQgPSBjbS5maW5kTWF0Y2hpbmdCcmFja2V0KFBvcyhsaW5lLCBjaCksIHticmFja2V0UmVnZXg6IHJlfSk7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoZWQudG87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1vdmVUb1N0YXJ0T2ZMaW5lOiBmdW5jdGlvbihfY20sIGhlYWQpIHtcbiAgICAgICAgcmV0dXJuIFBvcyhoZWFkLmxpbmUsIDApO1xuICAgICAgfSxcbiAgICAgIG1vdmVUb0xpbmVPckVkZ2VPZkRvY3VtZW50OiBmdW5jdGlvbihjbSwgX2hlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIGxpbmVOdW0gPSBtb3Rpb25BcmdzLmZvcndhcmQgPyBjbS5sYXN0TGluZSgpIDogY20uZmlyc3RMaW5lKCk7XG4gICAgICAgIGlmIChtb3Rpb25BcmdzLnJlcGVhdElzRXhwbGljaXQpIHtcbiAgICAgICAgICBsaW5lTnVtID0gbW90aW9uQXJncy5yZXBlYXQgLSBjbS5nZXRPcHRpb24oJ2ZpcnN0TGluZU51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQb3MobGluZU51bSxcbiAgICAgICAgICAgICAgICAgICBmaW5kRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLmdldExpbmUobGluZU51bSkpKTtcbiAgICAgIH0sXG4gICAgICB0ZXh0T2JqZWN0TWFuaXB1bGF0aW9uOiBmdW5jdGlvbihjbSwgaGVhZCwgbW90aW9uQXJncywgdmltKSB7XG4gICAgICAgIC8vIFRPRE86IGxvdHMgb2YgcG9zc2libGUgZXhjZXB0aW9ucyB0aGF0IGNhbiBiZSB0aHJvd24gaGVyZS4gVHJ5IGRhKFxuICAgICAgICAvLyAgICAgb3V0c2lkZSBvZiBhICgpIGJsb2NrLlxuICAgICAgICB2YXIgbWlycm9yZWRQYWlycyA9IHsnKCc6ICcpJywgJyknOiAnKCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7JzogJ30nLCAnfSc6ICd7JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1snOiAnXScsICddJzogJ1snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPCc6ICc+JywgJz4nOiAnPCd9O1xuICAgICAgICB2YXIgc2VsZlBhaXJlZCA9IHsnXFwnJzogdHJ1ZSwgJ1wiJzogdHJ1ZSwgJ2AnOiB0cnVlfTtcblxuICAgICAgICB2YXIgY2hhcmFjdGVyID0gbW90aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlcjtcbiAgICAgICAgLy8gJ2InIHJlZmVycyB0byAgJygpJyBibG9jay5cbiAgICAgICAgLy8gJ0InIHJlZmVycyB0byAgJ3t9JyBibG9jay5cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PSAnYicpIHtcbiAgICAgICAgICBjaGFyYWN0ZXIgPSAnKCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09ICdCJykge1xuICAgICAgICAgIGNoYXJhY3RlciA9ICd7JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY2x1c2l2ZSBpcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgYW5kIGlcbiAgICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiB1c2luZyB0aGUgYWRkaXRpb25hbCB0ZXh0IG9iamVjdCBtYXAgdG8gcGVyZm9ybSB0ZXh0XG4gICAgICAgIC8vICAgICBvYmplY3Qgb3BlcmF0aW9ucywgbWVyZ2UgdGhlIG1hcCBpbnRvIHRoZSBkZWZhdWx0S2V5TWFwIGFuZCB1c2VcbiAgICAgICAgLy8gICAgIG1vdGlvbkFyZ3MgdG8gZGVmaW5lIGJlaGF2aW9yLiBEZWZpbmUgc2VwYXJhdGUgZW50cmllcyBmb3IgJ2F3JyxcbiAgICAgICAgLy8gICAgICdpdycsICdhWycsICdpWycsIGV0Yy5cbiAgICAgICAgdmFyIGluY2x1c2l2ZSA9ICFtb3Rpb25BcmdzLnRleHRPYmplY3RJbm5lcjtcblxuICAgICAgICB2YXIgdG1wO1xuICAgICAgICBpZiAobWlycm9yZWRQYWlyc1tjaGFyYWN0ZXJdKSB7XG4gICAgICAgICAgdG1wID0gc2VsZWN0Q29tcGFuaW9uT2JqZWN0KGNtLCBoZWFkLCBjaGFyYWN0ZXIsIGluY2x1c2l2ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZlBhaXJlZFtjaGFyYWN0ZXJdKSB7XG4gICAgICAgICAgdG1wID0gZmluZEJlZ2lubmluZ0FuZEVuZChjbSwgaGVhZCwgY2hhcmFjdGVyLCBpbmNsdXNpdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJ1cnKSB7XG4gICAgICAgICAgdG1wID0gZXhwYW5kV29yZFVuZGVyQ3Vyc29yKGNtLCBpbmNsdXNpdmUsIHRydWUgLyoqIGZvcndhcmQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgLyoqIGJpZ1dvcmQgKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJ3cnKSB7XG4gICAgICAgICAgdG1wID0gZXhwYW5kV29yZFVuZGVyQ3Vyc29yKGNtLCBpbmNsdXNpdmUsIHRydWUgLyoqIGZvcndhcmQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIC8qKiBiaWdXb3JkICovKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09ICdwJykge1xuICAgICAgICAgIHRtcCA9IGZpbmRQYXJhZ3JhcGgoY20sIGhlYWQsIG1vdGlvbkFyZ3MucmVwZWF0LCAwLCBpbmNsdXNpdmUpO1xuICAgICAgICAgIG1vdGlvbkFyZ3MubGluZXdpc2UgPSB0cnVlO1xuICAgICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgICAgaWYgKCF2aW0udmlzdWFsTGluZSkgeyB2aW0udmlzdWFsTGluZSA9IHRydWU7IH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yQXJncyA9IHZpbS5pbnB1dFN0YXRlLm9wZXJhdG9yQXJncztcbiAgICAgICAgICAgIGlmIChvcGVyYXRvckFyZ3MpIHsgb3BlcmF0b3JBcmdzLmxpbmV3aXNlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdG1wLmVuZC5saW5lLS07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gJ3QnKSB7XG4gICAgICAgICAgdG1wID0gZXhwYW5kVGFnVW5kZXJDdXJzb3IoY20sIGhlYWQsIGluY2x1c2l2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gdGV4dCBvYmplY3QgZGVmaW5lZCBmb3IgdGhpcywgZG9uJ3QgbW92ZS5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY20uc3RhdGUudmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICByZXR1cm4gW3RtcC5zdGFydCwgdG1wLmVuZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGFuZFNlbGVjdGlvbihjbSwgdG1wLnN0YXJ0LCB0bXAuZW5kKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgcmVwZWF0TGFzdENoYXJhY3RlclNlYXJjaDogZnVuY3Rpb24oY20sIGhlYWQsIG1vdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIGxhc3RTZWFyY2ggPSB2aW1HbG9iYWxTdGF0ZS5sYXN0Q2hhcmFjdGVyU2VhcmNoO1xuICAgICAgICB2YXIgcmVwZWF0ID0gbW90aW9uQXJncy5yZXBlYXQ7XG4gICAgICAgIHZhciBmb3J3YXJkID0gbW90aW9uQXJncy5mb3J3YXJkID09PSBsYXN0U2VhcmNoLmZvcndhcmQ7XG4gICAgICAgIHZhciBpbmNyZW1lbnQgPSAobGFzdFNlYXJjaC5pbmNyZW1lbnQgPyAxIDogMCkgKiAoZm9yd2FyZCA/IC0xIDogMSk7XG4gICAgICAgIGNtLm1vdmVIKC1pbmNyZW1lbnQsICdjaGFyJyk7XG4gICAgICAgIG1vdGlvbkFyZ3MuaW5jbHVzaXZlID0gZm9yd2FyZCA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgdmFyIGN1ckVuZCA9IG1vdmVUb0NoYXJhY3RlcihjbSwgcmVwZWF0LCBmb3J3YXJkLCBsYXN0U2VhcmNoLnNlbGVjdGVkQ2hhcmFjdGVyKTtcbiAgICAgICAgaWYgKCFjdXJFbmQpIHtcbiAgICAgICAgICBjbS5tb3ZlSChpbmNyZW1lbnQsICdjaGFyJyk7XG4gICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VyRW5kLmNoICs9IGluY3JlbWVudDtcbiAgICAgICAgcmV0dXJuIGN1ckVuZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGVmaW5lTW90aW9uKG5hbWUsIGZuKSB7XG4gICAgICBtb3Rpb25zW25hbWVdID0gZm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsbEFycmF5KHZhbCwgdGltZXMpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZXM7IGkrKykge1xuICAgICAgICBhcnIucHVzaCh2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gb3BlcmF0b3IgYWN0cyBvbiBhIHRleHQgc2VsZWN0aW9uLiBJdCByZWNlaXZlcyB0aGUgbGlzdCBvZiBzZWxlY3Rpb25zXG4gICAgICogYXMgaW5wdXQuIFRoZSBjb3JyZXNwb25kaW5nIENvZGVNaXJyb3Igc2VsZWN0aW9uIGlzIGd1YXJhbnRlZWQgdG9cbiAgICAqIG1hdGNoIHRoZSBpbnB1dCBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgdmFyIG9wZXJhdG9ycyA9IHtcbiAgICAgIGNoYW5nZTogZnVuY3Rpb24oY20sIGFyZ3MsIHJhbmdlcykge1xuICAgICAgICB2YXIgZmluYWxIZWFkLCB0ZXh0O1xuICAgICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgICB2YXIgYW5jaG9yID0gcmFuZ2VzWzBdLmFuY2hvcixcbiAgICAgICAgICAgIGhlYWQgPSByYW5nZXNbMF0uaGVhZDtcbiAgICAgICAgaWYgKCF2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIHRleHQgPSBjbS5nZXRSYW5nZShhbmNob3IsIGhlYWQpO1xuICAgICAgICAgIHZhciBsYXN0U3RhdGUgPSB2aW0ubGFzdEVkaXRJbnB1dFN0YXRlIHx8IHt9O1xuICAgICAgICAgIGlmIChsYXN0U3RhdGUubW90aW9uID09IFwibW92ZUJ5V29yZHNcIiAmJiAhaXNXaGl0ZVNwYWNlU3RyaW5nKHRleHQpKSB7XG4gICAgICAgICAgICAvLyBFeGNsdWRlIHRyYWlsaW5nIHdoaXRlc3BhY2UgaWYgdGhlIHJhbmdlIGlzIG5vdCBhbGwgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIHZhciBtYXRjaCA9ICgvXFxzKyQvKS5leGVjKHRleHQpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIGxhc3RTdGF0ZS5tb3Rpb25BcmdzICYmIGxhc3RTdGF0ZS5tb3Rpb25BcmdzLmZvcndhcmQpIHtcbiAgICAgICAgICAgICAgaGVhZCA9IG9mZnNldEN1cnNvcihoZWFkLCAwLCAtIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0gbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHByZXZMaW5lRW5kID0gbmV3IFBvcyhhbmNob3IubGluZSAtIDEsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICAgIHZhciB3YXNMYXN0TGluZSA9IGNtLmZpcnN0TGluZSgpID09IGNtLmxhc3RMaW5lKCk7XG4gICAgICAgICAgaWYgKGhlYWQubGluZSA+IGNtLmxhc3RMaW5lKCkgJiYgYXJncy5saW5ld2lzZSAmJiAhd2FzTGFzdExpbmUpIHtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSgnJywgcHJldkxpbmVFbmQsIGhlYWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoJycsIGFuY2hvciwgaGVhZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhcmdzLmxpbmV3aXNlKSB7XG4gICAgICAgICAgICAvLyBQdXNoIHRoZSBuZXh0IGxpbmUgYmFjayBkb3duLCBpZiB0aGVyZSBpcyBhIG5leHQgbGluZS5cbiAgICAgICAgICAgIGlmICghd2FzTGFzdExpbmUpIHtcbiAgICAgICAgICAgICAgY20uc2V0Q3Vyc29yKHByZXZMaW5lRW5kKTtcbiAgICAgICAgICAgICAgQ29kZU1pcnJvci5jb21tYW5kcy5uZXdsaW5lQW5kSW5kZW50KGNtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjdXJzb3IgZW5kcyB1cCBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICAgICAgICAgYW5jaG9yLmNoID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmluYWxIZWFkID0gYW5jaG9yO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MuZnVsbExpbmUpIHtcbiAgICAgICAgICAgIGhlYWQuY2ggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgaGVhZC5saW5lLS07XG4gICAgICAgICAgICBjbS5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKVxuICAgICAgICAgICAgdGV4dCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiKTtcbiAgICAgICAgICAgIGZpbmFsSGVhZCA9IGFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gZmlsbEFycmF5KCcnLCByYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhyZXBsYWNlbWVudCk7XG4gICAgICAgICAgZmluYWxIZWFkID0gY3Vyc29yTWluKHJhbmdlc1swXS5oZWFkLCByYW5nZXNbMF0uYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucHVzaFRleHQoXG4gICAgICAgICAgICBhcmdzLnJlZ2lzdGVyTmFtZSwgJ2NoYW5nZScsIHRleHQsXG4gICAgICAgICAgICBhcmdzLmxpbmV3aXNlLCByYW5nZXMubGVuZ3RoID4gMSk7XG4gICAgICAgIGFjdGlvbnMuZW50ZXJJbnNlcnRNb2RlKGNtLCB7aGVhZDogZmluYWxIZWFkfSwgY20uc3RhdGUudmltKTtcbiAgICAgIH0sXG4gICAgICAvLyBkZWxldGUgaXMgYSBqYXZhc2NyaXB0IGtleXdvcmQuXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oY20sIGFyZ3MsIHJhbmdlcykge1xuICAgICAgICB2YXIgZmluYWxIZWFkLCB0ZXh0O1xuICAgICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgICBpZiAoIXZpbS52aXN1YWxCbG9jaykge1xuICAgICAgICAgIHZhciBhbmNob3IgPSByYW5nZXNbMF0uYW5jaG9yLFxuICAgICAgICAgICAgICBoZWFkID0gcmFuZ2VzWzBdLmhlYWQ7XG4gICAgICAgICAgaWYgKGFyZ3MubGluZXdpc2UgJiZcbiAgICAgICAgICAgICAgaGVhZC5saW5lICE9IGNtLmZpcnN0TGluZSgpICYmXG4gICAgICAgICAgICAgIGFuY2hvci5saW5lID09IGNtLmxhc3RMaW5lKCkgJiZcbiAgICAgICAgICAgICAgYW5jaG9yLmxpbmUgPT0gaGVhZC5saW5lIC0gMSkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBkZCBvbiBsYXN0IGxpbmUgKGFuZCBmaXJzdCBsaW5lKS5cbiAgICAgICAgICAgIGlmIChhbmNob3IubGluZSA9PSBjbS5maXJzdExpbmUoKSkge1xuICAgICAgICAgICAgICBhbmNob3IuY2ggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5jaG9yID0gUG9zKGFuY2hvci5saW5lIC0gMSwgbGluZUxlbmd0aChjbSwgYW5jaG9yLmxpbmUgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHQgPSBjbS5nZXRSYW5nZShhbmNob3IsIGhlYWQpO1xuICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSgnJywgYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgICBmaW5hbEhlYWQgPSBhbmNob3I7XG4gICAgICAgICAgaWYgKGFyZ3MubGluZXdpc2UpIHtcbiAgICAgICAgICAgIGZpbmFsSGVhZCA9IG1vdGlvbnMubW92ZVRvRmlyc3ROb25XaGl0ZVNwYWNlQ2hhcmFjdGVyKGNtLCBhbmNob3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gZmlsbEFycmF5KCcnLCByYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhyZXBsYWNlbWVudCk7XG4gICAgICAgICAgZmluYWxIZWFkID0gcmFuZ2VzWzBdLmFuY2hvcjtcbiAgICAgICAgfVxuICAgICAgICB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucHVzaFRleHQoXG4gICAgICAgICAgICBhcmdzLnJlZ2lzdGVyTmFtZSwgJ2RlbGV0ZScsIHRleHQsXG4gICAgICAgICAgICBhcmdzLmxpbmV3aXNlLCB2aW0udmlzdWFsQmxvY2spO1xuICAgICAgICByZXR1cm4gY2xpcEN1cnNvclRvQ29udGVudChjbSwgZmluYWxIZWFkKTtcbiAgICAgIH0sXG4gICAgICBpbmRlbnQ6IGZ1bmN0aW9uKGNtLCBhcmdzLCByYW5nZXMpIHtcbiAgICAgICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICAgICAgdmFyIHN0YXJ0TGluZSA9IHJhbmdlc1swXS5hbmNob3IubGluZTtcbiAgICAgICAgdmFyIGVuZExpbmUgPSB2aW0udmlzdWFsQmxvY2sgP1xuICAgICAgICAgIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0uYW5jaG9yLmxpbmUgOlxuICAgICAgICAgIHJhbmdlc1swXS5oZWFkLmxpbmU7XG4gICAgICAgIC8vIEluIHZpc3VhbCBtb2RlLCBuPiBzaGlmdHMgdGhlIHNlbGVjdGlvbiByaWdodCBuIHRpbWVzLCBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHNoaWZ0aW5nIG4gbGluZXMgcmlnaHQgb25jZS5cbiAgICAgICAgdmFyIHJlcGVhdCA9ICh2aW0udmlzdWFsTW9kZSkgPyBhcmdzLnJlcGVhdCA6IDE7XG4gICAgICAgIGlmIChhcmdzLmxpbmV3aXNlKSB7XG4gICAgICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIGRlbGV0ZSBhIG5ld2xpbmUgaXMgdG8gZGVsZXRlIHVudGlsIHRoZSBzdGFydCBvZlxuICAgICAgICAgIC8vIHRoZSBuZXh0IGxpbmUsIHNvIGluIGxpbmV3aXNlIG1vZGUgZXZhbElucHV0IHdpbGwgaW5jbHVkZSB0aGUgbmV4dFxuICAgICAgICAgIC8vIGxpbmUuIFdlIGRvbid0IHdhbnQgdGhpcyBpbiBpbmRlbnQsIHNvIHdlIGdvIGJhY2sgYSBsaW5lLlxuICAgICAgICAgIGVuZExpbmUtLTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwZWF0OyBqKyspIHtcbiAgICAgICAgICAgIGNtLmluZGVudExpbmUoaSwgYXJncy5pbmRlbnRSaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb3Rpb25zLm1vdmVUb0ZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbSwgcmFuZ2VzWzBdLmFuY2hvcik7XG4gICAgICB9LFxuICAgICAgaW5kZW50QXV0bzogZnVuY3Rpb24oY20sIF9hcmdzLCByYW5nZXMpIHtcbiAgICAgICAgY20uZXhlY0NvbW1hbmQoXCJpbmRlbnRBdXRvXCIpO1xuICAgICAgICByZXR1cm4gbW90aW9ucy5tb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20sIHJhbmdlc1swXS5hbmNob3IpO1xuICAgICAgfSxcbiAgICAgIGNoYW5nZUNhc2U6IGZ1bmN0aW9uKGNtLCBhcmdzLCByYW5nZXMsIG9sZEFuY2hvciwgbmV3SGVhZCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IGNtLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgdmFyIHN3YXBwZWQgPSBbXTtcbiAgICAgICAgdmFyIHRvTG93ZXIgPSBhcmdzLnRvTG93ZXI7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZWN0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciB0b1N3YXAgPSBzZWxlY3Rpb25zW2pdO1xuICAgICAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgICAgICAgaWYgKHRvTG93ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRleHQgPSB0b1N3YXAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRvTG93ZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdG9Td2FwLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9Td2FwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIgPSB0b1N3YXAuY2hhckF0KGkpO1xuICAgICAgICAgICAgICB0ZXh0ICs9IGlzVXBwZXJDYXNlKGNoYXJhY3RlcikgPyBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKSA6XG4gICAgICAgICAgICAgICAgICBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3dhcHBlZC5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKHN3YXBwZWQpO1xuICAgICAgICBpZiAoYXJncy5zaG91bGRNb3ZlQ3Vyc29yKXtcbiAgICAgICAgICByZXR1cm4gbmV3SGVhZDtcbiAgICAgICAgfSBlbHNlIGlmICghY20uc3RhdGUudmltLnZpc3VhbE1vZGUgJiYgYXJncy5saW5ld2lzZSAmJiByYW5nZXNbMF0uYW5jaG9yLmxpbmUgKyAxID09IHJhbmdlc1swXS5oZWFkLmxpbmUpIHtcbiAgICAgICAgICByZXR1cm4gbW90aW9ucy5tb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20sIG9sZEFuY2hvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJncy5saW5ld2lzZSl7XG4gICAgICAgICAgcmV0dXJuIG9sZEFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3Vyc29yTWluKHJhbmdlc1swXS5hbmNob3IsIHJhbmdlc1swXS5oZWFkKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHlhbms6IGZ1bmN0aW9uKGNtLCBhcmdzLCByYW5nZXMsIG9sZEFuY2hvcikge1xuICAgICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgICB2YXIgdGV4dCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB2YXIgZW5kUG9zID0gdmltLnZpc3VhbE1vZGVcbiAgICAgICAgICA/IGN1cnNvck1pbih2aW0uc2VsLmFuY2hvciwgdmltLnNlbC5oZWFkLCByYW5nZXNbMF0uaGVhZCwgcmFuZ2VzWzBdLmFuY2hvcilcbiAgICAgICAgICA6IG9sZEFuY2hvcjtcbiAgICAgICAgdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLnB1c2hUZXh0KFxuICAgICAgICAgICAgYXJncy5yZWdpc3Rlck5hbWUsICd5YW5rJyxcbiAgICAgICAgICAgIHRleHQsIGFyZ3MubGluZXdpc2UsIHZpbS52aXN1YWxCbG9jayk7XG4gICAgICAgIHJldHVybiBlbmRQb3M7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRlZmluZU9wZXJhdG9yKG5hbWUsIGZuKSB7XG4gICAgICBvcGVyYXRvcnNbbmFtZV0gPSBmbjtcbiAgICB9XG5cbiAgICB2YXIgYWN0aW9ucyA9IHtcbiAgICAgIGp1bXBMaXN0V2FsazogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcGVhdCA9IGFjdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgICB2YXIgZm9yd2FyZCA9IGFjdGlvbkFyZ3MuZm9yd2FyZDtcbiAgICAgICAgdmFyIGp1bXBMaXN0ID0gdmltR2xvYmFsU3RhdGUuanVtcExpc3Q7XG5cbiAgICAgICAgdmFyIG1hcmsgPSBqdW1wTGlzdC5tb3ZlKGNtLCBmb3J3YXJkID8gcmVwZWF0IDogLXJlcGVhdCk7XG4gICAgICAgIHZhciBtYXJrUG9zID0gbWFyayA/IG1hcmsuZmluZCgpIDogdW5kZWZpbmVkO1xuICAgICAgICBtYXJrUG9zID0gbWFya1BvcyA/IG1hcmtQb3MgOiBjbS5nZXRDdXJzb3IoKTtcbiAgICAgICAgY20uc2V0Q3Vyc29yKG1hcmtQb3MpO1xuICAgICAgfSxcbiAgICAgIHNjcm9sbDogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcGVhdCA9IGFjdGlvbkFyZ3MucmVwZWF0IHx8IDE7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gY20uZGVmYXVsdFRleHRIZWlnaHQoKTtcbiAgICAgICAgdmFyIHRvcCA9IGNtLmdldFNjcm9sbEluZm8oKS50b3A7XG4gICAgICAgIHZhciBkZWx0YSA9IGxpbmVIZWlnaHQgKiByZXBlYXQ7XG4gICAgICAgIHZhciBuZXdQb3MgPSBhY3Rpb25BcmdzLmZvcndhcmQgPyB0b3AgKyBkZWx0YSA6IHRvcCAtIGRlbHRhO1xuICAgICAgICB2YXIgY3Vyc29yID0gY29weUN1cnNvcihjbS5nZXRDdXJzb3IoKSk7XG4gICAgICAgIHZhciBjdXJzb3JDb29yZHMgPSBjbS5jaGFyQ29vcmRzKGN1cnNvciwgJ2xvY2FsJyk7XG4gICAgICAgIGlmIChhY3Rpb25BcmdzLmZvcndhcmQpIHtcbiAgICAgICAgICBpZiAobmV3UG9zID4gY3Vyc29yQ29vcmRzLnRvcCkge1xuICAgICAgICAgICAgIGN1cnNvci5saW5lICs9IChuZXdQb3MgLSBjdXJzb3JDb29yZHMudG9wKSAvIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgY3Vyc29yLmxpbmUgPSBNYXRoLmNlaWwoY3Vyc29yLmxpbmUpO1xuICAgICAgICAgICAgIGNtLnNldEN1cnNvcihjdXJzb3IpO1xuICAgICAgICAgICAgIGN1cnNvckNvb3JkcyA9IGNtLmNoYXJDb29yZHMoY3Vyc29yLCAnbG9jYWwnKTtcbiAgICAgICAgICAgICBjbS5zY3JvbGxUbyhudWxsLCBjdXJzb3JDb29yZHMudG9wKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIC8vIEN1cnNvciBzdGF5cyB3aXRoaW4gYm91bmRzLiAgSnVzdCByZXBvc2l0aW9uIHRoZSBzY3JvbGwgd2luZG93LlxuICAgICAgICAgICAgIGNtLnNjcm9sbFRvKG51bGwsIG5ld1Bvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdCb3R0b20gPSBuZXdQb3MgKyBjbS5nZXRTY3JvbGxJbmZvKCkuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgIGlmIChuZXdCb3R0b20gPCBjdXJzb3JDb29yZHMuYm90dG9tKSB7XG4gICAgICAgICAgICAgY3Vyc29yLmxpbmUgLT0gKGN1cnNvckNvb3Jkcy5ib3R0b20gLSBuZXdCb3R0b20pIC8gbGluZUhlaWdodDtcbiAgICAgICAgICAgICBjdXJzb3IubGluZSA9IE1hdGguZmxvb3IoY3Vyc29yLmxpbmUpO1xuICAgICAgICAgICAgIGNtLnNldEN1cnNvcihjdXJzb3IpO1xuICAgICAgICAgICAgIGN1cnNvckNvb3JkcyA9IGNtLmNoYXJDb29yZHMoY3Vyc29yLCAnbG9jYWwnKTtcbiAgICAgICAgICAgICBjbS5zY3JvbGxUbyhcbiAgICAgICAgICAgICAgICAgbnVsbCwgY3Vyc29yQ29vcmRzLmJvdHRvbSAtIGNtLmdldFNjcm9sbEluZm8oKS5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgLy8gQ3Vyc29yIHN0YXlzIHdpdGhpbiBib3VuZHMuICBKdXN0IHJlcG9zaXRpb24gdGhlIHNjcm9sbCB3aW5kb3cuXG4gICAgICAgICAgICAgY20uc2Nyb2xsVG8obnVsbCwgbmV3UG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzY3JvbGxUb0N1cnNvcjogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIGxpbmVOdW0gPSBjbS5nZXRDdXJzb3IoKS5saW5lO1xuICAgICAgICB2YXIgY2hhckNvb3JkcyA9IGNtLmNoYXJDb29yZHMoUG9zKGxpbmVOdW0sIDApLCAnbG9jYWwnKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNtLmdldFNjcm9sbEluZm8oKS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciB5ID0gY2hhckNvb3Jkcy50b3A7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gY2hhckNvb3Jkcy5ib3R0b20gLSB5O1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbkFyZ3MucG9zaXRpb24pIHtcbiAgICAgICAgICBjYXNlICdjZW50ZXInOiB5ID0geSAtIChoZWlnaHQgLyAyKSArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdib3R0b20nOiB5ID0geSAtIGhlaWdodCArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjbS5zY3JvbGxUbyhudWxsLCB5KTtcbiAgICAgIH0sXG4gICAgICByZXBsYXlNYWNybzogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICB2YXIgcmVnaXN0ZXJOYW1lID0gYWN0aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlcjtcbiAgICAgICAgdmFyIHJlcGVhdCA9IGFjdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgICAgaWYgKHJlZ2lzdGVyTmFtZSA9PSAnQCcpIHtcbiAgICAgICAgICByZWdpc3Rlck5hbWUgPSBtYWNyb01vZGVTdGF0ZS5sYXRlc3RSZWdpc3RlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYWNyb01vZGVTdGF0ZS5sYXRlc3RSZWdpc3RlciA9IHJlZ2lzdGVyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShyZXBlYXQtLSl7XG4gICAgICAgICAgZXhlY3V0ZU1hY3JvUmVnaXN0ZXIoY20sIHZpbSwgbWFjcm9Nb2RlU3RhdGUsIHJlZ2lzdGVyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbnRlck1hY3JvUmVjb3JkTW9kZTogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MpIHtcbiAgICAgICAgdmFyIG1hY3JvTW9kZVN0YXRlID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGU7XG4gICAgICAgIHZhciByZWdpc3Rlck5hbWUgPSBhY3Rpb25BcmdzLnNlbGVjdGVkQ2hhcmFjdGVyO1xuICAgICAgICBpZiAodmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmlzVmFsaWRSZWdpc3RlcihyZWdpc3Rlck5hbWUpKSB7XG4gICAgICAgICAgbWFjcm9Nb2RlU3RhdGUuZW50ZXJNYWNyb1JlY29yZE1vZGUoY20sIHJlZ2lzdGVyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2dnbGVPdmVyd3JpdGU6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIGlmICghY20uc3RhdGUub3ZlcndyaXRlKSB7XG4gICAgICAgICAgY20udG9nZ2xlT3ZlcndyaXRlKHRydWUpO1xuICAgICAgICAgIGNtLnNldE9wdGlvbigna2V5TWFwJywgJ3ZpbS1yZXBsYWNlJyk7XG4gICAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcInJlcGxhY2VcIn0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNtLnRvZ2dsZU92ZXJ3cml0ZShmYWxzZSk7XG4gICAgICAgICAgY20uc2V0T3B0aW9uKCdrZXlNYXAnLCAndmltLWluc2VydCcpO1xuICAgICAgICAgIENvZGVNaXJyb3Iuc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJpbnNlcnRcIn0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW50ZXJJbnNlcnRNb2RlOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICAgIGlmIChjbS5nZXRPcHRpb24oJ3JlYWRPbmx5JykpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZpbS5pbnNlcnRNb2RlID0gdHJ1ZTtcbiAgICAgICAgdmltLmluc2VydE1vZGVSZXBlYXQgPSBhY3Rpb25BcmdzICYmIGFjdGlvbkFyZ3MucmVwZWF0IHx8IDE7XG4gICAgICAgIHZhciBpbnNlcnRBdCA9IChhY3Rpb25BcmdzKSA/IGFjdGlvbkFyZ3MuaW5zZXJ0QXQgOiBudWxsO1xuICAgICAgICB2YXIgc2VsID0gdmltLnNlbDtcbiAgICAgICAgdmFyIGhlYWQgPSBhY3Rpb25BcmdzLmhlYWQgfHwgY20uZ2V0Q3Vyc29yKCdoZWFkJyk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBjbS5saXN0U2VsZWN0aW9ucygpLmxlbmd0aDtcbiAgICAgICAgaWYgKGluc2VydEF0ID09ICdlb2wnKSB7XG4gICAgICAgICAgaGVhZCA9IFBvcyhoZWFkLmxpbmUsIGxpbmVMZW5ndGgoY20sIGhlYWQubGluZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGluc2VydEF0ID09ICdib2wnKSB7XG4gICAgICAgICAgaGVhZCA9IFBvcyhoZWFkLmxpbmUsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGluc2VydEF0ID09ICdjaGFyQWZ0ZXInKSB7XG4gICAgICAgICAgaGVhZCA9IG9mZnNldEN1cnNvcihoZWFkLCAwLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnNlcnRBdCA9PSAnZmlyc3ROb25CbGFuaycpIHtcbiAgICAgICAgICBoZWFkID0gbW90aW9ucy5tb3ZlVG9GaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIoY20sIGhlYWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGluc2VydEF0ID09ICdzdGFydE9mU2VsZWN0ZWRBcmVhJykge1xuICAgICAgICAgIGlmICghdmltLnZpc3VhbE1vZGUpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAoIXZpbS52aXN1YWxCbG9jaykge1xuICAgICAgICAgICAgaWYgKHNlbC5oZWFkLmxpbmUgPCBzZWwuYW5jaG9yLmxpbmUpIHtcbiAgICAgICAgICAgICAgaGVhZCA9IHNlbC5oZWFkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGVhZCA9IFBvcyhzZWwuYW5jaG9yLmxpbmUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkID0gUG9zKFxuICAgICAgICAgICAgICAgIE1hdGgubWluKHNlbC5oZWFkLmxpbmUsIHNlbC5hbmNob3IubGluZSksXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oc2VsLmhlYWQuY2gsIHNlbC5hbmNob3IuY2gpKTtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguYWJzKHNlbC5oZWFkLmxpbmUgLSBzZWwuYW5jaG9yLmxpbmUpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0QXQgPT0gJ2VuZE9mU2VsZWN0ZWRBcmVhJykge1xuICAgICAgICAgICAgaWYgKCF2aW0udmlzdWFsTW9kZSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGlmICghdmltLnZpc3VhbEJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoc2VsLmhlYWQubGluZSA+PSBzZWwuYW5jaG9yLmxpbmUpIHtcbiAgICAgICAgICAgICAgaGVhZCA9IG9mZnNldEN1cnNvcihzZWwuaGVhZCwgMCwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoZWFkID0gUG9zKHNlbC5hbmNob3IubGluZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQgPSBQb3MoXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oc2VsLmhlYWQubGluZSwgc2VsLmFuY2hvci5saW5lKSxcbiAgICAgICAgICAgICAgICBNYXRoLm1heChzZWwuaGVhZC5jaCArIDEsIHNlbC5hbmNob3IuY2gpKTtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguYWJzKHNlbC5oZWFkLmxpbmUgLSBzZWwuYW5jaG9yLmxpbmUpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0QXQgPT0gJ2lucGxhY2UnKSB7XG4gICAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0QXQgPT0gJ2xhc3RFZGl0Jykge1xuICAgICAgICAgIGhlYWQgPSBnZXRMYXN0RWRpdFBvcyhjbSkgfHwgaGVhZDtcbiAgICAgICAgfVxuICAgICAgICBjbS5zZXRPcHRpb24oJ2Rpc2FibGVJbnB1dCcsIGZhbHNlKTtcbiAgICAgICAgaWYgKGFjdGlvbkFyZ3MgJiYgYWN0aW9uQXJncy5yZXBsYWNlKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIFJlcGxhY2UtbW9kZSBhcyBhIHNwZWNpYWwgY2FzZSBvZiBpbnNlcnQgbW9kZS5cbiAgICAgICAgICBjbS50b2dnbGVPdmVyd3JpdGUodHJ1ZSk7XG4gICAgICAgICAgY20uc2V0T3B0aW9uKCdrZXlNYXAnLCAndmltLXJlcGxhY2UnKTtcbiAgICAgICAgICBDb2RlTWlycm9yLnNpZ25hbChjbSwgXCJ2aW0tbW9kZS1jaGFuZ2VcIiwge21vZGU6IFwicmVwbGFjZVwifSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY20udG9nZ2xlT3ZlcndyaXRlKGZhbHNlKTtcbiAgICAgICAgICBjbS5zZXRPcHRpb24oJ2tleU1hcCcsICd2aW0taW5zZXJ0Jyk7XG4gICAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcImluc2VydFwifSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHtcbiAgICAgICAgICAvLyBPbmx5IHJlY29yZCBpZiBub3QgcmVwbGF5aW5nLlxuICAgICAgICAgIGNtLm9uKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgICAgICAgQ29kZU1pcnJvci5vbihjbS5nZXRJbnB1dEZpZWxkKCksICdrZXlkb3duJywgb25LZXlFdmVudFRhcmdldEtleURvd24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIGV4aXRWaXN1YWxNb2RlKGNtKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RGb3JJbnNlcnQoY20sIGhlYWQsIGhlaWdodCk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlVmlzdWFsTW9kZTogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICB2YXIgcmVwZWF0ID0gYWN0aW9uQXJncy5yZXBlYXQ7XG4gICAgICAgIHZhciBhbmNob3IgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICAgICAgdmFyIGhlYWQ7XG4gICAgICAgIC8vIFRPRE86IFRoZSByZXBlYXQgc2hvdWxkIGFjdHVhbGx5IHNlbGVjdCBudW1iZXIgb2YgY2hhcmFjdGVycy9saW5lc1xuICAgICAgICAvLyAgICAgZXF1YWwgdG8gdGhlIHJlcGVhdCB0aW1lcyB0aGUgc2l6ZSBvZiB0aGUgcHJldmlvdXMgdmlzdWFsXG4gICAgICAgIC8vICAgICBvcGVyYXRpb24uXG4gICAgICAgIGlmICghdmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICAvLyBFbnRlcmluZyB2aXN1YWwgbW9kZVxuICAgICAgICAgIHZpbS52aXN1YWxNb2RlID0gdHJ1ZTtcbiAgICAgICAgICB2aW0udmlzdWFsTGluZSA9ICEhYWN0aW9uQXJncy5saW5ld2lzZTtcbiAgICAgICAgICB2aW0udmlzdWFsQmxvY2sgPSAhIWFjdGlvbkFyZ3MuYmxvY2t3aXNlO1xuICAgICAgICAgIGhlYWQgPSBjbGlwQ3Vyc29yVG9Db250ZW50KFxuICAgICAgICAgICAgICBjbSwgUG9zKGFuY2hvci5saW5lLCBhbmNob3IuY2ggKyByZXBlYXQgLSAxKSk7XG4gICAgICAgICAgdmltLnNlbCA9IHtcbiAgICAgICAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgICAgICAgaGVhZDogaGVhZFxuICAgICAgICAgIH07XG4gICAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcInZpc3VhbFwiLCBzdWJNb2RlOiB2aW0udmlzdWFsTGluZSA/IFwibGluZXdpc2VcIiA6IHZpbS52aXN1YWxCbG9jayA/IFwiYmxvY2t3aXNlXCIgOiBcIlwifSk7XG4gICAgICAgICAgdXBkYXRlQ21TZWxlY3Rpb24oY20pO1xuICAgICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgJzwnLCBjdXJzb3JNaW4oYW5jaG9yLCBoZWFkKSk7XG4gICAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPicsIGN1cnNvck1heChhbmNob3IsIGhlYWQpKTtcbiAgICAgICAgfSBlbHNlIGlmICh2aW0udmlzdWFsTGluZSBeIGFjdGlvbkFyZ3MubGluZXdpc2UgfHxcbiAgICAgICAgICAgIHZpbS52aXN1YWxCbG9jayBeIGFjdGlvbkFyZ3MuYmxvY2t3aXNlKSB7XG4gICAgICAgICAgLy8gVG9nZ2xpbmcgYmV0d2VlbiBtb2Rlc1xuICAgICAgICAgIHZpbS52aXN1YWxMaW5lID0gISFhY3Rpb25BcmdzLmxpbmV3aXNlO1xuICAgICAgICAgIHZpbS52aXN1YWxCbG9jayA9ICEhYWN0aW9uQXJncy5ibG9ja3dpc2U7XG4gICAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcInZpc3VhbFwiLCBzdWJNb2RlOiB2aW0udmlzdWFsTGluZSA/IFwibGluZXdpc2VcIiA6IHZpbS52aXN1YWxCbG9jayA/IFwiYmxvY2t3aXNlXCIgOiBcIlwifSk7XG4gICAgICAgICAgdXBkYXRlQ21TZWxlY3Rpb24oY20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4aXRWaXN1YWxNb2RlKGNtKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc2VsZWN0TGFzdFNlbGVjdGlvbjogZnVuY3Rpb24oY20sIF9hY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgdmFyIGxhc3RTZWxlY3Rpb24gPSB2aW0ubGFzdFNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgdXBkYXRlTGFzdFNlbGVjdGlvbihjbSwgdmltKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBhbmNob3IgPSBsYXN0U2VsZWN0aW9uLmFuY2hvck1hcmsuZmluZCgpO1xuICAgICAgICAgIHZhciBoZWFkID0gbGFzdFNlbGVjdGlvbi5oZWFkTWFyay5maW5kKCk7XG4gICAgICAgICAgaWYgKCFhbmNob3IgfHwgIWhlYWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBtYXJrcyBoYXZlIGJlZW4gZGVzdHJveWVkIGR1ZSB0byBlZGl0cywgZG8gbm90aGluZy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmltLnNlbCA9IHtcbiAgICAgICAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgICAgICAgaGVhZDogaGVhZFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmltLnZpc3VhbE1vZGUgPSB0cnVlO1xuICAgICAgICAgIHZpbS52aXN1YWxMaW5lID0gbGFzdFNlbGVjdGlvbi52aXN1YWxMaW5lO1xuICAgICAgICAgIHZpbS52aXN1YWxCbG9jayA9IGxhc3RTZWxlY3Rpb24udmlzdWFsQmxvY2s7XG4gICAgICAgICAgdXBkYXRlQ21TZWxlY3Rpb24oY20pO1xuICAgICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgJzwnLCBjdXJzb3JNaW4oYW5jaG9yLCBoZWFkKSk7XG4gICAgICAgICAgdXBkYXRlTWFyayhjbSwgdmltLCAnPicsIGN1cnNvck1heChhbmNob3IsIGhlYWQpKTtcbiAgICAgICAgICBDb2RlTWlycm9yLnNpZ25hbChjbSwgJ3ZpbS1tb2RlLWNoYW5nZScsIHtcbiAgICAgICAgICAgIG1vZGU6ICd2aXN1YWwnLFxuICAgICAgICAgICAgc3ViTW9kZTogdmltLnZpc3VhbExpbmUgPyAnbGluZXdpc2UnIDpcbiAgICAgICAgICAgICAgICAgICAgIHZpbS52aXN1YWxCbG9jayA/ICdibG9ja3dpc2UnIDogJyd9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGpvaW5MaW5lczogZnVuY3Rpb24oY20sIGFjdGlvbkFyZ3MsIHZpbSkge1xuICAgICAgICB2YXIgY3VyU3RhcnQsIGN1ckVuZDtcbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgY3VyU3RhcnQgPSBjbS5nZXRDdXJzb3IoJ2FuY2hvcicpO1xuICAgICAgICAgIGN1ckVuZCA9IGNtLmdldEN1cnNvcignaGVhZCcpO1xuICAgICAgICAgIGlmIChjdXJzb3JJc0JlZm9yZShjdXJFbmQsIGN1clN0YXJ0KSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IGN1ckVuZDtcbiAgICAgICAgICAgIGN1ckVuZCA9IGN1clN0YXJ0O1xuICAgICAgICAgICAgY3VyU3RhcnQgPSB0bXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1ckVuZC5jaCA9IGxpbmVMZW5ndGgoY20sIGN1ckVuZC5saW5lKSAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVwZWF0IGlzIHRoZSBudW1iZXIgb2YgbGluZXMgdG8gam9pbi4gTWluaW11bSAyIGxpbmVzLlxuICAgICAgICAgIHZhciByZXBlYXQgPSBNYXRoLm1heChhY3Rpb25BcmdzLnJlcGVhdCwgMik7XG4gICAgICAgICAgY3VyU3RhcnQgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICAgICAgICBjdXJFbmQgPSBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBQb3MoY3VyU3RhcnQubGluZSArIHJlcGVhdCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEluZmluaXR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbmFsQ2ggPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gY3VyU3RhcnQubGluZTsgaSA8IGN1ckVuZC5saW5lOyBpKyspIHtcbiAgICAgICAgICBmaW5hbENoID0gbGluZUxlbmd0aChjbSwgY3VyU3RhcnQubGluZSk7XG4gICAgICAgICAgdmFyIHRtcCA9IFBvcyhjdXJTdGFydC5saW5lICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVMZW5ndGgoY20sIGN1clN0YXJ0LmxpbmUgKyAxKSk7XG4gICAgICAgICAgdmFyIHRleHQgPSBjbS5nZXRSYW5nZShjdXJTdGFydCwgdG1wKTtcbiAgICAgICAgICB0ZXh0ID0gYWN0aW9uQXJncy5rZWVwU3BhY2VzXG4gICAgICAgICAgICA/IHRleHQucmVwbGFjZSgvXFxuXFxyPy9nLCAnJylcbiAgICAgICAgICAgIDogdGV4dC5yZXBsYWNlKC9cXG5cXHMqL2csICcgJyk7XG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKHRleHQsIGN1clN0YXJ0LCB0bXApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJGaW5hbFBvcyA9IFBvcyhjdXJTdGFydC5saW5lLCBmaW5hbENoKTtcbiAgICAgICAgaWYgKHZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAgICAgZXhpdFZpc3VhbE1vZGUoY20sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjbS5zZXRDdXJzb3IoY3VyRmluYWxQb3MpO1xuICAgICAgfSxcbiAgICAgIG5ld0xpbmVBbmRFbnRlckluc2VydE1vZGU6IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgdmltLmluc2VydE1vZGUgPSB0cnVlO1xuICAgICAgICB2YXIgaW5zZXJ0QXQgPSBjb3B5Q3Vyc29yKGNtLmdldEN1cnNvcigpKTtcbiAgICAgICAgaWYgKGluc2VydEF0LmxpbmUgPT09IGNtLmZpcnN0TGluZSgpICYmICFhY3Rpb25BcmdzLmFmdGVyKSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBpbnNlcnRpbmcgbmV3bGluZSBiZWZvcmUgc3RhcnQgb2YgZG9jdW1lbnQuXG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKCdcXG4nLCBQb3MoY20uZmlyc3RMaW5lKCksIDApKTtcbiAgICAgICAgICBjbS5zZXRDdXJzb3IoY20uZmlyc3RMaW5lKCksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydEF0LmxpbmUgPSAoYWN0aW9uQXJncy5hZnRlcikgPyBpbnNlcnRBdC5saW5lIDpcbiAgICAgICAgICAgICAgaW5zZXJ0QXQubGluZSAtIDE7XG4gICAgICAgICAgaW5zZXJ0QXQuY2ggPSBsaW5lTGVuZ3RoKGNtLCBpbnNlcnRBdC5saW5lKTtcbiAgICAgICAgICBjbS5zZXRDdXJzb3IoaW5zZXJ0QXQpO1xuICAgICAgICAgIHZhciBuZXdsaW5lRm4gPSBDb2RlTWlycm9yLmNvbW1hbmRzLm5ld2xpbmVBbmRJbmRlbnRDb250aW51ZUNvbW1lbnQgfHxcbiAgICAgICAgICAgICAgQ29kZU1pcnJvci5jb21tYW5kcy5uZXdsaW5lQW5kSW5kZW50O1xuICAgICAgICAgIG5ld2xpbmVGbihjbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbnRlckluc2VydE1vZGUoY20sIHsgcmVwZWF0OiBhY3Rpb25BcmdzLnJlcGVhdCB9LCB2aW0pO1xuICAgICAgfSxcbiAgICAgIHBhc3RlOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciBjdXIgPSBjb3B5Q3Vyc29yKGNtLmdldEN1cnNvcigpKTtcbiAgICAgICAgdmFyIHJlZ2lzdGVyID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKFxuICAgICAgICAgICAgYWN0aW9uQXJncy5yZWdpc3Rlck5hbWUpO1xuICAgICAgICB2YXIgdGV4dCA9IHJlZ2lzdGVyLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uQXJncy5tYXRjaEluZGVudCkge1xuICAgICAgICAgIHZhciB0YWJTaXplID0gY20uZ2V0T3B0aW9uKFwidGFiU2l6ZVwiKTtcbiAgICAgICAgICAvLyBsZW5ndGggdGhhdCBjb25zaWRlcnMgdGFicyBhbmQgdGFiU2l6ZVxuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlTGVuZ3RoID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB2YXIgdGFicyA9IChzdHIuc3BsaXQoXCJcXHRcIikubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB2YXIgc3BhY2VzID0gKHN0ci5zcGxpdChcIiBcIikubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICByZXR1cm4gdGFicyAqIHRhYlNpemUgKyBzcGFjZXMgKiAxO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gY20uZ2V0TGluZShjbS5nZXRDdXJzb3IoKS5saW5lKTtcbiAgICAgICAgICB2YXIgaW5kZW50ID0gd2hpdGVzcGFjZUxlbmd0aChjdXJyZW50TGluZS5tYXRjaCgvXlxccyovKVswXSk7XG4gICAgICAgICAgLy8gY2hvbXAgbGFzdCBuZXdsaW5lIGIvYyBkb24ndCB3YW50IGl0IHRvIG1hdGNoIC9eXFxzKi9nbVxuICAgICAgICAgIHZhciBjaG9tcGVkVGV4dCA9IHRleHQucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICAgICAgICB2YXIgd2FzQ2hvbXBlZCA9IHRleHQgIT09IGNob21wZWRUZXh0O1xuICAgICAgICAgIHZhciBmaXJzdEluZGVudCA9IHdoaXRlc3BhY2VMZW5ndGgodGV4dC5tYXRjaCgvXlxccyovKVswXSk7XG4gICAgICAgICAgdmFyIHRleHQgPSBjaG9tcGVkVGV4dC5yZXBsYWNlKC9eXFxzKi9nbSwgZnVuY3Rpb24od3NwYWNlKSB7XG4gICAgICAgICAgICB2YXIgbmV3SW5kZW50ID0gaW5kZW50ICsgKHdoaXRlc3BhY2VMZW5ndGgod3NwYWNlKSAtIGZpcnN0SW5kZW50KTtcbiAgICAgICAgICAgIGlmIChuZXdJbmRlbnQgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY20uZ2V0T3B0aW9uKFwiaW5kZW50V2l0aFRhYnNcIikpIHtcbiAgICAgICAgICAgICAgdmFyIHF1b3RpZW50ID0gTWF0aC5mbG9vcihuZXdJbmRlbnQgLyB0YWJTaXplKTtcbiAgICAgICAgICAgICAgcmV0dXJuIEFycmF5KHF1b3RpZW50ICsgMSkuam9pbignXFx0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEFycmF5KG5ld0luZGVudCArIDEpLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0ZXh0ICs9IHdhc0Nob21wZWQgPyBcIlxcblwiIDogXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uQXJncy5yZXBlYXQgPiAxKSB7XG4gICAgICAgICAgdmFyIHRleHQgPSBBcnJheShhY3Rpb25BcmdzLnJlcGVhdCArIDEpLmpvaW4odGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmV3aXNlID0gcmVnaXN0ZXIubGluZXdpc2U7XG4gICAgICAgIHZhciBibG9ja3dpc2UgPSByZWdpc3Rlci5ibG9ja3dpc2U7XG4gICAgICAgIGlmIChibG9ja3dpc2UpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgICAgICAgIHRleHQucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGV4dFtpXSA9ICh0ZXh0W2ldID09ICcnKSA/ICcgJyA6IHRleHRbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1ci5jaCArPSBhY3Rpb25BcmdzLmFmdGVyID8gMSA6IDA7XG4gICAgICAgICAgY3VyLmNoID0gTWF0aC5taW4obGluZUxlbmd0aChjbSwgY3VyLmxpbmUpLCBjdXIuY2gpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgICAgaWYodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICAgIHRleHQgPSB2aW0udmlzdWFsTGluZSA/IHRleHQuc2xpY2UoMCwgLTEpIDogJ1xcbicgKyB0ZXh0LnNsaWNlKDAsIHRleHQubGVuZ3RoIC0gMSkgKyAnXFxuJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbkFyZ3MuYWZ0ZXIpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgdGhlIG5ld2xpbmUgYXQgdGhlIGVuZCB0byB0aGUgc3RhcnQgaW5zdGVhZCwgYW5kIHBhc3RlIGp1c3RcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgbmV3bGluZSBjaGFyYWN0ZXIgb2YgdGhlIGxpbmUgd2UgYXJlIG9uIHJpZ2h0IG5vdy5cbiAgICAgICAgICAgIHRleHQgPSAnXFxuJyArIHRleHQuc2xpY2UoMCwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGN1ci5jaCA9IGxpbmVMZW5ndGgoY20sIGN1ci5saW5lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyLmNoID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyLmNoICs9IGFjdGlvbkFyZ3MuYWZ0ZXIgPyAxIDogMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyUG9zRmluYWw7XG4gICAgICAgIHZhciBpZHg7XG4gICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIC8vICBzYXZlIHRoZSBwYXN0ZWQgdGV4dCBmb3IgcmVzZWxlY3Rpb24gaWYgdGhlIG5lZWQgYXJpc2VzXG4gICAgICAgICAgdmltLmxhc3RQYXN0ZWRUZXh0ID0gdGV4dDtcbiAgICAgICAgICB2YXIgbGFzdFNlbGVjdGlvbkN1ckVuZDtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWRBcmVhID0gZ2V0U2VsZWN0ZWRBcmVhUmFuZ2UoY20sIHZpbSk7XG4gICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0ZWRBcmVhWzBdO1xuICAgICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSBzZWxlY3RlZEFyZWFbMV07XG4gICAgICAgICAgdmFyIHNlbGVjdGVkVGV4dCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgIHZhciBzZWxlY3Rpb25zID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgICAgICB2YXIgZW1wdHlTdHJpbmdzID0gbmV3IEFycmF5KHNlbGVjdGlvbnMubGVuZ3RoKS5qb2luKCcxJykuc3BsaXQoJzEnKTtcbiAgICAgICAgICAvLyBzYXZlIHRoZSBjdXJFbmQgbWFya2VyIGJlZm9yZSBpdCBnZXQgY2xlYXJlZCBkdWUgdG8gY20ucmVwbGFjZVJhbmdlLlxuICAgICAgICAgIGlmICh2aW0ubGFzdFNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGFzdFNlbGVjdGlvbkN1ckVuZCA9IHZpbS5sYXN0U2VsZWN0aW9uLmhlYWRNYXJrLmZpbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcHVzaCB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCB0ZXh0IHRvIHVubmFtZWQgcmVnaXN0ZXJcbiAgICAgICAgICB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIudW5uYW1lZFJlZ2lzdGVyLnNldFRleHQoc2VsZWN0ZWRUZXh0KTtcbiAgICAgICAgICBpZiAoYmxvY2t3aXNlKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBkZWxldGUgdGhlIHNlbGVjdGVkIHRleHRcbiAgICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKGVtcHR5U3RyaW5ncyk7XG4gICAgICAgICAgICAvLyBTZXQgbmV3IHNlbGVjdGlvbnMgYXMgcGVyIHRoZSBibG9jayBsZW5ndGggb2YgdGhlIHlhbmtlZCB0ZXh0XG4gICAgICAgICAgICBzZWxlY3Rpb25FbmQgPSBQb3Moc2VsZWN0aW9uU3RhcnQubGluZSArIHRleHQubGVuZ3RoLTEsIHNlbGVjdGlvblN0YXJ0LmNoKTtcbiAgICAgICAgICAgIGNtLnNldEN1cnNvcihzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICBzZWxlY3RCbG9jayhjbSwgc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKHRleHQpO1xuICAgICAgICAgICAgY3VyUG9zRmluYWwgPSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZpbS52aXN1YWxCbG9jaykge1xuICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnMoZW1wdHlTdHJpbmdzKTtcbiAgICAgICAgICAgIGNtLnNldEN1cnNvcihzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIGN1clBvc0ZpbmFsID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZSh0ZXh0LCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgICAgIGN1clBvc0ZpbmFsID0gY20ucG9zRnJvbUluZGV4KGNtLmluZGV4RnJvbVBvcyhzZWxlY3Rpb25TdGFydCkgKyB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZXN0b3JlIHRoZSB0aGUgY3VyRW5kIG1hcmtlclxuICAgICAgICAgIGlmKGxhc3RTZWxlY3Rpb25DdXJFbmQpIHtcbiAgICAgICAgICAgIHZpbS5sYXN0U2VsZWN0aW9uLmhlYWRNYXJrID0gY20uc2V0Qm9va21hcmsobGFzdFNlbGVjdGlvbkN1ckVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsaW5ld2lzZSkge1xuICAgICAgICAgICAgY3VyUG9zRmluYWwuY2g9MDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGJsb2Nrd2lzZSkge1xuICAgICAgICAgICAgY20uc2V0Q3Vyc29yKGN1cik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGxpbmUgPSBjdXIubGluZStpO1xuICAgICAgICAgICAgICBpZiAobGluZSA+IGNtLmxhc3RMaW5lKCkpIHtcbiAgICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoJ1xcbicsICBQb3MobGluZSwgMCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBsYXN0Q2ggPSBsaW5lTGVuZ3RoKGNtLCBsaW5lKTtcbiAgICAgICAgICAgICAgaWYgKGxhc3RDaCA8IGN1ci5jaCkge1xuICAgICAgICAgICAgICAgIGV4dGVuZExpbmVUb0NvbHVtbihjbSwgbGluZSwgY3VyLmNoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY20uc2V0Q3Vyc29yKGN1cik7XG4gICAgICAgICAgICBzZWxlY3RCbG9jayhjbSwgUG9zKGN1ci5saW5lICsgdGV4dC5sZW5ndGgtMSwgY3VyLmNoKSk7XG4gICAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyh0ZXh0KTtcbiAgICAgICAgICAgIGN1clBvc0ZpbmFsID0gY3VyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dCwgY3VyKTtcbiAgICAgICAgICAgIC8vIE5vdyBmaW5lIHR1bmUgdGhlIGN1cnNvciB0byB3aGVyZSB3ZSB3YW50IGl0LlxuICAgICAgICAgICAgaWYgKGxpbmV3aXNlICYmIGFjdGlvbkFyZ3MuYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgY3VyUG9zRmluYWwgPSBQb3MoXG4gICAgICAgICAgICAgIGN1ci5saW5lICsgMSxcbiAgICAgICAgICAgICAgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGN1ci5saW5lICsgMSkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZXdpc2UgJiYgIWFjdGlvbkFyZ3MuYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgY3VyUG9zRmluYWwgPSBQb3MoXG4gICAgICAgICAgICAgICAgY3VyLmxpbmUsXG4gICAgICAgICAgICAgICAgZmluZEZpcnN0Tm9uV2hpdGVTcGFjZUNoYXJhY3RlcihjbS5nZXRMaW5lKGN1ci5saW5lKSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbGluZXdpc2UgJiYgYWN0aW9uQXJncy5hZnRlcikge1xuICAgICAgICAgICAgICBpZHggPSBjbS5pbmRleEZyb21Qb3MoY3VyKTtcbiAgICAgICAgICAgICAgY3VyUG9zRmluYWwgPSBjbS5wb3NGcm9tSW5kZXgoaWR4ICsgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlkeCA9IGNtLmluZGV4RnJvbVBvcyhjdXIpO1xuICAgICAgICAgICAgICBjdXJQb3NGaW5hbCA9IGNtLnBvc0Zyb21JbmRleChpZHggKyB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIGV4aXRWaXN1YWxNb2RlKGNtLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY20uc2V0Q3Vyc29yKGN1clBvc0ZpbmFsKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncykge1xuICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVwZWF0Rm4oY20sIENvZGVNaXJyb3IuY29tbWFuZHMudW5kbywgYWN0aW9uQXJncy5yZXBlYXQpKCk7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKGNtLmdldEN1cnNvcignYW5jaG9yJykpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZWRvOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncykge1xuICAgICAgICByZXBlYXRGbihjbSwgQ29kZU1pcnJvci5jb21tYW5kcy5yZWRvLCBhY3Rpb25BcmdzLnJlcGVhdCkoKTtcbiAgICAgIH0sXG4gICAgICBzZXRSZWdpc3RlcjogZnVuY3Rpb24oX2NtLCBhY3Rpb25BcmdzLCB2aW0pIHtcbiAgICAgICAgdmltLmlucHV0U3RhdGUucmVnaXN0ZXJOYW1lID0gYWN0aW9uQXJncy5zZWxlY3RlZENoYXJhY3RlcjtcbiAgICAgIH0sXG4gICAgICBzZXRNYXJrOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciBtYXJrTmFtZSA9IGFjdGlvbkFyZ3Muc2VsZWN0ZWRDaGFyYWN0ZXI7XG4gICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgbWFya05hbWUsIGNtLmdldEN1cnNvcigpKTtcbiAgICAgIH0sXG4gICAgICByZXBsYWNlOiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciByZXBsYWNlV2l0aCA9IGFjdGlvbkFyZ3Muc2VsZWN0ZWRDaGFyYWN0ZXI7XG4gICAgICAgIHZhciBjdXJTdGFydCA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgcmVwbGFjZVRvO1xuICAgICAgICB2YXIgY3VyRW5kO1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIGN1clN0YXJ0ID0gY20uZ2V0Q3Vyc29yKCdzdGFydCcpO1xuICAgICAgICAgIGN1ckVuZCA9IGNtLmdldEN1cnNvcignZW5kJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGN1clN0YXJ0LmxpbmUpO1xuICAgICAgICAgIHJlcGxhY2VUbyA9IGN1clN0YXJ0LmNoICsgYWN0aW9uQXJncy5yZXBlYXQ7XG4gICAgICAgICAgaWYgKHJlcGxhY2VUbyA+IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXBsYWNlVG89bGluZS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1ckVuZCA9IFBvcyhjdXJTdGFydC5saW5lLCByZXBsYWNlVG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBsYWNlV2l0aD09J1xcbicpIHtcbiAgICAgICAgICBpZiAoIXZpbS52aXN1YWxNb2RlKSBjbS5yZXBsYWNlUmFuZ2UoJycsIGN1clN0YXJ0LCBjdXJFbmQpO1xuICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSwgd2hlcmUgdmltIGhlbHAgc2F5cyB0byByZXBsYWNlIGJ5IGp1c3Qgb25lIGxpbmUtYnJlYWtcbiAgICAgICAgICAoQ29kZU1pcnJvci5jb21tYW5kcy5uZXdsaW5lQW5kSW5kZW50Q29udGludWVDb21tZW50IHx8IENvZGVNaXJyb3IuY29tbWFuZHMubmV3bGluZUFuZEluZGVudCkoY20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXBsYWNlV2l0aFN0ciA9IGNtLmdldFJhbmdlKGN1clN0YXJ0LCBjdXJFbmQpO1xuICAgICAgICAgIC8vcmVwbGFjZSBhbGwgY2hhcmFjdGVycyBpbiByYW5nZSBieSBzZWxlY3RlZCwgYnV0IGtlZXAgbGluZWJyZWFrc1xuICAgICAgICAgIHJlcGxhY2VXaXRoU3RyID0gcmVwbGFjZVdpdGhTdHIucmVwbGFjZSgvW15cXG5dL2csIHJlcGxhY2VXaXRoKTtcbiAgICAgICAgICBpZiAodmltLnZpc3VhbEJsb2NrKSB7XG4gICAgICAgICAgICAvLyBUYWJzIGFyZSBzcGxpdCBpbiB2aXN1YSBibG9jayBiZWZvcmUgcmVwbGFjaW5nXG4gICAgICAgICAgICB2YXIgc3BhY2VzID0gbmV3IEFycmF5KGNtLmdldE9wdGlvbihcInRhYlNpemVcIikrMSkuam9pbignICcpO1xuICAgICAgICAgICAgcmVwbGFjZVdpdGhTdHIgPSBjbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJlcGxhY2VXaXRoU3RyID0gcmVwbGFjZVdpdGhTdHIucmVwbGFjZSgvXFx0L2csIHNwYWNlcykucmVwbGFjZSgvW15cXG5dL2csIHJlcGxhY2VXaXRoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhyZXBsYWNlV2l0aFN0cik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShyZXBsYWNlV2l0aFN0ciwgY3VyU3RhcnQsIGN1ckVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgICAgY3VyU3RhcnQgPSBjdXJzb3JJc0JlZm9yZShzZWxlY3Rpb25zWzBdLmFuY2hvciwgc2VsZWN0aW9uc1swXS5oZWFkKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uc1swXS5hbmNob3IgOiBzZWxlY3Rpb25zWzBdLmhlYWQ7XG4gICAgICAgICAgICBjbS5zZXRDdXJzb3IoY3VyU3RhcnQpO1xuICAgICAgICAgICAgZXhpdFZpc3VhbE1vZGUoY20sIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY20uc2V0Q3Vyc29yKG9mZnNldEN1cnNvcihjdXJFbmQsIDAsIC0xKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5jcmVtZW50TnVtYmVyVG9rZW46IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzKSB7XG4gICAgICAgIHZhciBjdXIgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICAgICAgdmFyIGxpbmVTdHIgPSBjbS5nZXRMaW5lKGN1ci5saW5lKTtcbiAgICAgICAgdmFyIHJlID0gLygtPykoPzooMHgpKFtcXGRhLWZdKyl8KDBifDB8KShcXGQrKSkvZ2k7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICB2YXIgZW5kO1xuICAgICAgICB2YXIgbnVtYmVyU3RyO1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhsaW5lU3RyKSkgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGFydCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgIGlmIChjdXIuY2ggPCBlbmQpYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhY3Rpb25BcmdzLmJhY2t0cmFjayAmJiAoZW5kIDw9IGN1ci5jaCkpcmV0dXJuO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YXIgYmFzZVN0ciA9IG1hdGNoWzJdIHx8IG1hdGNoWzRdXG4gICAgICAgICAgdmFyIGRpZ2l0cyA9IG1hdGNoWzNdIHx8IG1hdGNoWzVdXG4gICAgICAgICAgdmFyIGluY3JlbWVudCA9IGFjdGlvbkFyZ3MuaW5jcmVhc2UgPyAxIDogLTE7XG4gICAgICAgICAgdmFyIGJhc2UgPSB7JzBiJzogMiwgJzAnOiA4LCAnJzogMTAsICcweCc6IDE2fVtiYXNlU3RyLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgIHZhciBudW1iZXIgPSBwYXJzZUludChtYXRjaFsxXSArIGRpZ2l0cywgYmFzZSkgKyAoaW5jcmVtZW50ICogYWN0aW9uQXJncy5yZXBlYXQpO1xuICAgICAgICAgIG51bWJlclN0ciA9IG51bWJlci50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgICB2YXIgemVyb1BhZGRpbmcgPSBiYXNlU3RyID8gbmV3IEFycmF5KGRpZ2l0cy5sZW5ndGggLSBudW1iZXJTdHIubGVuZ3RoICsgMSArIG1hdGNoWzFdLmxlbmd0aCkuam9pbignMCcpIDogJydcbiAgICAgICAgICBpZiAobnVtYmVyU3RyLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBudW1iZXJTdHIgPSAnLScgKyBiYXNlU3RyICsgemVyb1BhZGRpbmcgKyBudW1iZXJTdHIuc3Vic3RyKDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1iZXJTdHIgPSBiYXNlU3RyICsgemVyb1BhZGRpbmcgKyBudW1iZXJTdHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBmcm9tID0gUG9zKGN1ci5saW5lLCBzdGFydCk7XG4gICAgICAgICAgdmFyIHRvID0gUG9zKGN1ci5saW5lLCBlbmQpO1xuICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShudW1iZXJTdHIsIGZyb20sIHRvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY20uc2V0Q3Vyc29yKFBvcyhjdXIubGluZSwgc3RhcnQgKyBudW1iZXJTdHIubGVuZ3RoIC0gMSkpO1xuICAgICAgfSxcbiAgICAgIHJlcGVhdExhc3RFZGl0OiBmdW5jdGlvbihjbSwgYWN0aW9uQXJncywgdmltKSB7XG4gICAgICAgIHZhciBsYXN0RWRpdElucHV0U3RhdGUgPSB2aW0ubGFzdEVkaXRJbnB1dFN0YXRlO1xuICAgICAgICBpZiAoIWxhc3RFZGl0SW5wdXRTdGF0ZSkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIHJlcGVhdCA9IGFjdGlvbkFyZ3MucmVwZWF0O1xuICAgICAgICBpZiAocmVwZWF0ICYmIGFjdGlvbkFyZ3MucmVwZWF0SXNFeHBsaWNpdCkge1xuICAgICAgICAgIHZpbS5sYXN0RWRpdElucHV0U3RhdGUucmVwZWF0T3ZlcnJpZGUgPSByZXBlYXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwZWF0ID0gdmltLmxhc3RFZGl0SW5wdXRTdGF0ZS5yZXBlYXRPdmVycmlkZSB8fCByZXBlYXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVwZWF0TGFzdEVkaXQoY20sIHZpbSwgcmVwZWF0LCBmYWxzZSAvKiogcmVwZWF0Rm9ySW5zZXJ0ICovKTtcbiAgICAgIH0sXG4gICAgICBpbmRlbnQ6IGZ1bmN0aW9uKGNtLCBhY3Rpb25BcmdzKSB7XG4gICAgICAgIGNtLmluZGVudExpbmUoY20uZ2V0Q3Vyc29yKCkubGluZSwgYWN0aW9uQXJncy5pbmRlbnRSaWdodCk7XG4gICAgICB9LFxuICAgICAgZXhpdEluc2VydE1vZGU6IGV4aXRJbnNlcnRNb2RlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRlZmluZUFjdGlvbihuYW1lLCBmbikge1xuICAgICAgYWN0aW9uc1tuYW1lXSA9IGZuO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQmVsb3cgYXJlIG1pc2NlbGxhbmVvdXMgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBieSB2aW0uanNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENsaXBzIGN1cnNvciB0byBlbnN1cmUgdGhhdCBsaW5lIGlzIHdpdGhpbiB0aGUgYnVmZmVyJ3MgcmFuZ2VcbiAgICAgKiBJZiBpbmNsdWRlTGluZUJyZWFrIGlzIHRydWUsIHRoZW4gYWxsb3cgY3VyLmNoID09IGxpbmVMZW5ndGguXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xpcEN1cnNvclRvQ29udGVudChjbSwgY3VyKSB7XG4gICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgdmFyIGluY2x1ZGVMaW5lQnJlYWsgPSB2aW0uaW5zZXJ0TW9kZSB8fCB2aW0udmlzdWFsTW9kZTtcbiAgICAgIHZhciBsaW5lID0gTWF0aC5taW4oTWF0aC5tYXgoY20uZmlyc3RMaW5lKCksIGN1ci5saW5lKSwgY20ubGFzdExpbmUoKSApO1xuICAgICAgdmFyIG1heENoID0gbGluZUxlbmd0aChjbSwgbGluZSkgLSAxICsgISFpbmNsdWRlTGluZUJyZWFrO1xuICAgICAgdmFyIGNoID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgY3VyLmNoKSwgbWF4Q2gpO1xuICAgICAgcmV0dXJuIFBvcyhsaW5lLCBjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlBcmdzKGFyZ3MpIHtcbiAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gYXJncykge1xuICAgICAgICBpZiAoYXJncy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIHJldFtwcm9wXSA9IGFyZ3NbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9mZnNldEN1cnNvcihjdXIsIG9mZnNldExpbmUsIG9mZnNldENoKSB7XG4gICAgICBpZiAodHlwZW9mIG9mZnNldExpbmUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9mZnNldENoID0gb2Zmc2V0TGluZS5jaDtcbiAgICAgICAgb2Zmc2V0TGluZSA9IG9mZnNldExpbmUubGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQb3MoY3VyLmxpbmUgKyBvZmZzZXRMaW5lLCBjdXIuY2ggKyBvZmZzZXRDaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1hbmRNYXRjaGVzKGtleXMsIGtleU1hcCwgY29udGV4dCwgaW5wdXRTdGF0ZSkge1xuICAgICAgLy8gUGFydGlhbCBtYXRjaGVzIGFyZSBub3QgYXBwbGllZC4gVGhleSBpbmZvcm0gdGhlIGtleSBoYW5kbGVyXG4gICAgICAvLyB0aGF0IHRoZSBjdXJyZW50IGtleSBzZXF1ZW5jZSBpcyBhIHN1YnNlcXVlbmNlIG9mIGEgdmFsaWQga2V5XG4gICAgICAvLyBzZXF1ZW5jZSwgc28gdGhhdCB0aGUga2V5IGJ1ZmZlciBpcyBub3QgY2xlYXJlZC5cbiAgICAgIHZhciBtYXRjaCwgcGFydGlhbCA9IFtdLCBmdWxsID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleU1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29tbWFuZCA9IGtleU1hcFtpXTtcbiAgICAgICAgaWYgKGNvbnRleHQgPT0gJ2luc2VydCcgJiYgY29tbWFuZC5jb250ZXh0ICE9ICdpbnNlcnQnIHx8XG4gICAgICAgICAgICBjb21tYW5kLmNvbnRleHQgJiYgY29tbWFuZC5jb250ZXh0ICE9IGNvbnRleHQgfHxcbiAgICAgICAgICAgIGlucHV0U3RhdGUub3BlcmF0b3IgJiYgY29tbWFuZC50eXBlID09ICdhY3Rpb24nIHx8XG4gICAgICAgICAgICAhKG1hdGNoID0gY29tbWFuZE1hdGNoKGtleXMsIGNvbW1hbmQua2V5cykpKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmIChtYXRjaCA9PSAncGFydGlhbCcpIHsgcGFydGlhbC5wdXNoKGNvbW1hbmQpOyB9XG4gICAgICAgIGlmIChtYXRjaCA9PSAnZnVsbCcpIHsgZnVsbC5wdXNoKGNvbW1hbmQpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJ0aWFsOiBwYXJ0aWFsLmxlbmd0aCAmJiBwYXJ0aWFsLFxuICAgICAgICBmdWxsOiBmdWxsLmxlbmd0aCAmJiBmdWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21tYW5kTWF0Y2gocHJlc3NlZCwgbWFwcGVkKSB7XG4gICAgICBpZiAobWFwcGVkLnNsaWNlKC0xMSkgPT0gJzxjaGFyYWN0ZXI+Jykge1xuICAgICAgICAvLyBMYXN0IGNoYXJhY3RlciBtYXRjaGVzIGFueXRoaW5nLlxuICAgICAgICB2YXIgcHJlZml4TGVuID0gbWFwcGVkLmxlbmd0aCAtIDExO1xuICAgICAgICB2YXIgcHJlc3NlZFByZWZpeCA9IHByZXNzZWQuc2xpY2UoMCwgcHJlZml4TGVuKTtcbiAgICAgICAgdmFyIG1hcHBlZFByZWZpeCA9IG1hcHBlZC5zbGljZSgwLCBwcmVmaXhMZW4pO1xuICAgICAgICByZXR1cm4gcHJlc3NlZFByZWZpeCA9PSBtYXBwZWRQcmVmaXggJiYgcHJlc3NlZC5sZW5ndGggPiBwcmVmaXhMZW4gPyAnZnVsbCcgOlxuICAgICAgICAgICAgICAgbWFwcGVkUHJlZml4LmluZGV4T2YocHJlc3NlZFByZWZpeCkgPT0gMCA/ICdwYXJ0aWFsJyA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByZXNzZWQgPT0gbWFwcGVkID8gJ2Z1bGwnIDpcbiAgICAgICAgICAgICAgIG1hcHBlZC5pbmRleE9mKHByZXNzZWQpID09IDAgPyAncGFydGlhbCcgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbGFzdENoYXIoa2V5cykge1xuICAgICAgdmFyIG1hdGNoID0gL14uKig8W14+XSs+KSQvLmV4ZWMoa2V5cyk7XG4gICAgICB2YXIgc2VsZWN0ZWRDaGFyYWN0ZXIgPSBtYXRjaCA/IG1hdGNoWzFdIDoga2V5cy5zbGljZSgtMSk7XG4gICAgICBpZiAoc2VsZWN0ZWRDaGFyYWN0ZXIubGVuZ3RoID4gMSl7XG4gICAgICAgIHN3aXRjaChzZWxlY3RlZENoYXJhY3Rlcil7XG4gICAgICAgICAgY2FzZSAnPENSPic6XG4gICAgICAgICAgICBzZWxlY3RlZENoYXJhY3Rlcj0nXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJzxTcGFjZT4nOlxuICAgICAgICAgICAgc2VsZWN0ZWRDaGFyYWN0ZXI9JyAnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNlbGVjdGVkQ2hhcmFjdGVyPScnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RlZENoYXJhY3RlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwZWF0Rm4oY20sIGZuLCByZXBlYXQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBlYXQ7IGkrKykge1xuICAgICAgICAgIGZuKGNtKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weUN1cnNvcihjdXIpIHtcbiAgICAgIHJldHVybiBQb3MoY3VyLmxpbmUsIGN1ci5jaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1cnNvckVxdWFsKGN1cjEsIGN1cjIpIHtcbiAgICAgIHJldHVybiBjdXIxLmNoID09IGN1cjIuY2ggJiYgY3VyMS5saW5lID09IGN1cjIubGluZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3Vyc29ySXNCZWZvcmUoY3VyMSwgY3VyMikge1xuICAgICAgaWYgKGN1cjEubGluZSA8IGN1cjIubGluZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXIxLmxpbmUgPT0gY3VyMi5saW5lICYmIGN1cjEuY2ggPCBjdXIyLmNoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdXJzb3JNaW4oY3VyMSwgY3VyMikge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGN1cjIgPSBjdXJzb3JNaW4uYXBwbHkodW5kZWZpbmVkLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJzb3JJc0JlZm9yZShjdXIxLCBjdXIyKSA/IGN1cjEgOiBjdXIyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdXJzb3JNYXgoY3VyMSwgY3VyMikge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGN1cjIgPSBjdXJzb3JNYXguYXBwbHkodW5kZWZpbmVkLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJzb3JJc0JlZm9yZShjdXIxLCBjdXIyKSA/IGN1cjIgOiBjdXIxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdXJzb3JJc0JldHdlZW4oY3VyMSwgY3VyMiwgY3VyMykge1xuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGN1cjIgaXMgYmV0d2VlbiBjdXIxIGFuZCBjdXIzLlxuICAgICAgdmFyIGN1cjFiZWZvcmUyID0gY3Vyc29ySXNCZWZvcmUoY3VyMSwgY3VyMik7XG4gICAgICB2YXIgY3VyMmJlZm9yZTMgPSBjdXJzb3JJc0JlZm9yZShjdXIyLCBjdXIzKTtcbiAgICAgIHJldHVybiBjdXIxYmVmb3JlMiAmJiBjdXIyYmVmb3JlMztcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUxlbmd0aChjbSwgbGluZU51bSkge1xuICAgICAgcmV0dXJuIGNtLmdldExpbmUobGluZU51bSkubGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmltKHMpIHtcbiAgICAgIGlmIChzLnRyaW0pIHtcbiAgICAgICAgcmV0dXJuIHMudHJpbSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdleChzKSB7XG4gICAgICByZXR1cm4gcy5yZXBsYWNlKC8oWy4/KiskXFxbXFxdXFwvXFxcXCgpe318XFwtXSkvZywgJ1xcXFwkMScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHRlbmRMaW5lVG9Db2x1bW4oY20sIGxpbmVOdW0sIGNvbHVtbikge1xuICAgICAgdmFyIGVuZENoID0gbGluZUxlbmd0aChjbSwgbGluZU51bSk7XG4gICAgICB2YXIgc3BhY2VzID0gbmV3IEFycmF5KGNvbHVtbi1lbmRDaCsxKS5qb2luKCcgJyk7XG4gICAgICBjbS5zZXRDdXJzb3IoUG9zKGxpbmVOdW0sIGVuZENoKSk7XG4gICAgICBjbS5yZXBsYWNlUmFuZ2Uoc3BhY2VzLCBjbS5nZXRDdXJzb3IoKSk7XG4gICAgfVxuICAgIC8vIFRoaXMgZnVuY3Rpb25zIHNlbGVjdHMgYSByZWN0YW5ndWxhciBibG9ja1xuICAgIC8vIG9mIHRleHQgd2l0aCBzZWxlY3Rpb25FbmQgYXMgYW55IG9mIGl0cyBjb3JuZXJcbiAgICAvLyBIZWlnaHQgb2YgYmxvY2s6XG4gICAgLy8gRGlmZmVyZW5jZSBpbiBzZWxlY3Rpb25FbmQubGluZSBhbmQgZmlyc3QvbGFzdCBzZWxlY3Rpb24ubGluZVxuICAgIC8vIFdpZHRoIG9mIHRoZSBibG9jazpcbiAgICAvLyBEaXN0YW5jZSBiZXR3ZWVuIHNlbGVjdGlvbkVuZC5jaCBhbmQgYW55KGZpcnN0IGNvbnNpZGVyZWQgaGVyZSkgc2VsZWN0aW9uLmNoXG4gICAgZnVuY3Rpb24gc2VsZWN0QmxvY2soY20sIHNlbGVjdGlvbkVuZCkge1xuICAgICAgdmFyIHNlbGVjdGlvbnMgPSBbXSwgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIHZhciBoZWFkID0gY29weUN1cnNvcihjbS5jbGlwUG9zKHNlbGVjdGlvbkVuZCkpO1xuICAgICAgdmFyIGlzQ2xpcHBlZCA9ICFjdXJzb3JFcXVhbChzZWxlY3Rpb25FbmQsIGhlYWQpO1xuICAgICAgdmFyIGN1ckhlYWQgPSBjbS5nZXRDdXJzb3IoJ2hlYWQnKTtcbiAgICAgIHZhciBwcmltSW5kZXggPSBnZXRJbmRleChyYW5nZXMsIGN1ckhlYWQpO1xuICAgICAgdmFyIHdhc0NsaXBwZWQgPSBjdXJzb3JFcXVhbChyYW5nZXNbcHJpbUluZGV4XS5oZWFkLCByYW5nZXNbcHJpbUluZGV4XS5hbmNob3IpO1xuICAgICAgdmFyIG1heCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGluZGV4ID0gbWF4IC0gcHJpbUluZGV4ID4gcHJpbUluZGV4ID8gbWF4IDogMDtcbiAgICAgIHZhciBiYXNlID0gcmFuZ2VzW2luZGV4XS5hbmNob3I7XG5cbiAgICAgIHZhciBmaXJzdExpbmUgPSBNYXRoLm1pbihiYXNlLmxpbmUsIGhlYWQubGluZSk7XG4gICAgICB2YXIgbGFzdExpbmUgPSBNYXRoLm1heChiYXNlLmxpbmUsIGhlYWQubGluZSk7XG4gICAgICB2YXIgYmFzZUNoID0gYmFzZS5jaCwgaGVhZENoID0gaGVhZC5jaDtcblxuICAgICAgdmFyIGRpciA9IHJhbmdlc1tpbmRleF0uaGVhZC5jaCAtIGJhc2VDaDtcbiAgICAgIHZhciBuZXdEaXIgPSBoZWFkQ2ggLSBiYXNlQ2g7XG4gICAgICBpZiAoZGlyID4gMCAmJiBuZXdEaXIgPD0gMCkge1xuICAgICAgICBiYXNlQ2grKztcbiAgICAgICAgaWYgKCFpc0NsaXBwZWQpIHsgaGVhZENoLS07IH1cbiAgICAgIH0gZWxzZSBpZiAoZGlyIDwgMCAmJiBuZXdEaXIgPj0gMCkge1xuICAgICAgICBiYXNlQ2gtLTtcbiAgICAgICAgaWYgKCF3YXNDbGlwcGVkKSB7IGhlYWRDaCsrOyB9XG4gICAgICB9IGVsc2UgaWYgKGRpciA8IDAgJiYgbmV3RGlyID09IC0xKSB7XG4gICAgICAgIGJhc2VDaC0tO1xuICAgICAgICBoZWFkQ2grKztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGxpbmUgPSBmaXJzdExpbmU7IGxpbmUgPD0gbGFzdExpbmU7IGxpbmUrKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSB7YW5jaG9yOiBuZXcgUG9zKGxpbmUsIGJhc2VDaCksIGhlYWQ6IG5ldyBQb3MobGluZSwgaGVhZENoKX07XG4gICAgICAgIHNlbGVjdGlvbnMucHVzaChyYW5nZSk7XG4gICAgICB9XG4gICAgICBjbS5zZXRTZWxlY3Rpb25zKHNlbGVjdGlvbnMpO1xuICAgICAgc2VsZWN0aW9uRW5kLmNoID0gaGVhZENoO1xuICAgICAgYmFzZS5jaCA9IGJhc2VDaDtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZWxlY3RGb3JJbnNlcnQoY20sIGhlYWQsIGhlaWdodCkge1xuICAgICAgdmFyIHNlbCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICB2YXIgbGluZUhlYWQgPSBvZmZzZXRDdXJzb3IoaGVhZCwgaSwgMCk7XG4gICAgICAgIHNlbC5wdXNoKHthbmNob3I6IGxpbmVIZWFkLCBoZWFkOiBsaW5lSGVhZH0pO1xuICAgICAgfVxuICAgICAgY20uc2V0U2VsZWN0aW9ucyhzZWwsIDApO1xuICAgIH1cbiAgICAvLyBnZXRJbmRleCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY3Vyc29yIGluIHRoZSBzZWxlY3Rpb25zLlxuICAgIGZ1bmN0aW9uIGdldEluZGV4KHJhbmdlcywgY3Vyc29yLCBlbmQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhdEFuY2hvciA9IGVuZCAhPSAnaGVhZCcgJiYgY3Vyc29yRXF1YWwocmFuZ2VzW2ldLmFuY2hvciwgY3Vyc29yKTtcbiAgICAgICAgdmFyIGF0SGVhZCA9IGVuZCAhPSAnYW5jaG9yJyAmJiBjdXJzb3JFcXVhbChyYW5nZXNbaV0uaGVhZCwgY3Vyc29yKTtcbiAgICAgICAgaWYgKGF0QW5jaG9yIHx8IGF0SGVhZCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNlbGVjdGVkQXJlYVJhbmdlKGNtLCB2aW0pIHtcbiAgICAgIHZhciBsYXN0U2VsZWN0aW9uID0gdmltLmxhc3RTZWxlY3Rpb247XG4gICAgICB2YXIgZ2V0Q3VycmVudFNlbGVjdGVkQXJlYVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gIHNlbGVjdGlvbnNbMF07XG4gICAgICAgIHZhciBlbmQgPSBzZWxlY3Rpb25zW3NlbGVjdGlvbnMubGVuZ3RoLTFdO1xuICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBjdXJzb3JJc0JlZm9yZShzdGFydC5hbmNob3IsIHN0YXJ0LmhlYWQpID8gc3RhcnQuYW5jaG9yIDogc3RhcnQuaGVhZDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkVuZCA9IGN1cnNvcklzQmVmb3JlKGVuZC5hbmNob3IsIGVuZC5oZWFkKSA/IGVuZC5oZWFkIDogZW5kLmFuY2hvcjtcbiAgICAgICAgcmV0dXJuIFtzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kXTtcbiAgICAgIH07XG4gICAgICB2YXIgZ2V0TGFzdFNlbGVjdGVkQXJlYVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHZhciBibG9jayA9IGxhc3RTZWxlY3Rpb24udmlzdWFsQmxvY2s7XG4gICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgIHZhciB3aWR0aCA9IGJsb2NrLndpZHRoO1xuICAgICAgICAgIHZhciBoZWlnaHQgPSBibG9jay5oZWlnaHQ7XG4gICAgICAgICAgc2VsZWN0aW9uRW5kID0gUG9zKHNlbGVjdGlvblN0YXJ0LmxpbmUgKyBoZWlnaHQsIHNlbGVjdGlvblN0YXJ0LmNoICsgd2lkdGgpO1xuICAgICAgICAgIHZhciBzZWxlY3Rpb25zID0gW107XG4gICAgICAgICAgLy8gc2VsZWN0QmxvY2sgY3JlYXRlcyBhICdwcm9wZXInIHJlY3Rhbmd1bGFyIGJsb2NrLlxuICAgICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRoYXQgaW4gYWxsIGNhc2VzLCBzbyB3ZSBtYW51YWxseSBzZXQgc2VsZWN0aW9ucy5cbiAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZWN0aW9uU3RhcnQubGluZTsgaSA8IHNlbGVjdGlvbkVuZC5saW5lOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBQb3MoaSwgc2VsZWN0aW9uU3RhcnQuY2gpO1xuICAgICAgICAgICAgdmFyIGhlYWQgPSBQb3MoaSwgc2VsZWN0aW9uRW5kLmNoKTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHthbmNob3I6IGFuY2hvciwgaGVhZDogaGVhZH07XG4gICAgICAgICAgICBzZWxlY3Rpb25zLnB1c2gocmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHNlbGVjdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFydCA9IGxhc3RTZWxlY3Rpb24uYW5jaG9yTWFyay5maW5kKCk7XG4gICAgICAgICAgdmFyIGVuZCA9IGxhc3RTZWxlY3Rpb24uaGVhZE1hcmsuZmluZCgpO1xuICAgICAgICAgIHZhciBsaW5lID0gZW5kLmxpbmUgLSBzdGFydC5saW5lO1xuICAgICAgICAgIHZhciBjaCA9IGVuZC5jaCAtIHN0YXJ0LmNoO1xuICAgICAgICAgIHNlbGVjdGlvbkVuZCA9IHtsaW5lOiBzZWxlY3Rpb25FbmQubGluZSArIGxpbmUsIGNoOiBsaW5lID8gc2VsZWN0aW9uRW5kLmNoIDogY2ggKyBzZWxlY3Rpb25FbmQuY2h9O1xuICAgICAgICAgIGlmIChsYXN0U2VsZWN0aW9uLnZpc3VhbExpbmUpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gUG9zKHNlbGVjdGlvblN0YXJ0LmxpbmUsIDApO1xuICAgICAgICAgICAgc2VsZWN0aW9uRW5kID0gUG9zKHNlbGVjdGlvbkVuZC5saW5lLCBsaW5lTGVuZ3RoKGNtLCBzZWxlY3Rpb25FbmQubGluZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbS5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kXTtcbiAgICAgIH07XG4gICAgICBpZiAoIXZpbS52aXN1YWxNb2RlKSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIHJlcGxheWluZyB0aGUgYWN0aW9uLlxuICAgICAgICByZXR1cm4gZ2V0TGFzdFNlbGVjdGVkQXJlYVJhbmdlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0Q3VycmVudFNlbGVjdGVkQXJlYVJhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVwZGF0ZXMgdGhlIHByZXZpb3VzIHNlbGVjdGlvbiB3aXRoIHRoZSBjdXJyZW50IHNlbGVjdGlvbidzIHZhbHVlcy4gVGhpc1xuICAgIC8vIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpbiB2aXN1YWwgbW9kZS5cbiAgICBmdW5jdGlvbiB1cGRhdGVMYXN0U2VsZWN0aW9uKGNtLCB2aW0pIHtcbiAgICAgIHZhciBhbmNob3IgPSB2aW0uc2VsLmFuY2hvcjtcbiAgICAgIHZhciBoZWFkID0gdmltLnNlbC5oZWFkO1xuICAgICAgLy8gVG8gYWNjb21tb2RhdGUgdGhlIGVmZmVjdCBvZiBsYXN0UGFzdGVkVGV4dCBpbiB0aGUgbGFzdCBzZWxlY3Rpb25cbiAgICAgIGlmICh2aW0ubGFzdFBhc3RlZFRleHQpIHtcbiAgICAgICAgaGVhZCA9IGNtLnBvc0Zyb21JbmRleChjbS5pbmRleEZyb21Qb3MoYW5jaG9yKSArIHZpbS5sYXN0UGFzdGVkVGV4dC5sZW5ndGgpO1xuICAgICAgICB2aW0ubGFzdFBhc3RlZFRleHQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmltLmxhc3RTZWxlY3Rpb24gPSB7J2FuY2hvck1hcmsnOiBjbS5zZXRCb29rbWFyayhhbmNob3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlYWRNYXJrJzogY20uc2V0Qm9va21hcmsoaGVhZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnYW5jaG9yJzogY29weUN1cnNvcihhbmNob3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlYWQnOiBjb3B5Q3Vyc29yKGhlYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc3VhbE1vZGUnOiB2aW0udmlzdWFsTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICd2aXN1YWxMaW5lJzogdmltLnZpc3VhbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAndmlzdWFsQmxvY2snOiB2aW0udmlzdWFsQmxvY2t9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHBhbmRTZWxlY3Rpb24oY20sIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBzZWwgPSBjbS5zdGF0ZS52aW0uc2VsO1xuICAgICAgdmFyIGhlYWQgPSBzZWwuaGVhZDtcbiAgICAgIHZhciBhbmNob3IgPSBzZWwuYW5jaG9yO1xuICAgICAgdmFyIHRtcDtcbiAgICAgIGlmIChjdXJzb3JJc0JlZm9yZShlbmQsIHN0YXJ0KSkge1xuICAgICAgICB0bXAgPSBlbmQ7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IHRtcDtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJzb3JJc0JlZm9yZShoZWFkLCBhbmNob3IpKSB7XG4gICAgICAgIGhlYWQgPSBjdXJzb3JNaW4oc3RhcnQsIGhlYWQpO1xuICAgICAgICBhbmNob3IgPSBjdXJzb3JNYXgoYW5jaG9yLCBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yID0gY3Vyc29yTWluKHN0YXJ0LCBhbmNob3IpO1xuICAgICAgICBoZWFkID0gY3Vyc29yTWF4KGhlYWQsIGVuZCk7XG4gICAgICAgIGhlYWQgPSBvZmZzZXRDdXJzb3IoaGVhZCwgMCwgLTEpO1xuICAgICAgICBpZiAoaGVhZC5jaCA9PSAtMSAmJiBoZWFkLmxpbmUgIT0gY20uZmlyc3RMaW5lKCkpIHtcbiAgICAgICAgICBoZWFkID0gUG9zKGhlYWQubGluZSAtIDEsIGxpbmVMZW5ndGgoY20sIGhlYWQubGluZSAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFthbmNob3IsIGhlYWRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBDb2RlTWlycm9yIHNlbGVjdGlvbiB0byBtYXRjaCB0aGUgcHJvdmlkZWQgdmltIHNlbGVjdGlvbi5cbiAgICAgKiBJZiBubyBhcmd1bWVudHMgYXJlIGdpdmVuLCBpdCB1c2VzIHRoZSBjdXJyZW50IHZpbSBzZWxlY3Rpb24gc3RhdGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlQ21TZWxlY3Rpb24oY20sIHNlbCwgbW9kZSkge1xuICAgICAgdmFyIHZpbSA9IGNtLnN0YXRlLnZpbTtcbiAgICAgIHNlbCA9IHNlbCB8fCB2aW0uc2VsO1xuICAgICAgdmFyIG1vZGUgPSBtb2RlIHx8XG4gICAgICAgIHZpbS52aXN1YWxMaW5lID8gJ2xpbmUnIDogdmltLnZpc3VhbEJsb2NrID8gJ2Jsb2NrJyA6ICdjaGFyJztcbiAgICAgIHZhciBjbVNlbCA9IG1ha2VDbVNlbGVjdGlvbihjbSwgc2VsLCBtb2RlKTtcbiAgICAgIGNtLnNldFNlbGVjdGlvbnMoY21TZWwucmFuZ2VzLCBjbVNlbC5wcmltYXJ5KTtcbiAgICAgIHVwZGF0ZUZha2VDdXJzb3IoY20pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQ21TZWxlY3Rpb24oY20sIHNlbCwgbW9kZSwgZXhjbHVzaXZlKSB7XG4gICAgICB2YXIgaGVhZCA9IGNvcHlDdXJzb3Ioc2VsLmhlYWQpO1xuICAgICAgdmFyIGFuY2hvciA9IGNvcHlDdXJzb3Ioc2VsLmFuY2hvcik7XG4gICAgICBpZiAobW9kZSA9PSAnY2hhcicpIHtcbiAgICAgICAgdmFyIGhlYWRPZmZzZXQgPSAhZXhjbHVzaXZlICYmICFjdXJzb3JJc0JlZm9yZShzZWwuaGVhZCwgc2VsLmFuY2hvcikgPyAxIDogMDtcbiAgICAgICAgdmFyIGFuY2hvck9mZnNldCA9IGN1cnNvcklzQmVmb3JlKHNlbC5oZWFkLCBzZWwuYW5jaG9yKSA/IDEgOiAwO1xuICAgICAgICBoZWFkID0gb2Zmc2V0Q3Vyc29yKHNlbC5oZWFkLCAwLCBoZWFkT2Zmc2V0KTtcbiAgICAgICAgYW5jaG9yID0gb2Zmc2V0Q3Vyc29yKHNlbC5hbmNob3IsIDAsIGFuY2hvck9mZnNldCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmFuZ2VzOiBbe2FuY2hvcjogYW5jaG9yLCBoZWFkOiBoZWFkfV0sXG4gICAgICAgICAgcHJpbWFyeTogMFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChtb2RlID09ICdsaW5lJykge1xuICAgICAgICBpZiAoIWN1cnNvcklzQmVmb3JlKHNlbC5oZWFkLCBzZWwuYW5jaG9yKSkge1xuICAgICAgICAgIGFuY2hvci5jaCA9IDA7XG5cbiAgICAgICAgICB2YXIgbGFzdExpbmUgPSBjbS5sYXN0TGluZSgpO1xuICAgICAgICAgIGlmIChoZWFkLmxpbmUgPiBsYXN0TGluZSkge1xuICAgICAgICAgICAgaGVhZC5saW5lID0gbGFzdExpbmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhlYWQuY2ggPSBsaW5lTGVuZ3RoKGNtLCBoZWFkLmxpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWQuY2ggPSAwO1xuICAgICAgICAgIGFuY2hvci5jaCA9IGxpbmVMZW5ndGgoY20sIGFuY2hvci5saW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhbmdlczogW3thbmNob3I6IGFuY2hvciwgaGVhZDogaGVhZH1dLFxuICAgICAgICAgIHByaW1hcnk6IDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnYmxvY2snKSB7XG4gICAgICAgIHZhciB0b3AgPSBNYXRoLm1pbihhbmNob3IubGluZSwgaGVhZC5saW5lKSxcbiAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihhbmNob3IuY2gsIGhlYWQuY2gpLFxuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoYW5jaG9yLmxpbmUsIGhlYWQubGluZSksXG4gICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KGFuY2hvci5jaCwgaGVhZC5jaCkgKyAxO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgMTtcbiAgICAgICAgdmFyIHByaW1hcnkgPSBoZWFkLmxpbmUgPT0gdG9wID8gMCA6IGhlaWdodCAtIDE7XG4gICAgICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgIHJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIGFuY2hvcjogUG9zKHRvcCArIGksIGxlZnQpLFxuICAgICAgICAgICAgaGVhZDogUG9zKHRvcCArIGksIHJpZ2h0KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmFuZ2VzOiByYW5nZXMsXG4gICAgICAgICAgcHJpbWFyeTogcHJpbWFyeVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRIZWFkKGNtKSB7XG4gICAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCdoZWFkJyk7XG4gICAgICBpZiAoY20uZ2V0U2VsZWN0aW9uKCkubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gU21hbGwgY29ybmVyIGNhc2Ugd2hlbiBvbmx5IDEgY2hhcmFjdGVyIGlzIHNlbGVjdGVkLiBUaGUgXCJyZWFsXCJcbiAgICAgICAgLy8gaGVhZCBpcyB0aGUgbGVmdCBvZiBoZWFkIGFuZCBhbmNob3IuXG4gICAgICAgIGN1ciA9IGN1cnNvck1pbihjdXIsIGNtLmdldEN1cnNvcignYW5jaG9yJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBtb3ZlSGVhZCBpcyBzZXQgdG8gZmFsc2UsIHRoZSBDb2RlTWlycm9yIHNlbGVjdGlvbiB3aWxsIG5vdCBiZVxuICAgICAqIHRvdWNoZWQuIFRoZSBjYWxsZXIgYXNzdW1lcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgcHV0dGluZyB0aGUgY3Vyc29yXG4gICAgKiBpbiB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhpdFZpc3VhbE1vZGUoY20sIG1vdmVIZWFkKSB7XG4gICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgaWYgKG1vdmVIZWFkICE9PSBmYWxzZSkge1xuICAgICAgICBjbS5zZXRDdXJzb3IoY2xpcEN1cnNvclRvQ29udGVudChjbSwgdmltLnNlbC5oZWFkKSk7XG4gICAgICB9XG4gICAgICB1cGRhdGVMYXN0U2VsZWN0aW9uKGNtLCB2aW0pO1xuICAgICAgdmltLnZpc3VhbE1vZGUgPSBmYWxzZTtcbiAgICAgIHZpbS52aXN1YWxMaW5lID0gZmFsc2U7XG4gICAgICB2aW0udmlzdWFsQmxvY2sgPSBmYWxzZTtcbiAgICAgIGlmICghdmltLmluc2VydE1vZGUpIENvZGVNaXJyb3Iuc2lnbmFsKGNtLCBcInZpbS1tb2RlLWNoYW5nZVwiLCB7bW9kZTogXCJub3JtYWxcIn0pO1xuICAgICAgY2xlYXJGYWtlQ3Vyc29yKHZpbSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSB0cmFpbGluZyBuZXdsaW5lcyBmcm9tIHRoZSBzZWxlY3Rpb24uIEZvclxuICAgIC8vIGV4YW1wbGUsIHdpdGggdGhlIGNhcmV0IGF0IHRoZSBzdGFydCBvZiB0aGUgbGFzdCB3b3JkIG9uIHRoZSBsaW5lLFxuICAgIC8vICdkdycgc2hvdWxkIHdvcmQsIGJ1dCBub3QgdGhlIG5ld2xpbmUsIHdoaWxlICd3JyBzaG91bGQgYWR2YW5jZSB0aGVcbiAgICAvLyBjYXJldCB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBuZXh0IGxpbmUuXG4gICAgZnVuY3Rpb24gY2xpcFRvTGluZShjbSwgY3VyU3RhcnQsIGN1ckVuZCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGNtLmdldFJhbmdlKGN1clN0YXJ0LCBjdXJFbmQpO1xuICAgICAgLy8gT25seSBjbGlwIGlmIHRoZSBzZWxlY3Rpb24gZW5kcyB3aXRoIHRyYWlsaW5nIG5ld2xpbmUgKyB3aGl0ZXNwYWNlXG4gICAgICBpZiAoL1xcblxccyokLy50ZXN0KHNlbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gc2VsZWN0aW9uLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgLy8gV2Uga25vdyB0aGlzIGlzIGFsbCB3aGl0ZXNwYWNlLlxuICAgICAgICBsaW5lcy5wb3AoKTtcblxuICAgICAgICAvLyBDYXNlczpcbiAgICAgICAgLy8gMS4gTGFzdCB3b3JkIGlzIGFuIGVtcHR5IGxpbmUgLSBkbyBub3QgY2xpcCB0aGUgdHJhaWxpbmcgJ1xcbidcbiAgICAgICAgLy8gMi4gTGFzdCB3b3JkIGlzIG5vdCBhbiBlbXB0eSBsaW5lIC0gY2xpcCB0aGUgdHJhaWxpbmcgJ1xcbidcbiAgICAgICAgdmFyIGxpbmU7XG4gICAgICAgIC8vIEZpbmQgdGhlIGxpbmUgY29udGFpbmluZyB0aGUgbGFzdCB3b3JkLCBhbmQgY2xpcCBhbGwgd2hpdGVzcGFjZSB1cFxuICAgICAgICAvLyB0byBpdC5cbiAgICAgICAgZm9yICh2YXIgbGluZSA9IGxpbmVzLnBvcCgpOyBsaW5lcy5sZW5ndGggPiAwICYmIGxpbmUgJiYgaXNXaGl0ZVNwYWNlU3RyaW5nKGxpbmUpOyBsaW5lID0gbGluZXMucG9wKCkpIHtcbiAgICAgICAgICBjdXJFbmQubGluZS0tO1xuICAgICAgICAgIGN1ckVuZC5jaCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGxhc3Qgd29yZCBpcyBub3QgYW4gZW1wdHkgbGluZSwgY2xpcCBhbiBhZGRpdGlvbmFsIG5ld2xpbmVcbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICBjdXJFbmQubGluZS0tO1xuICAgICAgICAgIGN1ckVuZC5jaCA9IGxpbmVMZW5ndGgoY20sIGN1ckVuZC5saW5lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJFbmQuY2ggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhwYW5kIHRoZSBzZWxlY3Rpb24gdG8gbGluZSBlbmRzLlxuICAgIGZ1bmN0aW9uIGV4cGFuZFNlbGVjdGlvblRvTGluZShfY20sIGN1clN0YXJ0LCBjdXJFbmQpIHtcbiAgICAgIGN1clN0YXJ0LmNoID0gMDtcbiAgICAgIGN1ckVuZC5jaCA9IDA7XG4gICAgICBjdXJFbmQubGluZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRGaXJzdE5vbldoaXRlU3BhY2VDaGFyYWN0ZXIodGV4dCkge1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgdmFyIGZpcnN0Tm9uV1MgPSB0ZXh0LnNlYXJjaCgvXFxTLyk7XG4gICAgICByZXR1cm4gZmlyc3ROb25XUyA9PSAtMSA/IHRleHQubGVuZ3RoIDogZmlyc3ROb25XUztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRXb3JkVW5kZXJDdXJzb3IoY20sIGluY2x1c2l2ZSwgX2ZvcndhcmQsIGJpZ1dvcmQsIG5vU3ltYm9sKSB7XG4gICAgICB2YXIgY3VyID0gZ2V0SGVhZChjbSk7XG4gICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUoY3VyLmxpbmUpO1xuICAgICAgdmFyIGlkeCA9IGN1ci5jaDtcblxuICAgICAgLy8gU2VlayB0byBmaXJzdCB3b3JkIG9yIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciwgZGVwZW5kaW5nIG9uIGlmXG4gICAgICAvLyBub1N5bWJvbCBpcyB0cnVlLlxuICAgICAgdmFyIHRlc3QgPSBub1N5bWJvbCA/IHdvcmRDaGFyVGVzdFswXSA6IGJpZ1dvcmRDaGFyVGVzdCBbMF07XG4gICAgICB3aGlsZSAoIXRlc3QobGluZS5jaGFyQXQoaWR4KSkpIHtcbiAgICAgICAgaWR4Kys7XG4gICAgICAgIGlmIChpZHggPj0gbGluZS5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJpZ1dvcmQpIHtcbiAgICAgICAgdGVzdCA9IGJpZ1dvcmRDaGFyVGVzdFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlc3QgPSB3b3JkQ2hhclRlc3RbMF07XG4gICAgICAgIGlmICghdGVzdChsaW5lLmNoYXJBdChpZHgpKSkge1xuICAgICAgICAgIHRlc3QgPSB3b3JkQ2hhclRlc3RbMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGVuZCA9IGlkeCwgc3RhcnQgPSBpZHg7XG4gICAgICB3aGlsZSAodGVzdChsaW5lLmNoYXJBdChlbmQpKSAmJiBlbmQgPCBsaW5lLmxlbmd0aCkgeyBlbmQrKzsgfVxuICAgICAgd2hpbGUgKHRlc3QobGluZS5jaGFyQXQoc3RhcnQpKSAmJiBzdGFydCA+PSAwKSB7IHN0YXJ0LS07IH1cbiAgICAgIHN0YXJ0Kys7XG5cbiAgICAgIGlmIChpbmNsdXNpdmUpIHtcbiAgICAgICAgLy8gSWYgcHJlc2VudCwgaW5jbHVkZSBhbGwgd2hpdGVzcGFjZSBhZnRlciB3b3JkLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGluY2x1ZGUgYWxsIHdoaXRlc3BhY2UgYmVmb3JlIHdvcmQsIGV4Y2VwdCBpbmRlbnRhdGlvbi5cbiAgICAgICAgdmFyIHdvcmRFbmQgPSBlbmQ7XG4gICAgICAgIHdoaWxlICgvXFxzLy50ZXN0KGxpbmUuY2hhckF0KGVuZCkpICYmIGVuZCA8IGxpbmUubGVuZ3RoKSB7IGVuZCsrOyB9XG4gICAgICAgIGlmICh3b3JkRW5kID09IGVuZCkge1xuICAgICAgICAgIHZhciB3b3JkU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICB3aGlsZSAoL1xccy8udGVzdChsaW5lLmNoYXJBdChzdGFydCAtIDEpKSAmJiBzdGFydCA+IDApIHsgc3RhcnQtLTsgfVxuICAgICAgICAgIGlmICghc3RhcnQpIHsgc3RhcnQgPSB3b3JkU3RhcnQ7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3RhcnQ6IFBvcyhjdXIubGluZSwgc3RhcnQpLCBlbmQ6IFBvcyhjdXIubGluZSwgZW5kKSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlcGVuZHMgb24gdGhlIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqIC0gZWRpdG9yIG1vZGUgc2hvdWxkIGJlIGh0bWxtaXhlZG1vZGUgLyB4bWxcbiAgICAgKiAtIG1vZGUveG1sL3htbC5qcyBzaG91bGQgYmUgbG9hZGVkXG4gICAgICogLSBhZGRvbi9mb2xkL3htbC1mb2xkLmpzIHNob3VsZCBiZSBsb2FkZWRcbiAgICAgKlxuICAgICAqIElmIGFueSBvZiB0aGUgYWJvdmUgcmVxdWlyZW1lbnRzIGFyZSBub3QgdHJ1ZSwgdGhpcyBmdW5jdGlvbiBub29wcy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgX05PVF8gYSAxMDAlIGFjY3VyYXRlIGltcGxlbWVudGF0aW9uIG9mIHZpbSB0YWcgdGV4dCBvYmplY3RzLlxuICAgICAqIFRoZSBmb2xsb3dpbmcgY2F2ZWF0cyBhcHBseSAoYmFzZWQgb2ZmIGN1cnNvcnkgdGVzdGluZywgSSdtIHN1cmUgdGhlcmVcbiAgICAgKiBhcmUgb3RoZXIgZGlzY3JlcGFuY2llcyk6XG4gICAgICpcbiAgICAgKiAtIERvZXMgbm90IHdvcmsgaW5zaWRlIGNvbW1lbnRzOlxuICAgICAqICAgYGBgXG4gICAgICogICA8IS0tIDxkaXY+YnJva2VuPC9kaXY+IC0tPlxuICAgICAqICAgYGBgXG4gICAgICogLSBEb2VzIG5vdCB3b3JrIHdoZW4gdGFncyBoYXZlIGRpZmZlcmVudCBjYXNlczpcbiAgICAgKiAgIGBgYFxuICAgICAqICAgPGRpdj5icm9rZW48L0RJVj5cbiAgICAgKiAgIGBgYFxuICAgICAqIC0gRG9lcyBub3Qgd29yayB3aGVuIGN1cnNvciBpcyBpbnNpZGUgYSBicm9rZW4gdGFnOlxuICAgICAqICAgYGBgXG4gICAgICogICA8ZGl2Pjxicm9rPjxlbj48L2Rpdj5cbiAgICAgKiAgIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4cGFuZFRhZ1VuZGVyQ3Vyc29yKGNtLCBoZWFkLCBpbmNsdXNpdmUpIHtcbiAgICAgIHZhciBjdXIgPSBoZWFkO1xuICAgICAgaWYgKCFDb2RlTWlycm9yLmZpbmRNYXRjaGluZ1RhZyB8fCAhQ29kZU1pcnJvci5maW5kRW5jbG9zaW5nVGFnKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBjdXIsIGVuZDogY3VyIH07XG4gICAgICB9XG5cbiAgICAgIHZhciB0YWdzID0gQ29kZU1pcnJvci5maW5kTWF0Y2hpbmdUYWcoY20sIGhlYWQpIHx8IENvZGVNaXJyb3IuZmluZEVuY2xvc2luZ1RhZyhjbSwgaGVhZCk7XG4gICAgICBpZiAoIXRhZ3MgfHwgIXRhZ3Mub3BlbiB8fCAhdGFncy5jbG9zZSkge1xuICAgICAgICByZXR1cm4geyBzdGFydDogY3VyLCBlbmQ6IGN1ciB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiB0YWdzLm9wZW4uZnJvbSwgZW5kOiB0YWdzLmNsb3NlLnRvIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGFydDogdGFncy5vcGVuLnRvLCBlbmQ6IHRhZ3MuY2xvc2UuZnJvbSB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlY29yZEp1bXBQb3NpdGlvbihjbSwgb2xkQ3VyLCBuZXdDdXIpIHtcbiAgICAgIGlmICghY3Vyc29yRXF1YWwob2xkQ3VyLCBuZXdDdXIpKSB7XG4gICAgICAgIHZpbUdsb2JhbFN0YXRlLmp1bXBMaXN0LmFkZChjbSwgb2xkQ3VyLCBuZXdDdXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlY29yZExhc3RDaGFyYWN0ZXJTZWFyY2goaW5jcmVtZW50LCBhcmdzKSB7XG4gICAgICAgIHZpbUdsb2JhbFN0YXRlLmxhc3RDaGFyYWN0ZXJTZWFyY2guaW5jcmVtZW50ID0gaW5jcmVtZW50O1xuICAgICAgICB2aW1HbG9iYWxTdGF0ZS5sYXN0Q2hhcmFjdGVyU2VhcmNoLmZvcndhcmQgPSBhcmdzLmZvcndhcmQ7XG4gICAgICAgIHZpbUdsb2JhbFN0YXRlLmxhc3RDaGFyYWN0ZXJTZWFyY2guc2VsZWN0ZWRDaGFyYWN0ZXIgPSBhcmdzLnNlbGVjdGVkQ2hhcmFjdGVyO1xuICAgIH1cblxuICAgIHZhciBzeW1ib2xUb01vZGUgPSB7XG4gICAgICAgICcoJzogJ2JyYWNrZXQnLCAnKSc6ICdicmFja2V0JywgJ3snOiAnYnJhY2tldCcsICd9JzogJ2JyYWNrZXQnLFxuICAgICAgICAnWyc6ICdzZWN0aW9uJywgJ10nOiAnc2VjdGlvbicsXG4gICAgICAgICcqJzogJ2NvbW1lbnQnLCAnLyc6ICdjb21tZW50JyxcbiAgICAgICAgJ20nOiAnbWV0aG9kJywgJ00nOiAnbWV0aG9kJyxcbiAgICAgICAgJyMnOiAncHJlcHJvY2VzcydcbiAgICB9O1xuICAgIHZhciBmaW5kU3ltYm9sTW9kZXMgPSB7XG4gICAgICBicmFja2V0OiB7XG4gICAgICAgIGlzQ29tcGxldGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLm5leHRDaCA9PT0gc3RhdGUuc3ltYikge1xuICAgICAgICAgICAgc3RhdGUuZGVwdGgrKztcbiAgICAgICAgICAgIGlmIChzdGF0ZS5kZXB0aCA+PSAxKXJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubmV4dENoID09PSBzdGF0ZS5yZXZlcnNlU3ltYikge1xuICAgICAgICAgICAgc3RhdGUuZGVwdGgtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2VjdGlvbjoge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIHN0YXRlLmN1ck1vdmVUaHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgICBzdGF0ZS5zeW1iID0gKHN0YXRlLmZvcndhcmQgPyAnXScgOiAnWycpID09PSBzdGF0ZS5zeW1iID8gJ3snIDogJ30nO1xuICAgICAgICB9LFxuICAgICAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5pbmRleCA9PT0gMCAmJiBzdGF0ZS5uZXh0Q2ggPT09IHN0YXRlLnN5bWI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb21tZW50OiB7XG4gICAgICAgIGlzQ29tcGxldGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gc3RhdGUubGFzdENoID09PSAnKicgJiYgc3RhdGUubmV4dENoID09PSAnLyc7XG4gICAgICAgICAgc3RhdGUubGFzdENoID0gc3RhdGUubmV4dENoO1xuICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFRPRE86IFRoZSBvcmlnaW5hbCBWaW0gaW1wbGVtZW50YXRpb24gb25seSBvcGVyYXRlcyBvbiBsZXZlbCAxIGFuZCAyLlxuICAgICAgLy8gVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gZG9lc24ndCBjaGVjayBmb3IgY29kZSBibG9jayBsZXZlbCBhbmRcbiAgICAgIC8vIHRoZXJlZm9yZSBpdCBvcGVyYXRlcyBvbiBhbnkgbGV2ZWxzLlxuICAgICAgbWV0aG9kOiB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgc3RhdGUuc3ltYiA9IChzdGF0ZS5zeW1iID09PSAnbScgPyAneycgOiAnfScpO1xuICAgICAgICAgIHN0YXRlLnJldmVyc2VTeW1iID0gc3RhdGUuc3ltYiA9PT0gJ3snID8gJ30nIDogJ3snO1xuICAgICAgICB9LFxuICAgICAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5uZXh0Q2ggPT09IHN0YXRlLnN5bWIpcmV0dXJuIHRydWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJlcHJvY2Vzczoge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgIHN0YXRlLmluZGV4ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgaXNDb21wbGV0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUubmV4dENoID09PSAnIycpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHN0YXRlLmxpbmVUZXh0Lm1hdGNoKC9eIyhcXHcrKS8pWzFdO1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSAnZW5kaWYnKSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5mb3J3YXJkICYmIHN0YXRlLmRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUuZGVwdGgrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICdpZicpIHtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5mb3J3YXJkICYmIHN0YXRlLmRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUuZGVwdGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJ2Vsc2UnICYmIHN0YXRlLmRlcHRoID09PSAwKXJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZpbmRTeW1ib2woY20sIHJlcGVhdCwgZm9yd2FyZCwgc3ltYikge1xuICAgICAgdmFyIGN1ciA9IGNvcHlDdXJzb3IoY20uZ2V0Q3Vyc29yKCkpO1xuICAgICAgdmFyIGluY3JlbWVudCA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICB2YXIgZW5kTGluZSA9IGZvcndhcmQgPyBjbS5saW5lQ291bnQoKSA6IC0xO1xuICAgICAgdmFyIGN1ckNoID0gY3VyLmNoO1xuICAgICAgdmFyIGxpbmUgPSBjdXIubGluZTtcbiAgICAgIHZhciBsaW5lVGV4dCA9IGNtLmdldExpbmUobGluZSk7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGxpbmVUZXh0OiBsaW5lVGV4dCxcbiAgICAgICAgbmV4dENoOiBsaW5lVGV4dC5jaGFyQXQoY3VyQ2gpLFxuICAgICAgICBsYXN0Q2g6IG51bGwsXG4gICAgICAgIGluZGV4OiBjdXJDaCxcbiAgICAgICAgc3ltYjogc3ltYixcbiAgICAgICAgcmV2ZXJzZVN5bWI6IChmb3J3YXJkID8gIHsgJyknOiAnKCcsICd9JzogJ3snIH0gOiB7ICcoJzogJyknLCAneyc6ICd9JyB9KVtzeW1iXSxcbiAgICAgICAgZm9yd2FyZDogZm9yd2FyZCxcbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgIGN1ck1vdmVUaHJvdWdoOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciBtb2RlID0gc3ltYm9sVG9Nb2RlW3N5bWJdO1xuICAgICAgaWYgKCFtb2RlKXJldHVybiBjdXI7XG4gICAgICB2YXIgaW5pdCA9IGZpbmRTeW1ib2xNb2Rlc1ttb2RlXS5pbml0O1xuICAgICAgdmFyIGlzQ29tcGxldGUgPSBmaW5kU3ltYm9sTW9kZXNbbW9kZV0uaXNDb21wbGV0ZTtcbiAgICAgIGlmIChpbml0KSB7IGluaXQoc3RhdGUpOyB9XG4gICAgICB3aGlsZSAobGluZSAhPT0gZW5kTGluZSAmJiByZXBlYXQpIHtcbiAgICAgICAgc3RhdGUuaW5kZXggKz0gaW5jcmVtZW50O1xuICAgICAgICBzdGF0ZS5uZXh0Q2ggPSBzdGF0ZS5saW5lVGV4dC5jaGFyQXQoc3RhdGUuaW5kZXgpO1xuICAgICAgICBpZiAoIXN0YXRlLm5leHRDaCkge1xuICAgICAgICAgIGxpbmUgKz0gaW5jcmVtZW50O1xuICAgICAgICAgIHN0YXRlLmxpbmVUZXh0ID0gY20uZ2V0TGluZShsaW5lKSB8fCAnJztcbiAgICAgICAgICBpZiAoaW5jcmVtZW50ID4gMCkge1xuICAgICAgICAgICAgc3RhdGUuaW5kZXggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGluZUxlbiA9IHN0YXRlLmxpbmVUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXRlLmluZGV4ID0gKGxpbmVMZW4gPiAwKSA/IChsaW5lTGVuLTEpIDogMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUubmV4dENoID0gc3RhdGUubGluZVRleHQuY2hhckF0KHN0YXRlLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb21wbGV0ZShzdGF0ZSkpIHtcbiAgICAgICAgICBjdXIubGluZSA9IGxpbmU7XG4gICAgICAgICAgY3VyLmNoID0gc3RhdGUuaW5kZXg7XG4gICAgICAgICAgcmVwZWF0LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5uZXh0Q2ggfHwgc3RhdGUuY3VyTW92ZVRocm91Z2gpIHtcbiAgICAgICAgcmV0dXJuIFBvcyhsaW5lLCBzdGF0ZS5pbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VyO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmV0dXJucyB0aGUgYm91bmRhcmllcyBvZiB0aGUgbmV4dCB3b3JkLiBJZiB0aGUgY3Vyc29yIGluIHRoZSBtaWRkbGUgb2ZcbiAgICAgKiB0aGUgd29yZCwgdGhlbiByZXR1cm5zIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBjdXJyZW50IHdvcmQsIHN0YXJ0aW5nIGF0XG4gICAgICogdGhlIGN1cnNvci4gSWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgc3RhcnQvZW5kIG9mIGEgd29yZCwgYW5kIHdlIGFyZSBnb2luZ1xuICAgICAqIGZvcndhcmQvYmFja3dhcmQsIHJlc3BlY3RpdmVseSwgZmluZCB0aGUgYm91bmRhcmllcyBvZiB0aGUgbmV4dCB3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb2RlTWlycm9yfSBjbSBDb2RlTWlycm9yIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0N1cnNvcn0gY3VyIFRoZSBjdXJzb3IgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkIFRydWUgdG8gc2VhcmNoIGZvcndhcmQuIEZhbHNlIHRvIHNlYXJjaFxuICAgICAqICAgICBiYWNrd2FyZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpZ1dvcmQgVHJ1ZSBpZiBwdW5jdHVhdGlvbiBjb3VudCBhcyBwYXJ0IG9mIHRoZSB3b3JkLlxuICAgICAqICAgICBGYWxzZSBpZiBvbmx5IFthLXpBLVowLTldIGNoYXJhY3RlcnMgY291bnQgYXMgcGFydCBvZiB0aGUgd29yZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVtcHR5TGluZUlzV29yZCBUcnVlIGlmIGVtcHR5IGxpbmVzIHNob3VsZCBiZSB0cmVhdGVkXG4gICAgICogICAgIGFzIHdvcmRzLlxuICAgICAqIEByZXR1cm4ge09iamVjdHtmcm9tOm51bWJlciwgdG86bnVtYmVyLCBsaW5lOiBudW1iZXJ9fSBUaGUgYm91bmRhcmllcyBvZlxuICAgICAqICAgICB0aGUgd29yZCwgb3IgbnVsbCBpZiB0aGVyZSBhcmUgbm8gbW9yZSB3b3Jkcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kV29yZChjbSwgY3VyLCBmb3J3YXJkLCBiaWdXb3JkLCBlbXB0eUxpbmVJc1dvcmQpIHtcbiAgICAgIHZhciBsaW5lTnVtID0gY3VyLmxpbmU7XG4gICAgICB2YXIgcG9zID0gY3VyLmNoO1xuICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKGxpbmVOdW0pO1xuICAgICAgdmFyIGRpciA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICB2YXIgY2hhclRlc3RzID0gYmlnV29yZCA/IGJpZ1dvcmRDaGFyVGVzdDogd29yZENoYXJUZXN0O1xuXG4gICAgICBpZiAoZW1wdHlMaW5lSXNXb3JkICYmIGxpbmUgPT0gJycpIHtcbiAgICAgICAgbGluZU51bSArPSBkaXI7XG4gICAgICAgIGxpbmUgPSBjbS5nZXRMaW5lKGxpbmVOdW0pO1xuICAgICAgICBpZiAoIWlzTGluZShjbSwgbGluZU51bSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSAoZm9yd2FyZCkgPyAwIDogbGluZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChlbXB0eUxpbmVJc1dvcmQgJiYgbGluZSA9PSAnJykge1xuICAgICAgICAgIHJldHVybiB7IGZyb206IDAsIHRvOiAwLCBsaW5lOiBsaW5lTnVtIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0b3AgPSAoZGlyID4gMCkgPyBsaW5lLmxlbmd0aCA6IC0xO1xuICAgICAgICB2YXIgd29yZFN0YXJ0ID0gc3RvcCwgd29yZEVuZCA9IHN0b3A7XG4gICAgICAgIC8vIEZpbmQgYm91bmRzIG9mIG5leHQgd29yZC5cbiAgICAgICAgd2hpbGUgKHBvcyAhPSBzdG9wKSB7XG4gICAgICAgICAgdmFyIGZvdW5kV29yZCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhclRlc3RzLmxlbmd0aCAmJiAhZm91bmRXb3JkOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjaGFyVGVzdHNbaV0obGluZS5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgd29yZFN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIGVuZCBvZiB3b3JkLlxuICAgICAgICAgICAgICB3aGlsZSAocG9zICE9IHN0b3AgJiYgY2hhclRlc3RzW2ldKGxpbmUuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3b3JkRW5kID0gcG9zO1xuICAgICAgICAgICAgICBmb3VuZFdvcmQgPSB3b3JkU3RhcnQgIT0gd29yZEVuZDtcbiAgICAgICAgICAgICAgaWYgKHdvcmRTdGFydCA9PSBjdXIuY2ggJiYgbGluZU51bSA9PSBjdXIubGluZSAmJlxuICAgICAgICAgICAgICAgICAgd29yZEVuZCA9PSB3b3JkU3RhcnQgKyBkaXIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzdGFydGVkIGF0IHRoZSBlbmQgb2YgYSB3b3JkLiBGaW5kIHRoZSBuZXh0IG9uZS5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZnJvbTogTWF0aC5taW4od29yZFN0YXJ0LCB3b3JkRW5kICsgMSksXG4gICAgICAgICAgICAgICAgICB0bzogTWF0aC5tYXgod29yZFN0YXJ0LCB3b3JkRW5kKSxcbiAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW0gfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kV29yZCkge1xuICAgICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWR2YW5jZSB0byBuZXh0L3ByZXYgbGluZS5cbiAgICAgICAgbGluZU51bSArPSBkaXI7XG4gICAgICAgIGlmICghaXNMaW5lKGNtLCBsaW5lTnVtKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSBjbS5nZXRMaW5lKGxpbmVOdW0pO1xuICAgICAgICBwb3MgPSAoZGlyID4gMCkgPyAwIDogbGluZS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb2RlTWlycm9yfSBjbSBDb2RlTWlycm9yIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1Bvc30gY3VyIFRoZSBwb3NpdGlvbiB0byBzdGFydCBmcm9tLlxuICAgICAqIEBwYXJhbSB7aW50fSByZXBlYXQgTnVtYmVyIG9mIHdvcmRzIHRvIG1vdmUgcGFzdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmQgVHJ1ZSB0byBzZWFyY2ggZm9yd2FyZC4gRmFsc2UgdG8gc2VhcmNoXG4gICAgICogICAgIGJhY2t3YXJkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd29yZEVuZCBUcnVlIHRvIG1vdmUgdG8gZW5kIG9mIHdvcmQuIEZhbHNlIHRvIG1vdmUgdG9cbiAgICAgKiAgICAgYmVnaW5uaW5nIG9mIHdvcmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaWdXb3JkIFRydWUgaWYgcHVuY3R1YXRpb24gY291bnQgYXMgcGFydCBvZiB0aGUgd29yZC5cbiAgICAgKiAgICAgRmFsc2UgaWYgb25seSBhbHBoYWJldCBjaGFyYWN0ZXJzIGNvdW50IGFzIHBhcnQgb2YgdGhlIHdvcmQuXG4gICAgICogQHJldHVybiB7Q3Vyc29yfSBUaGUgcG9zaXRpb24gdGhlIGN1cnNvciBzaG91bGQgbW92ZSB0by5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb3ZlVG9Xb3JkKGNtLCBjdXIsIHJlcGVhdCwgZm9yd2FyZCwgd29yZEVuZCwgYmlnV29yZCkge1xuICAgICAgdmFyIGN1clN0YXJ0ID0gY29weUN1cnNvcihjdXIpO1xuICAgICAgdmFyIHdvcmRzID0gW107XG4gICAgICBpZiAoZm9yd2FyZCAmJiAhd29yZEVuZCB8fCAhZm9yd2FyZCAmJiB3b3JkRW5kKSB7XG4gICAgICAgIHJlcGVhdCsrO1xuICAgICAgfVxuICAgICAgLy8gRm9yICdlJywgZW1wdHkgbGluZXMgYXJlIG5vdCBjb25zaWRlcmVkIHdvcmRzLCBnbyBmaWd1cmUuXG4gICAgICB2YXIgZW1wdHlMaW5lSXNXb3JkID0gIShmb3J3YXJkICYmIHdvcmRFbmQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBlYXQ7IGkrKykge1xuICAgICAgICB2YXIgd29yZCA9IGZpbmRXb3JkKGNtLCBjdXIsIGZvcndhcmQsIGJpZ1dvcmQsIGVtcHR5TGluZUlzV29yZCk7XG4gICAgICAgIGlmICghd29yZCkge1xuICAgICAgICAgIHZhciBlb2RDaCA9IGxpbmVMZW5ndGgoY20sIGNtLmxhc3RMaW5lKCkpO1xuICAgICAgICAgIHdvcmRzLnB1c2goZm9yd2FyZFxuICAgICAgICAgICAgICA/IHtsaW5lOiBjbS5sYXN0TGluZSgpLCBmcm9tOiBlb2RDaCwgdG86IGVvZENofVxuICAgICAgICAgICAgICA6IHtsaW5lOiAwLCBmcm9tOiAwLCB0bzogMH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHdvcmRzLnB1c2god29yZCk7XG4gICAgICAgIGN1ciA9IFBvcyh3b3JkLmxpbmUsIGZvcndhcmQgPyAod29yZC50byAtIDEpIDogd29yZC5mcm9tKTtcbiAgICAgIH1cbiAgICAgIHZhciBzaG9ydENpcmN1aXQgPSB3b3Jkcy5sZW5ndGggIT0gcmVwZWF0O1xuICAgICAgdmFyIGZpcnN0V29yZCA9IHdvcmRzWzBdO1xuICAgICAgdmFyIGxhc3RXb3JkID0gd29yZHMucG9wKCk7XG4gICAgICBpZiAoZm9yd2FyZCAmJiAhd29yZEVuZCkge1xuICAgICAgICAvLyB3XG4gICAgICAgIGlmICghc2hvcnRDaXJjdWl0ICYmIChmaXJzdFdvcmQuZnJvbSAhPSBjdXJTdGFydC5jaCB8fCBmaXJzdFdvcmQubGluZSAhPSBjdXJTdGFydC5saW5lKSkge1xuICAgICAgICAgIC8vIFdlIGRpZCBub3Qgc3RhcnQgaW4gdGhlIG1pZGRsZSBvZiBhIHdvcmQuIERpc2NhcmQgdGhlIGV4dHJhIHdvcmQgYXQgdGhlIGVuZC5cbiAgICAgICAgICBsYXN0V29yZCA9IHdvcmRzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQb3MobGFzdFdvcmQubGluZSwgbGFzdFdvcmQuZnJvbSk7XG4gICAgICB9IGVsc2UgaWYgKGZvcndhcmQgJiYgd29yZEVuZCkge1xuICAgICAgICByZXR1cm4gUG9zKGxhc3RXb3JkLmxpbmUsIGxhc3RXb3JkLnRvIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKCFmb3J3YXJkICYmIHdvcmRFbmQpIHtcbiAgICAgICAgLy8gZ2VcbiAgICAgICAgaWYgKCFzaG9ydENpcmN1aXQgJiYgKGZpcnN0V29yZC50byAhPSBjdXJTdGFydC5jaCB8fCBmaXJzdFdvcmQubGluZSAhPSBjdXJTdGFydC5saW5lKSkge1xuICAgICAgICAgIC8vIFdlIGRpZCBub3Qgc3RhcnQgaW4gdGhlIG1pZGRsZSBvZiBhIHdvcmQuIERpc2NhcmQgdGhlIGV4dHJhIHdvcmQgYXQgdGhlIGVuZC5cbiAgICAgICAgICBsYXN0V29yZCA9IHdvcmRzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQb3MobGFzdFdvcmQubGluZSwgbGFzdFdvcmQudG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYlxuICAgICAgICByZXR1cm4gUG9zKGxhc3RXb3JkLmxpbmUsIGxhc3RXb3JkLmZyb20pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdmVUb0VvbChjbSwgaGVhZCwgbW90aW9uQXJncywgdmltLCBrZWVwSFBvcykge1xuICAgICAgdmFyIGN1ciA9IGhlYWQ7XG4gICAgICB2YXIgcmV0dmFsPSBQb3MoY3VyLmxpbmUgKyBtb3Rpb25BcmdzLnJlcGVhdCAtIDEsIEluZmluaXR5KTtcbiAgICAgIHZhciBlbmQ9Y20uY2xpcFBvcyhyZXR2YWwpO1xuICAgICAgZW5kLmNoLS07XG4gICAgICBpZiAoIWtlZXBIUG9zKSB7XG4gICAgICAgIHZpbS5sYXN0SFBvcyA9IEluZmluaXR5O1xuICAgICAgICB2aW0ubGFzdEhTUG9zID0gY20uY2hhckNvb3JkcyhlbmQsJ2RpdicpLmxlZnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdmVUb0NoYXJhY3RlcihjbSwgcmVwZWF0LCBmb3J3YXJkLCBjaGFyYWN0ZXIpIHtcbiAgICAgIHZhciBjdXIgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICAgIHZhciBzdGFydCA9IGN1ci5jaDtcbiAgICAgIHZhciBpZHg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGVhdDsgaSArKykge1xuICAgICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUoY3VyLmxpbmUpO1xuICAgICAgICBpZHggPSBjaGFySWR4SW5MaW5lKHN0YXJ0LCBsaW5lLCBjaGFyYWN0ZXIsIGZvcndhcmQsIHRydWUpO1xuICAgICAgICBpZiAoaWR4ID09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gUG9zKGNtLmdldEN1cnNvcigpLmxpbmUsIGlkeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZVRvQ29sdW1uKGNtLCByZXBlYXQpIHtcbiAgICAgIC8vIHJlcGVhdCBpcyBhbHdheXMgPj0gMSwgc28gcmVwZWF0IC0gMSBhbHdheXMgY29ycmVzcG9uZHNcbiAgICAgIC8vIHRvIHRoZSBjb2x1bW4gd2Ugd2FudCB0byBnbyB0by5cbiAgICAgIHZhciBsaW5lID0gY20uZ2V0Q3Vyc29yKCkubGluZTtcbiAgICAgIHJldHVybiBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBQb3MobGluZSwgcmVwZWF0IC0gMSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1hcmsoY20sIHZpbSwgbWFya05hbWUsIHBvcykge1xuICAgICAgaWYgKCFpbkFycmF5KG1hcmtOYW1lLCB2YWxpZE1hcmtzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmltLm1hcmtzW21hcmtOYW1lXSkge1xuICAgICAgICB2aW0ubWFya3NbbWFya05hbWVdLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICB2aW0ubWFya3NbbWFya05hbWVdID0gY20uc2V0Qm9va21hcmsocG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFySWR4SW5MaW5lKHN0YXJ0LCBsaW5lLCBjaGFyYWN0ZXIsIGZvcndhcmQsIGluY2x1ZGVDaGFyKSB7XG4gICAgICAvLyBTZWFyY2ggZm9yIGNoYXIgaW4gbGluZS5cbiAgICAgIC8vIG1vdGlvbl9vcHRpb25zOiB7Zm9yd2FyZCwgaW5jbHVkZUNoYXJ9XG4gICAgICAvLyBJZiBpbmNsdWRlQ2hhciA9IHRydWUsIGluY2x1ZGUgaXQgdG9vLlxuICAgICAgLy8gSWYgZm9yd2FyZCA9IHRydWUsIHNlYXJjaCBmb3J3YXJkLCBlbHNlIHNlYXJjaCBiYWNrd2FyZHMuXG4gICAgICAvLyBJZiBjaGFyIGlzIG5vdCBmb3VuZCBvbiB0aGlzIGxpbmUsIGRvIG5vdGhpbmdcbiAgICAgIHZhciBpZHg7XG4gICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICBpZHggPSBsaW5lLmluZGV4T2YoY2hhcmFjdGVyLCBzdGFydCArIDEpO1xuICAgICAgICBpZiAoaWR4ICE9IC0xICYmICFpbmNsdWRlQ2hhcikge1xuICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHggPSBsaW5lLmxhc3RJbmRleE9mKGNoYXJhY3Rlciwgc3RhcnQgLSAxKTtcbiAgICAgICAgaWYgKGlkeCAhPSAtMSAmJiAhaW5jbHVkZUNoYXIpIHtcbiAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kUGFyYWdyYXBoKGNtLCBoZWFkLCByZXBlYXQsIGRpciwgaW5jbHVzaXZlKSB7XG4gICAgICB2YXIgbGluZSA9IGhlYWQubGluZTtcbiAgICAgIHZhciBtaW4gPSBjbS5maXJzdExpbmUoKTtcbiAgICAgIHZhciBtYXggPSBjbS5sYXN0TGluZSgpO1xuICAgICAgdmFyIHN0YXJ0LCBlbmQsIGkgPSBsaW5lO1xuICAgICAgZnVuY3Rpb24gaXNFbXB0eShpKSB7IHJldHVybiAhY20uZ2V0TGluZShpKTsgfVxuICAgICAgZnVuY3Rpb24gaXNCb3VuZGFyeShpLCBkaXIsIGFueSkge1xuICAgICAgICBpZiAoYW55KSB7IHJldHVybiBpc0VtcHR5KGkpICE9IGlzRW1wdHkoaSArIGRpcik7IH1cbiAgICAgICAgcmV0dXJuICFpc0VtcHR5KGkpICYmIGlzRW1wdHkoaSArIGRpcik7XG4gICAgICB9XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHdoaWxlIChtaW4gPD0gaSAmJiBpIDw9IG1heCAmJiByZXBlYXQgPiAwKSB7XG4gICAgICAgICAgaWYgKGlzQm91bmRhcnkoaSwgZGlyKSkgeyByZXBlYXQtLTsgfVxuICAgICAgICAgIGkgKz0gZGlyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zKGksIDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgaWYgKHZpbS52aXN1YWxMaW5lICYmIGlzQm91bmRhcnkobGluZSwgMSwgdHJ1ZSkpIHtcbiAgICAgICAgdmFyIGFuY2hvciA9IHZpbS5zZWwuYW5jaG9yO1xuICAgICAgICBpZiAoaXNCb3VuZGFyeShhbmNob3IubGluZSwgLTEsIHRydWUpKSB7XG4gICAgICAgICAgaWYgKCFpbmNsdXNpdmUgfHwgYW5jaG9yLmxpbmUgIT0gbGluZSkge1xuICAgICAgICAgICAgbGluZSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHN0YXJ0U3RhdGUgPSBpc0VtcHR5KGxpbmUpO1xuICAgICAgZm9yIChpID0gbGluZTsgaSA8PSBtYXggJiYgcmVwZWF0OyBpKyspIHtcbiAgICAgICAgaWYgKGlzQm91bmRhcnkoaSwgMSwgdHJ1ZSkpIHtcbiAgICAgICAgICBpZiAoIWluY2x1c2l2ZSB8fCBpc0VtcHR5KGkpICE9IHN0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHJlcGVhdC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW5kID0gbmV3IFBvcyhpLCAwKTtcbiAgICAgIC8vIHNlbGVjdCBib3VuZGFyeSBiZWZvcmUgcGFyYWdyYXBoIGZvciB0aGUgbGFzdCBvbmVcbiAgICAgIGlmIChpID4gbWF4ICYmICFzdGFydFN0YXRlKSB7IHN0YXJ0U3RhdGUgPSB0cnVlOyB9XG4gICAgICBlbHNlIHsgaW5jbHVzaXZlID0gZmFsc2U7IH1cbiAgICAgIGZvciAoaSA9IGxpbmU7IGkgPiBtaW47IGktLSkge1xuICAgICAgICBpZiAoIWluY2x1c2l2ZSB8fCBpc0VtcHR5KGkpID09IHN0YXJ0U3RhdGUgfHwgaSA9PSBsaW5lKSB7XG4gICAgICAgICAgaWYgKGlzQm91bmRhcnkoaSwgLTEsIHRydWUpKSB7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gbmV3IFBvcyhpLCAwKTtcbiAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kU2VudGVuY2UoY20sIGN1ciwgcmVwZWF0LCBkaXIpIHtcblxuICAgICAgLypcbiAgICAgICAgVGFrZXMgYW4gaW5kZXggb2JqZWN0XG4gICAgICAgIHtcbiAgICAgICAgICBsaW5lOiB0aGUgbGluZSBzdHJpbmcsXG4gICAgICAgICAgbG46IGxpbmUgbnVtYmVyLFxuICAgICAgICAgIHBvczogaW5kZXggaW4gbGluZSxcbiAgICAgICAgICBkaXI6IGRpcmVjdGlvbiBvZiB0cmF2ZXJzYWwgKC0xIG9yIDEpXG4gICAgICAgIH1cbiAgICAgICAgYW5kIG1vZGlmaWVzIHRoZSBsaW5lLCBsbiwgYW5kIHBvcyBtZW1iZXJzIHRvIHJlcHJlc2VudCB0aGVcbiAgICAgICAgbmV4dCB2YWxpZCBwb3NpdGlvbiBvciBzZXRzIHRoZW0gdG8gbnVsbCBpZiB0aGVyZSBhcmVcbiAgICAgICAgbm8gbW9yZSB2YWxpZCBwb3NpdGlvbnMuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIG5leHRDaGFyKGNtLCBpZHgpIHtcbiAgICAgICAgaWYgKGlkeC5wb3MgKyBpZHguZGlyIDwgMCB8fCBpZHgucG9zICsgaWR4LmRpciA+PSBpZHgubGluZS5sZW5ndGgpIHtcbiAgICAgICAgICBpZHgubG4gKz0gaWR4LmRpcjtcbiAgICAgICAgICBpZiAoIWlzTGluZShjbSwgaWR4LmxuKSkge1xuICAgICAgICAgICAgaWR4LmxpbmUgPSBudWxsO1xuICAgICAgICAgICAgaWR4LmxuID0gbnVsbDtcbiAgICAgICAgICAgIGlkeC5wb3MgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZHgubGluZSA9IGNtLmdldExpbmUoaWR4LmxuKTtcbiAgICAgICAgICBpZHgucG9zID0gKGlkeC5kaXIgPiAwKSA/IDAgOiBpZHgubGluZS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlkeC5wb3MgKz0gaWR4LmRpcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRyYXZlcnNhbCBpbiBmb3J3YXJkIGRpcmVjdGlvblxuICAgICAgICBSZXR1cm5zIGFuIGluZGV4IG9iamVjdCBvZiB0aGUgbmV3IGxvY2F0aW9uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGZvcndhcmQoY20sIGxuLCBwb3MsIGRpcikge1xuICAgICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUobG4pO1xuICAgICAgICB2YXIgc3RvcCA9IChsaW5lID09PSBcIlwiKTtcblxuICAgICAgICB2YXIgY3VyciA9IHtcbiAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgIGxuOiBsbixcbiAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICBkaXI6IGRpcixcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0X3ZhbGlkID0ge1xuICAgICAgICAgIGxuOiBjdXJyLmxuLFxuICAgICAgICAgIHBvczogY3Vyci5wb3MsXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2tpcF9lbXB0eV9saW5lcyA9IChjdXJyLmxpbmUgPT09IFwiXCIpO1xuXG4gICAgICAgIC8vIE1vdmUgb25lIHN0ZXAgdG8gc2tpcCBjaGFyYWN0ZXIgd2Ugc3RhcnQgb25cbiAgICAgICAgbmV4dENoYXIoY20sIGN1cnIpO1xuXG4gICAgICAgIHdoaWxlIChjdXJyLmxpbmUgIT09IG51bGwpIHtcbiAgICAgICAgICBsYXN0X3ZhbGlkLmxuID0gY3Vyci5sbjtcbiAgICAgICAgICBsYXN0X3ZhbGlkLnBvcyA9IGN1cnIucG9zO1xuXG4gICAgICAgICAgaWYgKGN1cnIubGluZSA9PT0gXCJcIiAmJiAhc2tpcF9lbXB0eV9saW5lcykge1xuICAgICAgICAgICAgcmV0dXJuIHsgbG46IGN1cnIubG4sIHBvczogY3Vyci5wb3MsIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHN0b3AgJiYgY3Vyci5saW5lICE9PSBcIlwiICYmICFpc1doaXRlU3BhY2VTdHJpbmcoY3Vyci5saW5lW2N1cnIucG9zXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxuOiBjdXJyLmxuLCBwb3M6IGN1cnIucG9zLCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0VuZE9mU2VudGVuY2VTeW1ib2woY3Vyci5saW5lW2N1cnIucG9zXSlcbiAgICAgICAgICAgICYmICFzdG9wXG4gICAgICAgICAgICAmJiAoY3Vyci5wb3MgPT09IGN1cnIubGluZS5sZW5ndGggLSAxXG4gICAgICAgICAgICAgIHx8IGlzV2hpdGVTcGFjZVN0cmluZyhjdXJyLmxpbmVbY3Vyci5wb3MgKyAxXSkpKSB7XG4gICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0Q2hhcihjbSwgY3Vycik7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgIFNldCB0aGUgcG9zaXRpb24gdG8gdGhlIGxhc3Qgbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyIG9uIHRoZSBsYXN0XG4gICAgICAgICAgdmFsaWQgbGluZSBpbiB0aGUgY2FzZSB0aGF0IHdlIHJlYWNoIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICAqL1xuICAgICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUobGFzdF92YWxpZC5sbik7XG4gICAgICAgIGxhc3RfdmFsaWQucG9zID0gMDtcbiAgICAgICAgZm9yKHZhciBpID0gbGluZS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIGlmICghaXNXaGl0ZVNwYWNlU3RyaW5nKGxpbmVbaV0pKSB7XG4gICAgICAgICAgICBsYXN0X3ZhbGlkLnBvcyA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFzdF92YWxpZDtcblxuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRyYXZlcnNhbCBpbiByZXZlcnNlIGRpcmVjdGlvblxuICAgICAgICBSZXR1cm5zIGFuIGluZGV4IG9iamVjdCBvZiB0aGUgbmV3IGxvY2F0aW9uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJldmVyc2UoY20sIGxuLCBwb3MsIGRpcikge1xuICAgICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUobG4pO1xuXG4gICAgICAgIHZhciBjdXJyID0ge1xuICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgbG46IGxuLFxuICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgIGRpcjogZGlyLFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RfdmFsaWQgPSB7XG4gICAgICAgICAgbG46IGN1cnIubG4sXG4gICAgICAgICAgcG9zOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBza2lwX2VtcHR5X2xpbmVzID0gKGN1cnIubGluZSA9PT0gXCJcIik7XG5cbiAgICAgICAgLy8gTW92ZSBvbmUgc3RlcCB0byBza2lwIGNoYXJhY3RlciB3ZSBzdGFydCBvblxuICAgICAgICBuZXh0Q2hhcihjbSwgY3Vycik7XG5cbiAgICAgICAgd2hpbGUgKGN1cnIubGluZSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgaWYgKGN1cnIubGluZSA9PT0gXCJcIiAmJiAhc2tpcF9lbXB0eV9saW5lcykge1xuICAgICAgICAgICAgaWYgKGxhc3RfdmFsaWQucG9zICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsYXN0X3ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGxuOiBjdXJyLmxuLCBwb3M6IGN1cnIucG9zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzRW5kT2ZTZW50ZW5jZVN5bWJvbChjdXJyLmxpbmVbY3Vyci5wb3NdKVxuICAgICAgICAgICAgICAmJiBsYXN0X3ZhbGlkLnBvcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAmJiAhKGN1cnIubG4gPT09IGxhc3RfdmFsaWQubG4gJiYgY3Vyci5wb3MgKyAxID09PSBsYXN0X3ZhbGlkLnBvcykpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0X3ZhbGlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjdXJyLmxpbmUgIT09IFwiXCIgJiYgIWlzV2hpdGVTcGFjZVN0cmluZyhjdXJyLmxpbmVbY3Vyci5wb3NdKSkge1xuICAgICAgICAgICAgc2tpcF9lbXB0eV9saW5lcyA9IGZhbHNlO1xuICAgICAgICAgICAgbGFzdF92YWxpZCA9IHsgbG46IGN1cnIubG4sIHBvczogY3Vyci5wb3MgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHRDaGFyKGNtLCBjdXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAgU2V0IHRoZSBwb3NpdGlvbiB0byB0aGUgZmlyc3Qgbm9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyIG9uIHRoZSBsYXN0XG4gICAgICAgICAgdmFsaWQgbGluZSBpbiB0aGUgY2FzZSB0aGF0IHdlIHJlYWNoIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICAqL1xuICAgICAgICB2YXIgbGluZSA9IGNtLmdldExpbmUobGFzdF92YWxpZC5sbik7XG4gICAgICAgIGxhc3RfdmFsaWQucG9zID0gMDtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoIWlzV2hpdGVTcGFjZVN0cmluZyhsaW5lW2ldKSkge1xuICAgICAgICAgICAgbGFzdF92YWxpZC5wb3MgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0X3ZhbGlkO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3Vycl9pbmRleCA9IHtcbiAgICAgICAgbG46IGN1ci5saW5lLFxuICAgICAgICBwb3M6IGN1ci5jaCxcbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChyZXBlYXQgPiAwKSB7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgY3Vycl9pbmRleCA9IHJldmVyc2UoY20sIGN1cnJfaW5kZXgubG4sIGN1cnJfaW5kZXgucG9zLCBkaXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGN1cnJfaW5kZXggPSBmb3J3YXJkKGNtLCBjdXJyX2luZGV4LmxuLCBjdXJyX2luZGV4LnBvcywgZGlyKTtcbiAgICAgICAgfVxuICAgICAgICByZXBlYXQtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBvcyhjdXJyX2luZGV4LmxuLCBjdXJyX2luZGV4LnBvcyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcGVyaGFwcyB0aGlzIGZpbmFnbGluZyBvZiBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBiZWxvbmdzXG4gICAgLy8gaW4gY29kZW1pcnJvci9yZXBsYWNlUmFuZ2U/XG4gICAgZnVuY3Rpb24gc2VsZWN0Q29tcGFuaW9uT2JqZWN0KGNtLCBoZWFkLCBzeW1iLCBpbmNsdXNpdmUpIHtcbiAgICAgIHZhciBjdXIgPSBoZWFkLCBzdGFydCwgZW5kO1xuXG4gICAgICB2YXIgYnJhY2tldFJlZ2V4cCA9ICh7XG4gICAgICAgICcoJzogL1soKV0vLCAnKSc6IC9bKCldLyxcbiAgICAgICAgJ1snOiAvW1tcXF1dLywgJ10nOiAvW1tcXF1dLyxcbiAgICAgICAgJ3snOiAvW3t9XS8sICd9JzogL1t7fV0vLFxuICAgICAgICAnPCc6IC9bPD5dLywgJz4nOiAvWzw+XS99KVtzeW1iXTtcbiAgICAgIHZhciBvcGVuU3ltID0gKHtcbiAgICAgICAgJygnOiAnKCcsICcpJzogJygnLFxuICAgICAgICAnWyc6ICdbJywgJ10nOiAnWycsXG4gICAgICAgICd7JzogJ3snLCAnfSc6ICd7JyxcbiAgICAgICAgJzwnOiAnPCcsICc+JzogJzwnfSlbc3ltYl07XG4gICAgICB2YXIgY3VyQ2hhciA9IGNtLmdldExpbmUoY3VyLmxpbmUpLmNoYXJBdChjdXIuY2gpO1xuICAgICAgLy8gRHVlIHRvIHRoZSBiZWhhdmlvciBvZiBzY2FuRm9yQnJhY2tldCwgd2UgbmVlZCB0byBhZGQgYW4gb2Zmc2V0IGlmIHRoZVxuICAgICAgLy8gY3Vyc29yIGlzIG9uIGEgbWF0Y2hpbmcgb3BlbiBicmFja2V0LlxuICAgICAgdmFyIG9mZnNldCA9IGN1ckNoYXIgPT09IG9wZW5TeW0gPyAxIDogMDtcblxuICAgICAgc3RhcnQgPSBjbS5zY2FuRm9yQnJhY2tldChQb3MoY3VyLmxpbmUsIGN1ci5jaCArIG9mZnNldCksIC0xLCB1bmRlZmluZWQsIHsnYnJhY2tldFJlZ2V4JzogYnJhY2tldFJlZ2V4cH0pO1xuICAgICAgZW5kID0gY20uc2NhbkZvckJyYWNrZXQoUG9zKGN1ci5saW5lLCBjdXIuY2ggKyBvZmZzZXQpLCAxLCB1bmRlZmluZWQsIHsnYnJhY2tldFJlZ2V4JzogYnJhY2tldFJlZ2V4cH0pO1xuXG4gICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGN1ciwgZW5kOiBjdXIgfTtcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSBzdGFydC5wb3M7XG4gICAgICBlbmQgPSBlbmQucG9zO1xuXG4gICAgICBpZiAoKHN0YXJ0LmxpbmUgPT0gZW5kLmxpbmUgJiYgc3RhcnQuY2ggPiBlbmQuY2gpXG4gICAgICAgICAgfHwgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSkpIHtcbiAgICAgICAgdmFyIHRtcCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgZW5kID0gdG1wO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVzaXZlKSB7XG4gICAgICAgIGVuZC5jaCArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQuY2ggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgIH1cblxuICAgIC8vIFRha2VzIGluIGEgc3ltYm9sIGFuZCBhIGN1cnNvciBhbmQgdHJpZXMgdG8gc2ltdWxhdGUgdGV4dCBvYmplY3RzIHRoYXRcbiAgICAvLyBoYXZlIGlkZW50aWNhbCBvcGVuaW5nIGFuZCBjbG9zaW5nIHN5bWJvbHNcbiAgICAvLyBUT0RPIHN1cHBvcnQgYWNyb3NzIG11bHRpcGxlIGxpbmVzXG4gICAgZnVuY3Rpb24gZmluZEJlZ2lubmluZ0FuZEVuZChjbSwgaGVhZCwgc3ltYiwgaW5jbHVzaXZlKSB7XG4gICAgICB2YXIgY3VyID0gY29weUN1cnNvcihoZWFkKTtcbiAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZShjdXIubGluZSk7XG4gICAgICB2YXIgY2hhcnMgPSBsaW5lLnNwbGl0KCcnKTtcbiAgICAgIHZhciBzdGFydCwgZW5kLCBpLCBsZW47XG4gICAgICB2YXIgZmlyc3RJbmRleCA9IGNoYXJzLmluZGV4T2Yoc3ltYik7XG5cbiAgICAgIC8vIHRoZSBkZWNpc2lvbiB0cmVlIGlzIHRvIGFsd2F5cyBsb29rIGJhY2t3YXJkcyBmb3IgdGhlIGJlZ2lubmluZyBmaXJzdCxcbiAgICAgIC8vIGJ1dCBpZiB0aGUgY3Vyc29yIGlzIGluIGZyb250IG9mIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiB0aGUgc3ltYixcbiAgICAgIC8vIHRoZW4gbW92ZSB0aGUgY3Vyc29yIGZvcndhcmRcbiAgICAgIGlmIChjdXIuY2ggPCBmaXJzdEluZGV4KSB7XG4gICAgICAgIGN1ci5jaCA9IGZpcnN0SW5kZXg7XG4gICAgICAgIC8vIFdoeSBpcyB0aGlzIGxpbmUgZXZlbiBoZXJlPz8/XG4gICAgICAgIC8vIGNtLnNldEN1cnNvcihjdXIubGluZSwgZmlyc3RJbmRleCsxKTtcbiAgICAgIH1cbiAgICAgIC8vIG90aGVyd2lzZSBpZiB0aGUgY3Vyc29yIGlzIGN1cnJlbnRseSBvbiB0aGUgY2xvc2luZyBzeW1ib2xcbiAgICAgIGVsc2UgaWYgKGZpcnN0SW5kZXggPCBjdXIuY2ggJiYgY2hhcnNbY3VyLmNoXSA9PSBzeW1iKSB7XG4gICAgICAgIGVuZCA9IGN1ci5jaDsgLy8gYXNzaWduIGVuZCB0byB0aGUgY3VycmVudCBjdXJzb3JcbiAgICAgICAgLS1jdXIuY2g7IC8vIG1ha2Ugc3VyZSB0byBsb29rIGJhY2t3YXJkc1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSdyZSBjdXJyZW50bHkgb24gdGhlIHN5bWJvbCwgd2UndmUgZ290IGEgc3RhcnRcbiAgICAgIGlmIChjaGFyc1tjdXIuY2hdID09IHN5bWIgJiYgIWVuZCkge1xuICAgICAgICBzdGFydCA9IGN1ci5jaCArIDE7IC8vIGFzc2lnbiBzdGFydCB0byBhaGVhZCBvZiB0aGUgY3Vyc29yXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnbyBiYWNrd2FyZHMgdG8gZmluZCB0aGUgc3RhcnRcbiAgICAgICAgZm9yIChpID0gY3VyLmNoOyBpID4gLTEgJiYgIXN0YXJ0OyBpLS0pIHtcbiAgICAgICAgICBpZiAoY2hhcnNbaV0gPT0gc3ltYikge1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbG9vayBmb3J3YXJkcyBmb3IgdGhlIGVuZCBzeW1ib2xcbiAgICAgIGlmIChzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0LCBsZW4gPSBjaGFycy5sZW5ndGg7IGkgPCBsZW4gJiYgIWVuZDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNoYXJzW2ldID09IHN5bWIpIHtcbiAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vdGhpbmcgZm91bmRcbiAgICAgIGlmICghc3RhcnQgfHwgIWVuZCkge1xuICAgICAgICByZXR1cm4geyBzdGFydDogY3VyLCBlbmQ6IGN1ciB9O1xuICAgICAgfVxuXG4gICAgICAvLyBpbmNsdWRlIHRoZSBzeW1ib2xzXG4gICAgICBpZiAoaW5jbHVzaXZlKSB7XG4gICAgICAgIC0tc3RhcnQ7ICsrZW5kO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogUG9zKGN1ci5saW5lLCBzdGFydCksXG4gICAgICAgIGVuZDogUG9zKGN1ci5saW5lLCBlbmQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmdW5jdGlvbnNcbiAgICBkZWZpbmVPcHRpb24oJ3BjcmUnLCB0cnVlLCAnYm9vbGVhbicpO1xuICAgIGZ1bmN0aW9uIFNlYXJjaFN0YXRlKCkge31cbiAgICBTZWFyY2hTdGF0ZS5wcm90b3R5cGUgPSB7XG4gICAgICBnZXRRdWVyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2aW1HbG9iYWxTdGF0ZS5xdWVyeTtcbiAgICAgIH0sXG4gICAgICBzZXRRdWVyeTogZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgdmltR2xvYmFsU3RhdGUucXVlcnkgPSBxdWVyeTtcbiAgICAgIH0sXG4gICAgICBnZXRPdmVybGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoT3ZlcmxheTtcbiAgICAgIH0sXG4gICAgICBzZXRPdmVybGF5OiBmdW5jdGlvbihvdmVybGF5KSB7XG4gICAgICAgIHRoaXMuc2VhcmNoT3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICB9LFxuICAgICAgaXNSZXZlcnNlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2aW1HbG9iYWxTdGF0ZS5pc1JldmVyc2VkO1xuICAgICAgfSxcbiAgICAgIHNldFJldmVyc2VkOiBmdW5jdGlvbihyZXZlcnNlZCkge1xuICAgICAgICB2aW1HbG9iYWxTdGF0ZS5pc1JldmVyc2VkID0gcmV2ZXJzZWQ7XG4gICAgICB9LFxuICAgICAgZ2V0U2Nyb2xsYmFyQW5ub3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZTtcbiAgICAgIH0sXG4gICAgICBzZXRTY3JvbGxiYXJBbm5vdGF0ZTogZnVuY3Rpb24oYW5ub3RhdGUpIHtcbiAgICAgICAgdGhpcy5hbm5vdGF0ZSA9IGFubm90YXRlO1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0U2VhcmNoU3RhdGUoY20pIHtcbiAgICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgICByZXR1cm4gdmltLnNlYXJjaFN0YXRlXyB8fCAodmltLnNlYXJjaFN0YXRlXyA9IG5ldyBTZWFyY2hTdGF0ZSgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaXRCeVNsYXNoKGFyZ1N0cmluZykge1xuICAgICAgcmV0dXJuIHNwbGl0QnlTZXBhcmF0b3IoYXJnU3RyaW5nLCAnLycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRVbmVzY2FwZWRTbGFzaGVzKGFyZ1N0cmluZykge1xuICAgICAgcmV0dXJuIGZpbmRVbmVzY2FwZWRTZXBhcmF0b3JzKGFyZ1N0cmluZywgJy8nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGxpdEJ5U2VwYXJhdG9yKGFyZ1N0cmluZywgc2VwYXJhdG9yKSB7XG4gICAgICB2YXIgc2xhc2hlcyA9IGZpbmRVbmVzY2FwZWRTZXBhcmF0b3JzKGFyZ1N0cmluZywgc2VwYXJhdG9yKSB8fCBbXTtcbiAgICAgIGlmICghc2xhc2hlcy5sZW5ndGgpIHJldHVybiBbXTtcbiAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgIC8vIGluIGNhc2Ugb2Ygc3RyaW5ncyBsaWtlIGZvby9iYXJcbiAgICAgIGlmIChzbGFzaGVzWzBdICE9PSAwKSByZXR1cm47XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsYXNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzbGFzaGVzW2ldID09ICdudW1iZXInKVxuICAgICAgICAgIHRva2Vucy5wdXNoKGFyZ1N0cmluZy5zdWJzdHJpbmcoc2xhc2hlc1tpXSArIDEsIHNsYXNoZXNbaSsxXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kVW5lc2NhcGVkU2VwYXJhdG9ycyhzdHIsIHNlcGFyYXRvcikge1xuICAgICAgaWYgKCFzZXBhcmF0b3IpXG4gICAgICAgIHNlcGFyYXRvciA9ICcvJztcblxuICAgICAgdmFyIGVzY2FwZU5leHRDaGFyID0gZmFsc2U7XG4gICAgICB2YXIgc2xhc2hlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpZiAoIWVzY2FwZU5leHRDaGFyICYmIGMgPT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgc2xhc2hlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGVzY2FwZU5leHRDaGFyID0gIWVzY2FwZU5leHRDaGFyICYmIChjID09ICdcXFxcJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xhc2hlcztcbiAgICB9XG5cbiAgICAvLyBUcmFuc2xhdGVzIGEgc2VhcmNoIHN0cmluZyBmcm9tIGV4ICh2aW0pIHN5bnRheCBpbnRvIGphdmFzY3JpcHQgZm9ybS5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVSZWdleChzdHIpIHtcbiAgICAgIC8vIFdoZW4gdGhlc2UgbWF0Y2gsIGFkZCBhICdcXCcgaWYgdW5lc2NhcGVkIG9yIHJlbW92ZSBvbmUgaWYgZXNjYXBlZC5cbiAgICAgIHZhciBzcGVjaWFscyA9ICd8KCl7JztcbiAgICAgIC8vIFJlbW92ZSwgYnV0IG5ldmVyIGFkZCwgYSAnXFwnIGZvciB0aGVzZS5cbiAgICAgIHZhciB1bmVzY2FwZSA9ICd9JztcbiAgICAgIHZhciBlc2NhcGVOZXh0Q2hhciA9IGZhbHNlO1xuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IC0xOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKSB8fCAnJztcbiAgICAgICAgdmFyIG4gPSBzdHIuY2hhckF0KGkrMSkgfHwgJyc7XG4gICAgICAgIHZhciBzcGVjaWFsQ29tZXNOZXh0ID0gKG4gJiYgc3BlY2lhbHMuaW5kZXhPZihuKSAhPSAtMSk7XG4gICAgICAgIGlmIChlc2NhcGVOZXh0Q2hhcikge1xuICAgICAgICAgIGlmIChjICE9PSAnXFxcXCcgfHwgIXNwZWNpYWxDb21lc05leHQpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlc2NhcGVOZXh0Q2hhciA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGVzY2FwZU5leHRDaGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFRyZWF0IHRoZSB1bmVzY2FwZSBsaXN0IGFzIHNwZWNpYWwgZm9yIHJlbW92aW5nLCBidXQgbm90IGFkZGluZyAnXFwnLlxuICAgICAgICAgICAgaWYgKG4gJiYgdW5lc2NhcGUuaW5kZXhPZihuKSAhPSAtMSkge1xuICAgICAgICAgICAgICBzcGVjaWFsQ29tZXNOZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdCBwYXNzaW5nIHRoaXMgdGVzdCBtZWFucyByZW1vdmluZyBhICdcXCcuXG4gICAgICAgICAgICBpZiAoIXNwZWNpYWxDb21lc05leHQgfHwgbiA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgIG91dC5wdXNoKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQucHVzaChjKTtcbiAgICAgICAgICAgIGlmIChzcGVjaWFsQ29tZXNOZXh0ICYmIG4gIT09ICdcXFxcJykge1xuICAgICAgICAgICAgICBvdXQucHVzaCgnXFxcXCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2xhdGVzIHRoZSByZXBsYWNlIHBhcnQgb2YgYSBzZWFyY2ggYW5kIHJlcGxhY2UgZnJvbSBleCAodmltKSBzeW50YXggaW50b1xuICAgIC8vIGphdmFzY3JpcHQgZm9ybS4gIFNpbWlsYXIgdG8gdHJhbnNsYXRlUmVnZXgsIGJ1dCBhZGRpdGlvbmFsbHkgZml4ZXMgYmFjayByZWZlcmVuY2VzXG4gICAgLy8gKHRyYW5zbGF0ZXMgJ1xcWzAuLjldJyB0byAnJFswLi45XScpIGFuZCBmb2xsb3dzIGRpZmZlcmVudCBydWxlcyBmb3IgZXNjYXBpbmcgJyQnLlxuICAgIHZhciBjaGFyVW5lc2NhcGVzID0geydcXFxcbic6ICdcXG4nLCAnXFxcXHInOiAnXFxyJywgJ1xcXFx0JzogJ1xcdCd9O1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlZ2V4UmVwbGFjZShzdHIpIHtcbiAgICAgIHZhciBlc2NhcGVOZXh0Q2hhciA9IGZhbHNlO1xuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IC0xOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKSB8fCAnJztcbiAgICAgICAgdmFyIG4gPSBzdHIuY2hhckF0KGkrMSkgfHwgJyc7XG4gICAgICAgIGlmIChjaGFyVW5lc2NhcGVzW2MgKyBuXSkge1xuICAgICAgICAgIG91dC5wdXNoKGNoYXJVbmVzY2FwZXNbYytuXSk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2UgaWYgKGVzY2FwZU5leHRDaGFyKSB7XG4gICAgICAgICAgLy8gQXQgYW55IHBvaW50IGluIHRoZSBsb29wLCBlc2NhcGVOZXh0Q2hhciBpcyB0cnVlIGlmIHRoZSBwcmV2aW91c1xuICAgICAgICAgIC8vIGNoYXJhY3RlciB3YXMgYSAnXFwnIGFuZCB3YXMgbm90IGVzY2FwZWQuXG4gICAgICAgICAgb3V0LnB1c2goYyk7XG4gICAgICAgICAgZXNjYXBlTmV4dENoYXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBlc2NhcGVOZXh0Q2hhciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoKGlzTnVtYmVyKG4pIHx8IG4gPT09ICckJykpIHtcbiAgICAgICAgICAgICAgb3V0LnB1c2goJyQnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiAhPT0gJy8nICYmIG4gIT09ICdcXFxcJykge1xuICAgICAgICAgICAgICBvdXQucHVzaCgnXFxcXCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgIG91dC5wdXNoKCckJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQucHVzaChjKTtcbiAgICAgICAgICAgIGlmIChuID09PSAnLycpIHtcbiAgICAgICAgICAgICAgb3V0LnB1c2goJ1xcXFwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQuam9pbignJyk7XG4gICAgfVxuXG4gICAgLy8gVW5lc2NhcGUgXFwgYW5kIC8gaW4gdGhlIHJlcGxhY2UgcGFydCwgZm9yIFBDUkUgbW9kZS5cbiAgICB2YXIgdW5lc2NhcGVzID0geydcXFxcLyc6ICcvJywgJ1xcXFxcXFxcJzogJ1xcXFwnLCAnXFxcXG4nOiAnXFxuJywgJ1xcXFxyJzogJ1xccicsICdcXFxcdCc6ICdcXHQnLCAnXFxcXCYnOicmJ307XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVSZWdleFJlcGxhY2Uoc3RyKSB7XG4gICAgICB2YXIgc3RyZWFtID0gbmV3IENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtKHN0cik7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAvLyBTZWFyY2ggZm9yIFxcLlxuICAgICAgICB3aGlsZSAoc3RyZWFtLnBlZWsoKSAmJiBzdHJlYW0ucGVlaygpICE9ICdcXFxcJykge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmVhbS5uZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIG1hdGNoZXIgaW4gdW5lc2NhcGVzKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChtYXRjaGVyLCB0cnVlKSkge1xuICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCh1bmVzY2FwZXNbbWF0Y2hlcl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICAgIC8vIERvbid0IGNoYW5nZSBhbnl0aGluZ1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmVhbS5uZXh0KCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBxdWVyeSBhbmQgcmV0dXJuIGEgUmVnZXhwIG9iamVjdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIHF1ZXJ5IGlzIGJsYW5rLlxuICAgICAqIElmIGlnbm9yZUNhc2UgaXMgcGFzc2VkIGluLCB0aGUgUmVnZXhwIG9iamVjdCB3aWxsIGhhdmUgdGhlICdpJyBmbGFnIHNldC5cbiAgICAgKiBJZiBzbWFydENhc2UgaXMgcGFzc2VkIGluLCBhbmQgdGhlIHF1ZXJ5IGNvbnRhaW5zIHVwcGVyIGNhc2UgbGV0dGVycyxcbiAgICAgKiAgIHRoZW4gaWdub3JlQ2FzZSBpcyBvdmVycmlkZGVuLCBhbmQgdGhlICdpJyBmbGFnIHdpbGwgbm90IGJlIHNldC5cbiAgICAgKiBJZiB0aGUgcXVlcnkgY29udGFpbnMgdGhlIC9pIGluIHRoZSBmbGFnIHBhcnQgb2YgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbixcbiAgICAgKiAgIHRoZW4gYm90aCBpZ25vcmVDYXNlIGFuZCBzbWFydENhc2UgYXJlIGlnbm9yZWQsIGFuZCAnaScgd2lsbCBiZSBwYXNzZWRcbiAgICAgKiAgIHRocm91Z2ggdG8gdGhlIFJlZ2V4IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVF1ZXJ5KHF1ZXJ5LCBpZ25vcmVDYXNlLCBzbWFydENhc2UpIHtcbiAgICAgIC8vIEZpcnN0IHVwZGF0ZSB0aGUgbGFzdCBzZWFyY2ggcmVnaXN0ZXJcbiAgICAgIHZhciBsYXN0U2VhcmNoUmVnaXN0ZXIgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIuZ2V0UmVnaXN0ZXIoJy8nKTtcbiAgICAgIGxhc3RTZWFyY2hSZWdpc3Rlci5zZXRUZXh0KHF1ZXJ5KTtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBxdWVyeSBpcyBhbHJlYWR5IGEgcmVnZXguXG4gICAgICBpZiAocXVlcnkgaW5zdGFuY2VvZiBSZWdFeHApIHsgcmV0dXJuIHF1ZXJ5OyB9XG4gICAgICAvLyBGaXJzdCB0cnkgdG8gZXh0cmFjdCByZWdleCArIGZsYWdzIGZyb20gdGhlIGlucHV0LiBJZiBubyBmbGFncyBmb3VuZCxcbiAgICAgIC8vIGV4dHJhY3QganVzdCB0aGUgcmVnZXguIElFIGRvZXMgbm90IGFjY2VwdCBmbGFncyBkaXJlY3RseSBkZWZpbmVkIGluXG4gICAgICAvLyB0aGUgcmVnZXggc3RyaW5nIGluIHRoZSBmb3JtIC9yZWdleC9mbGFnc1xuICAgICAgdmFyIHNsYXNoZXMgPSBmaW5kVW5lc2NhcGVkU2xhc2hlcyhxdWVyeSk7XG4gICAgICB2YXIgcmVnZXhQYXJ0O1xuICAgICAgdmFyIGZvcmNlSWdub3JlQ2FzZTtcbiAgICAgIGlmICghc2xhc2hlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gUXVlcnkgbG9va3MgbGlrZSAncmVnZXhwJ1xuICAgICAgICByZWdleFBhcnQgPSBxdWVyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFF1ZXJ5IGxvb2tzIGxpa2UgJ3JlZ2V4cC8uLi4nXG4gICAgICAgIHJlZ2V4UGFydCA9IHF1ZXJ5LnN1YnN0cmluZygwLCBzbGFzaGVzWzBdKTtcbiAgICAgICAgdmFyIGZsYWdzUGFydCA9IHF1ZXJ5LnN1YnN0cmluZyhzbGFzaGVzWzBdKTtcbiAgICAgICAgZm9yY2VJZ25vcmVDYXNlID0gKGZsYWdzUGFydC5pbmRleE9mKCdpJykgIT0gLTEpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZWdleFBhcnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWdldE9wdGlvbigncGNyZScpKSB7XG4gICAgICAgIHJlZ2V4UGFydCA9IHRyYW5zbGF0ZVJlZ2V4KHJlZ2V4UGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoc21hcnRDYXNlKSB7XG4gICAgICAgIGlnbm9yZUNhc2UgPSAoL15bXkEtWl0qJC8pLnRlc3QocmVnZXhQYXJ0KTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKHJlZ2V4UGFydCxcbiAgICAgICAgICAoaWdub3JlQ2FzZSB8fCBmb3JjZUlnbm9yZUNhc2UpID8gJ2knIDogdW5kZWZpbmVkKTtcbiAgICAgIHJldHVybiByZWdleHA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZG9tIC0gRG9jdW1lbnQgT2JqZWN0IE1hbmlwdWxhdG9yXG4gICAgICogVXNhZ2U6XG4gICAgICogICBkb20oJzx0YWc+J3w8bm9kZT5bLCAuLi57PGF0dHJpYnV0ZXM+fDwkc3R5bGVzPn18PGNoaWxkLW5vZGU+fCc8dGV4dD4nXSlcbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKiAgIGRvbSgnZGl2Jywge2lkOid4eXonfSwgZG9tKCdwJywgJ0NNIHJvY2tzIScsIHskY29sb3I6J3JlZCd9KSlcbiAgICAgKiAgIGRvbShkb2N1bWVudC5oZWFkLCBkb20oJ3NjcmlwdCcsICdhbGVydChcImhlbGxvIVwiKScpKVxuICAgICAqIE5vdCBzdXBwb3J0ZWQ6XG4gICAgICogICBkb20oJ3AnLCBbJ2FycmF5cyBhcmUgb2JqZWN0cyddLCBFcnJvcignb2JqZWN0cyBzcGVjaWZ5IGF0dHJpYnV0ZXMnKSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb20obikge1xuICAgICAgaWYgKHR5cGVvZiBuID09PSAnc3RyaW5nJykgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobik7XG4gICAgICBmb3IgKHZhciBhLCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIShhID0gYXJndW1lbnRzW2ldKSkgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpIGEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKTtcbiAgICAgICAgaWYgKGEubm9kZVR5cGUpIG4uYXBwZW5kQ2hpbGQoYSk7XG4gICAgICAgIGVsc2UgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcpIG4uc3R5bGVba2V5LnNsaWNlKDEpXSA9IGFba2V5XTtcbiAgICAgICAgICBlbHNlIG4uc2V0QXR0cmlidXRlKGtleSwgYVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvd0NvbmZpcm0oY20sIHRlbXBsYXRlKSB7XG4gICAgICB2YXIgcHJlID0gZG9tKCdwcmUnLCB7JGNvbG9yOiAncmVkJ30sIHRlbXBsYXRlKTtcbiAgICAgIGlmIChjbS5vcGVuTm90aWZpY2F0aW9uKSB7XG4gICAgICAgIGNtLm9wZW5Ob3RpZmljYXRpb24ocHJlLCB7Ym90dG9tOiB0cnVlLCBkdXJhdGlvbjogNTAwMH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQocHJlLmlubmVyVGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZVByb21wdChwcmVmaXgsIGRlc2MpIHtcbiAgICAgIHJldHVybiBkb20oZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgICAgZG9tKCdzcGFuJywgeyRmb250RmFtaWx5OiAnbW9ub3NwYWNlJywgJHdoaXRlU3BhY2U6ICdwcmUnfSxcbiAgICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgICBkb20oJ2lucHV0Jywge3R5cGU6ICd0ZXh0JywgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiAnb2ZmJywgc3BlbGxjaGVjazogJ2ZhbHNlJ30pKSxcbiAgICAgICAgICAgICAgIGRlc2MgJiYgZG9tKCdzcGFuJywgeyRjb2xvcjogJyM4ODgnfSwgZGVzYykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dQcm9tcHQoY20sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaG9ydFRleHQgPSAob3B0aW9ucy5wcmVmaXggfHwgJycpICsgJyAnICsgKG9wdGlvbnMuZGVzYyB8fCAnJyk7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBtYWtlUHJvbXB0KG9wdGlvbnMucHJlZml4LCBvcHRpb25zLmRlc2MpO1xuICAgICAgaWYgKGNtLm9wZW5EaWFsb2cpIHtcbiAgICAgICAgY20ub3BlbkRpYWxvZyh0ZW1wbGF0ZSwgb3B0aW9ucy5vbkNsb3NlLCB7XG4gICAgICAgICAgb25LZXlEb3duOiBvcHRpb25zLm9uS2V5RG93biwgb25LZXlVcDogb3B0aW9ucy5vbktleVVwLFxuICAgICAgICAgIGJvdHRvbTogdHJ1ZSwgc2VsZWN0VmFsdWVPbk9wZW46IGZhbHNlLCB2YWx1ZTogb3B0aW9ucy52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zLm9uQ2xvc2UocHJvbXB0KHNob3J0VGV4dCwgJycpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVxdWFsKHIxLCByMikge1xuICAgICAgaWYgKHIxIGluc3RhbmNlb2YgUmVnRXhwICYmIHIyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgdmFyIHByb3BzID0gWydnbG9iYWwnLCAnbXVsdGlsaW5lJywgJ2lnbm9yZUNhc2UnLCAnc291cmNlJ107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICAgICAgICBpZiAocjFbcHJvcF0gIT09IHIyW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgcXVlcnkgaXMgdmFsaWQuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2VhcmNoUXVlcnkoY20sIHJhd1F1ZXJ5LCBpZ25vcmVDYXNlLCBzbWFydENhc2UpIHtcbiAgICAgIGlmICghcmF3UXVlcnkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXRlID0gZ2V0U2VhcmNoU3RhdGUoY20pO1xuICAgICAgdmFyIHF1ZXJ5ID0gcGFyc2VRdWVyeShyYXdRdWVyeSwgISFpZ25vcmVDYXNlLCAhIXNtYXJ0Q2FzZSk7XG4gICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhpZ2hsaWdodFNlYXJjaE1hdGNoZXMoY20sIHF1ZXJ5KTtcbiAgICAgIGlmIChyZWdleEVxdWFsKHF1ZXJ5LCBzdGF0ZS5nZXRRdWVyeSgpKSkge1xuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5zZXRRdWVyeShxdWVyeSk7XG4gICAgICByZXR1cm4gcXVlcnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlYXJjaE92ZXJsYXkocXVlcnkpIHtcbiAgICAgIGlmIChxdWVyeS5zb3VyY2UuY2hhckF0KDApID09ICdeJykge1xuICAgICAgICB2YXIgbWF0Y2hTb2wgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIGlmIChtYXRjaFNvbCAmJiAhc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtYXRjaCA9IHN0cmVhbS5tYXRjaChxdWVyeSwgZmFsc2UpO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoWzBdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIC8vIE1hdGNoZWQgZW1wdHkgc3RyaW5nLCBza2lwIHRvIG5leHQuXG4gICAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiAnc2VhcmNoaW5nJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgICAgICAgIC8vIEJhY2t0cmFjayAxIHRvIG1hdGNoIFxcYlxuICAgICAgICAgICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICAgICAgICBpZiAoIXF1ZXJ5LmV4ZWMoc3RyZWFtLm5leHQoKSArIG1hdGNoWzBdKSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5tYXRjaChxdWVyeSk7XG4gICAgICAgICAgICByZXR1cm4gJ3NlYXJjaGluZyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChxdWVyeSwgZmFsc2UpKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJ5OiBxdWVyeVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGhpZ2hsaWdodFRpbWVvdXQgPSAwO1xuICAgIGZ1bmN0aW9uIGhpZ2hsaWdodFNlYXJjaE1hdGNoZXMoY20sIHF1ZXJ5KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaGlnaGxpZ2h0VGltZW91dCk7XG4gICAgICBoaWdobGlnaHRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlYXJjaFN0YXRlID0gZ2V0U2VhcmNoU3RhdGUoY20pO1xuICAgICAgICB2YXIgb3ZlcmxheSA9IHNlYXJjaFN0YXRlLmdldE92ZXJsYXkoKTtcbiAgICAgICAgaWYgKCFvdmVybGF5IHx8IHF1ZXJ5ICE9IG92ZXJsYXkucXVlcnkpIHtcbiAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgY20ucmVtb3ZlT3ZlcmxheShvdmVybGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3ZlcmxheSA9IHNlYXJjaE92ZXJsYXkocXVlcnkpO1xuICAgICAgICAgIGNtLmFkZE92ZXJsYXkob3ZlcmxheSk7XG4gICAgICAgICAgaWYgKGNtLnNob3dNYXRjaGVzT25TY3JvbGxiYXIpIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2hTdGF0ZS5nZXRTY3JvbGxiYXJBbm5vdGF0ZSgpKSB7XG4gICAgICAgICAgICAgIHNlYXJjaFN0YXRlLmdldFNjcm9sbGJhckFubm90YXRlKCkuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlYXJjaFN0YXRlLnNldFNjcm9sbGJhckFubm90YXRlKGNtLnNob3dNYXRjaGVzT25TY3JvbGxiYXIocXVlcnkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VhcmNoU3RhdGUuc2V0T3ZlcmxheShvdmVybGF5KTtcbiAgICAgICAgfVxuICAgICAgfSwgNTApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kTmV4dChjbSwgcHJldiwgcXVlcnksIHJlcGVhdCkge1xuICAgICAgaWYgKHJlcGVhdCA9PT0gdW5kZWZpbmVkKSB7IHJlcGVhdCA9IDE7IH1cbiAgICAgIHJldHVybiBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb3MgPSBjbS5nZXRDdXJzb3IoKTtcbiAgICAgICAgdmFyIGN1cnNvciA9IGNtLmdldFNlYXJjaEN1cnNvcihxdWVyeSwgcG9zKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBlYXQ7IGkrKykge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGN1cnNvci5maW5kKHByZXYpO1xuICAgICAgICAgIGlmIChpID09IDAgJiYgZm91bmQgJiYgY3Vyc29yRXF1YWwoY3Vyc29yLmZyb20oKSwgcG9zKSkgeyBmb3VuZCA9IGN1cnNvci5maW5kKHByZXYpOyB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgLy8gU2VhcmNoQ3Vyc29yIG1heSBoYXZlIHJldHVybmVkIG51bGwgYmVjYXVzZSBpdCBoaXQgRU9GLCB3cmFwXG4gICAgICAgICAgICAvLyBhcm91bmQgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgIGN1cnNvciA9IGNtLmdldFNlYXJjaEN1cnNvcihxdWVyeSxcbiAgICAgICAgICAgICAgICAocHJldikgPyBQb3MoY20ubGFzdExpbmUoKSkgOiBQb3MoY20uZmlyc3RMaW5lKCksIDApICk7XG4gICAgICAgICAgICBpZiAoIWN1cnNvci5maW5kKHByZXYpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvci5mcm9tKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldHR5IG11Y2ggdGhlIHNhbWUgYXMgYGZpbmROZXh0YCwgZXhjZXB0IGZvciB0aGUgZm9sbG93aW5nIGRpZmZlcmVuY2VzOlxuICAgICAqXG4gICAgICogMS4gQmVmb3JlIHN0YXJ0aW5nIHRoZSBzZWFyY2gsIG1vdmUgdG8gdGhlIHByZXZpb3VzIHNlYXJjaC4gVGhpcyB3YXkgaWYgb3VyIGN1cnNvciBpc1xuICAgICAqIGFscmVhZHkgaW5zaWRlIGEgbWF0Y2gsIHdlIHNob3VsZCByZXR1cm4gdGhlIGN1cnJlbnQgbWF0Y2guXG4gICAgICogMi4gUmF0aGVyIHRoYW4gb25seSByZXR1cm5pbmcgdGhlIGN1cnNvcidzIGZyb20sIHdlIHJldHVybiB0aGUgY3Vyc29yJ3MgZnJvbSBhbmQgdG8gYXMgYSB0dXBsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTmV4dEZyb21BbmRUb0luY2x1c2l2ZShjbSwgcHJldiwgcXVlcnksIHJlcGVhdCwgdmltKSB7XG4gICAgICBpZiAocmVwZWF0ID09PSB1bmRlZmluZWQpIHsgcmVwZWF0ID0gMTsgfVxuICAgICAgcmV0dXJuIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvcyA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgY3Vyc29yID0gY20uZ2V0U2VhcmNoQ3Vyc29yKHF1ZXJ5LCBwb3MpO1xuXG4gICAgICAgIC8vIEdvIGJhY2sgb25lIHJlc3VsdCB0byBlbnN1cmUgdGhhdCBpZiB0aGUgY3Vyc29yIGlzIGN1cnJlbnRseSBhIG1hdGNoLCB3ZSBrZWVwIGl0LlxuICAgICAgICB2YXIgZm91bmQgPSBjdXJzb3IuZmluZCghcHJldik7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBtb3ZlZCwgZ28gYmFjayBvbmUgbW9yZSAoc2ltaWxhciB0byBpZiBpPT0wIGxvZ2ljIGluIGZpbmROZXh0KS5cbiAgICAgICAgaWYgKCF2aW0udmlzdWFsTW9kZSAmJiBmb3VuZCAmJiBjdXJzb3JFcXVhbChjdXJzb3IuZnJvbSgpLCBwb3MpKSB7XG4gICAgICAgICAgY3Vyc29yLmZpbmQoIXByZXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBlYXQ7IGkrKykge1xuICAgICAgICAgIGZvdW5kID0gY3Vyc29yLmZpbmQocHJldik7XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgLy8gU2VhcmNoQ3Vyc29yIG1heSBoYXZlIHJldHVybmVkIG51bGwgYmVjYXVzZSBpdCBoaXQgRU9GLCB3cmFwXG4gICAgICAgICAgICAvLyBhcm91bmQgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgIGN1cnNvciA9IGNtLmdldFNlYXJjaEN1cnNvcihxdWVyeSxcbiAgICAgICAgICAgICAgICAocHJldikgPyBQb3MoY20ubGFzdExpbmUoKSkgOiBQb3MoY20uZmlyc3RMaW5lKCksIDApICk7XG4gICAgICAgICAgICBpZiAoIWN1cnNvci5maW5kKHByZXYpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjdXJzb3IuZnJvbSgpLCBjdXJzb3IudG8oKV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJTZWFyY2hIaWdobGlnaHQoY20pIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldFNlYXJjaFN0YXRlKGNtKTtcbiAgICAgIGNtLnJlbW92ZU92ZXJsYXkoZ2V0U2VhcmNoU3RhdGUoY20pLmdldE92ZXJsYXkoKSk7XG4gICAgICBzdGF0ZS5zZXRPdmVybGF5KG51bGwpO1xuICAgICAgaWYgKHN0YXRlLmdldFNjcm9sbGJhckFubm90YXRlKCkpIHtcbiAgICAgICAgc3RhdGUuZ2V0U2Nyb2xsYmFyQW5ub3RhdGUoKS5jbGVhcigpO1xuICAgICAgICBzdGF0ZS5zZXRTY3JvbGxiYXJBbm5vdGF0ZShudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgcG9zIGlzIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UsIElOQ0xVU0lWRS5cbiAgICAgKiBSYW5nZSBjYW4gYmUgc3BlY2lmaWVkIHdpdGggMSBvciAyIGFyZ3VtZW50cy5cbiAgICAgKiBJZiB0aGUgZmlyc3QgcmFuZ2UgYXJndW1lbnQgaXMgYW4gYXJyYXksIHRyZWF0IGl0IGFzIGFuIGFycmF5IG9mIGxpbmVcbiAgICAgKiBudW1iZXJzLiBNYXRjaCBwb3MgYWdhaW5zdCBhbnkgb2YgdGhlIGxpbmVzLlxuICAgICAqIElmIHRoZSBmaXJzdCByYW5nZSBhcmd1bWVudCBpcyBhIG51bWJlcixcbiAgICAgKiAgIGlmIHRoZXJlIGlzIG9ubHkgMSByYW5nZSBhcmd1bWVudCwgY2hlY2sgaWYgcG9zIGhhcyB0aGUgc2FtZSBsaW5lXG4gICAgICogICAgICAgbnVtYmVyXG4gICAgICogICBpZiB0aGVyZSBhcmUgMiByYW5nZSBhcmd1bWVudHMsIHRoZW4gY2hlY2sgaWYgcG9zIGlzIGluIGJldHdlZW4gdGhlIHR3b1xuICAgICAqICAgICAgIHJhbmdlIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luUmFuZ2UocG9zLCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAodHlwZW9mIHBvcyAhPSAnbnVtYmVyJykge1xuICAgICAgICAvLyBBc3N1bWUgaXQgaXMgYSBjdXJzb3IgcG9zaXRpb24uIEdldCB0aGUgbGluZSBudW1iZXIuXG4gICAgICAgIHBvcyA9IHBvcy5saW5lO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGluQXJyYXkocG9zLCBzdGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiAocG9zID49IHN0YXJ0ICYmIHBvcyA8PSBlbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwb3MgPT0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VXNlclZpc2libGVMaW5lcyhjbSkge1xuICAgICAgdmFyIHNjcm9sbEluZm8gPSBjbS5nZXRTY3JvbGxJbmZvKCk7XG4gICAgICB2YXIgb2NjbHVkZVRvbGVyYW5jZVRvcCA9IDY7XG4gICAgICB2YXIgb2NjbHVkZVRvbGVyYW5jZUJvdHRvbSA9IDEwO1xuICAgICAgdmFyIGZyb20gPSBjbS5jb29yZHNDaGFyKHtsZWZ0OjAsIHRvcDogb2NjbHVkZVRvbGVyYW5jZVRvcCArIHNjcm9sbEluZm8udG9wfSwgJ2xvY2FsJyk7XG4gICAgICB2YXIgYm90dG9tWSA9IHNjcm9sbEluZm8uY2xpZW50SGVpZ2h0IC0gb2NjbHVkZVRvbGVyYW5jZUJvdHRvbSArIHNjcm9sbEluZm8udG9wO1xuICAgICAgdmFyIHRvID0gY20uY29vcmRzQ2hhcih7bGVmdDowLCB0b3A6IGJvdHRvbVl9LCAnbG9jYWwnKTtcbiAgICAgIHJldHVybiB7dG9wOiBmcm9tLmxpbmUsIGJvdHRvbTogdG8ubGluZX07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWFya1BvcyhjbSwgdmltLCBtYXJrTmFtZSkge1xuICAgICAgaWYgKG1hcmtOYW1lID09ICdcXCcnIHx8IG1hcmtOYW1lID09ICdgJykge1xuICAgICAgICByZXR1cm4gdmltR2xvYmFsU3RhdGUuanVtcExpc3QuZmluZChjbSwgLTEpIHx8IFBvcygwLCAwKTtcbiAgICAgIH0gZWxzZSBpZiAobWFya05hbWUgPT0gJy4nKSB7XG4gICAgICAgIHJldHVybiBnZXRMYXN0RWRpdFBvcyhjbSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXJrID0gdmltLm1hcmtzW21hcmtOYW1lXTtcbiAgICAgIHJldHVybiBtYXJrICYmIG1hcmsuZmluZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldExhc3RFZGl0UG9zKGNtKSB7XG4gICAgICB2YXIgZG9uZSA9IGNtLmRvYy5oaXN0b3J5LmRvbmU7XG4gICAgICBmb3IgKHZhciBpID0gZG9uZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgaWYgKGRvbmVbaV0uY2hhbmdlcykge1xuICAgICAgICAgIHJldHVybiBjb3B5Q3Vyc29yKGRvbmVbaV0uY2hhbmdlc1swXS50byk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgRXhDb21tYW5kRGlzcGF0Y2hlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5idWlsZENvbW1hbmRNYXBfKCk7XG4gICAgfTtcbiAgICBFeENvbW1hbmREaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcbiAgICAgIHByb2Nlc3NDb21tYW5kOiBmdW5jdGlvbihjbSwgaW5wdXQsIG9wdF9wYXJhbXMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNtLmN1ck9wLmlzVmltT3AgPSB0cnVlO1xuICAgICAgICAgIHRoYXQuX3Byb2Nlc3NDb21tYW5kKGNtLCBpbnB1dCwgb3B0X3BhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIF9wcm9jZXNzQ29tbWFuZDogZnVuY3Rpb24oY20sIGlucHV0LCBvcHRfcGFyYW1zKSB7XG4gICAgICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgICAgIHZhciBjb21tYW5kSGlzdG9yeVJlZ2lzdGVyID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKCc6Jyk7XG4gICAgICAgIHZhciBwcmV2aW91c0NvbW1hbmQgPSBjb21tYW5kSGlzdG9yeVJlZ2lzdGVyLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICAgIGV4aXRWaXN1YWxNb2RlKGNtKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRTdHJlYW0gPSBuZXcgQ29kZU1pcnJvci5TdHJpbmdTdHJlYW0oaW5wdXQpO1xuICAgICAgICAvLyB1cGRhdGUgXCI6IHdpdGggdGhlIGxhdGVzdCBjb21tYW5kIHdoZXRoZXIgdmFsaWQgb3IgaW52YWxpZFxuICAgICAgICBjb21tYW5kSGlzdG9yeVJlZ2lzdGVyLnNldFRleHQoaW5wdXQpO1xuICAgICAgICB2YXIgcGFyYW1zID0gb3B0X3BhcmFtcyB8fCB7fTtcbiAgICAgICAgcGFyYW1zLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5wYXJzZUlucHV0XyhjbSwgaW5wdXRTdHJlYW0sIHBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIHNob3dDb25maXJtKGNtLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbW1hbmQ7XG4gICAgICAgIHZhciBjb21tYW5kTmFtZTtcbiAgICAgICAgaWYgKCFwYXJhbXMuY29tbWFuZE5hbWUpIHtcbiAgICAgICAgICAvLyBJZiBvbmx5IGEgbGluZSByYW5nZSBpcyBkZWZpbmVkLCBtb3ZlIHRvIHRoZSBsaW5lLlxuICAgICAgICAgIGlmIChwYXJhbXMubGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21tYW5kTmFtZSA9ICdtb3ZlJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tbWFuZCA9IHRoaXMubWF0Y2hDb21tYW5kXyhwYXJhbXMuY29tbWFuZE5hbWUpO1xuICAgICAgICAgIGlmIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjb21tYW5kTmFtZSA9IGNvbW1hbmQubmFtZTtcbiAgICAgICAgICAgIGlmIChjb21tYW5kLmV4Y2x1ZGVGcm9tQ29tbWFuZEhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgY29tbWFuZEhpc3RvcnlSZWdpc3Rlci5zZXRUZXh0KHByZXZpb3VzQ29tbWFuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnNlQ29tbWFuZEFyZ3NfKGlucHV0U3RyZWFtLCBwYXJhbXMsIGNvbW1hbmQpO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQudHlwZSA9PSAnZXhUb0tleScpIHtcbiAgICAgICAgICAgICAgLy8gSGFuZGxlIEV4IHRvIEtleSBtYXBwaW5nLlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmQudG9LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgQ29kZU1pcnJvci5WaW0uaGFuZGxlS2V5KGNtLCBjb21tYW5kLnRvS2V5c1tpXSwgJ21hcHBpbmcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQudHlwZSA9PSAnZXhUb0V4Jykge1xuICAgICAgICAgICAgICAvLyBIYW5kbGUgRXggdG8gRXggbWFwcGluZy5cbiAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ29tbWFuZChjbSwgY29tbWFuZC50b0lucHV0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbW1hbmROYW1lKSB7XG4gICAgICAgICAgc2hvd0NvbmZpcm0oY20sICdOb3QgYW4gZWRpdG9yIGNvbW1hbmQgXCI6JyArIGlucHV0ICsgJ1wiJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhDb21tYW5kc1tjb21tYW5kTmFtZV0oY20sIHBhcmFtcyk7XG4gICAgICAgICAgLy8gUG9zc2libHkgYXN5bmNocm9ub3VzIGNvbW1hbmRzIChlLmcuIHN1YnN0aXR1dGUsIHdoaWNoIG1pZ2h0IGhhdmUgYVxuICAgICAgICAgIC8vIHVzZXIgY29uZmlybWF0aW9uKSwgYXJlIHJlc3BvbnNpYmxlIGZvciBjYWxsaW5nIHRoZSBjYWxsYmFjayB3aGVuXG4gICAgICAgICAgLy8gZG9uZS4gQWxsIG90aGVycyBoYXZlIGl0IHRha2VuIGNhcmUgb2YgZm9yIHRoZW0gaGVyZS5cbiAgICAgICAgICBpZiAoKCFjb21tYW5kIHx8ICFjb21tYW5kLnBvc3NpYmx5QXN5bmMpICYmIHBhcmFtcy5jYWxsYmFjaykge1xuICAgICAgICAgICAgcGFyYW1zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICBzaG93Q29uZmlybShjbSwgZS50b1N0cmluZygpKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFyc2VJbnB1dF86IGZ1bmN0aW9uKGNtLCBpbnB1dFN0cmVhbSwgcmVzdWx0KSB7XG4gICAgICAgIGlucHV0U3RyZWFtLmVhdFdoaWxlKCc6Jyk7XG4gICAgICAgIC8vIFBhcnNlIHJhbmdlLlxuICAgICAgICBpZiAoaW5wdXRTdHJlYW0uZWF0KCclJykpIHtcbiAgICAgICAgICByZXN1bHQubGluZSA9IGNtLmZpcnN0TGluZSgpO1xuICAgICAgICAgIHJlc3VsdC5saW5lRW5kID0gY20ubGFzdExpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQubGluZSA9IHRoaXMucGFyc2VMaW5lU3BlY18oY20sIGlucHV0U3RyZWFtKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmxpbmUgIT09IHVuZGVmaW5lZCAmJiBpbnB1dFN0cmVhbS5lYXQoJywnKSkge1xuICAgICAgICAgICAgcmVzdWx0LmxpbmVFbmQgPSB0aGlzLnBhcnNlTGluZVNwZWNfKGNtLCBpbnB1dFN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyc2UgY29tbWFuZCBuYW1lLlxuICAgICAgICB2YXIgY29tbWFuZE1hdGNoID0gaW5wdXRTdHJlYW0ubWF0Y2goL14oXFx3K3whIXxAQHxbISMmKjw9PkB+XSkvKTtcbiAgICAgICAgaWYgKGNvbW1hbmRNYXRjaCkge1xuICAgICAgICAgIHJlc3VsdC5jb21tYW5kTmFtZSA9IGNvbW1hbmRNYXRjaFsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuY29tbWFuZE5hbWUgPSBpbnB1dFN0cmVhbS5tYXRjaCgvLiovKVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgcGFyc2VMaW5lU3BlY186IGZ1bmN0aW9uKGNtLCBpbnB1dFN0cmVhbSkge1xuICAgICAgICB2YXIgbnVtYmVyTWF0Y2ggPSBpbnB1dFN0cmVhbS5tYXRjaCgvXihcXGQrKS8pO1xuICAgICAgICBpZiAobnVtYmVyTWF0Y2gpIHtcbiAgICAgICAgICAvLyBBYnNvbHV0ZSBsaW5lIG51bWJlciBwbHVzIG9mZnNldCAoTitNIG9yIE4tTSkgaXMgcHJvYmFibHkgYSB0eXBvLFxuICAgICAgICAgIC8vIG5vdCBzb21ldGhpbmcgdGhlIHVzZXIgYWN0dWFsbHkgd2FudGVkLiAoTkI6IHZpbSBkb2VzIGFsbG93IHRoaXMuKVxuICAgICAgICAgIHJldHVybiBwYXJzZUludChudW1iZXJNYXRjaFsxXSwgMTApIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGlucHV0U3RyZWFtLm5leHQoKSkge1xuICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaW5lU3BlY09mZnNldF8oaW5wdXRTdHJlYW0sIGNtLmdldEN1cnNvcigpLmxpbmUpO1xuICAgICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaW5lU3BlY09mZnNldF8oaW5wdXRTdHJlYW0sIGNtLmxhc3RMaW5lKCkpO1xuICAgICAgICAgIGNhc2UgJ1xcJyc6XG4gICAgICAgICAgICB2YXIgbWFya05hbWUgPSBpbnB1dFN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICB2YXIgbWFya1BvcyA9IGdldE1hcmtQb3MoY20sIGNtLnN0YXRlLnZpbSwgbWFya05hbWUpO1xuICAgICAgICAgICAgaWYgKCFtYXJrUG9zKSB0aHJvdyBuZXcgRXJyb3IoJ01hcmsgbm90IHNldCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaW5lU3BlY09mZnNldF8oaW5wdXRTdHJlYW0sIG1hcmtQb3MubGluZSk7XG4gICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgICAgICAvLyBPZmZzZXQgaXMgcmVsYXRpdmUgdG8gY3VycmVudCBsaW5lIGlmIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaW5lU3BlY09mZnNldF8oaW5wdXRTdHJlYW0sIGNtLmdldEN1cnNvcigpLmxpbmUpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFyc2VMaW5lU3BlY09mZnNldF86IGZ1bmN0aW9uKGlucHV0U3RyZWFtLCBsaW5lKSB7XG4gICAgICAgIHZhciBvZmZzZXRNYXRjaCA9IGlucHV0U3RyZWFtLm1hdGNoKC9eKFsrLV0pPyhcXGQrKS8pO1xuICAgICAgICBpZiAob2Zmc2V0TWF0Y2gpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQob2Zmc2V0TWF0Y2hbMl0sIDEwKTtcbiAgICAgICAgICBpZiAob2Zmc2V0TWF0Y2hbMV0gPT0gXCItXCIpIHtcbiAgICAgICAgICAgIGxpbmUgLT0gb2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lICs9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICB9LFxuICAgICAgcGFyc2VDb21tYW5kQXJnc186IGZ1bmN0aW9uKGlucHV0U3RyZWFtLCBwYXJhbXMsIGNvbW1hbmQpIHtcbiAgICAgICAgaWYgKGlucHV0U3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5hcmdTdHJpbmcgPSBpbnB1dFN0cmVhbS5tYXRjaCgvLiovKVswXTtcbiAgICAgICAgLy8gUGFyc2UgY29tbWFuZC1saW5lIGFyZ3VtZW50c1xuICAgICAgICB2YXIgZGVsaW0gPSBjb21tYW5kLmFyZ0RlbGltaXRlciB8fCAvXFxzKy87XG4gICAgICAgIHZhciBhcmdzID0gdHJpbShwYXJhbXMuYXJnU3RyaW5nKS5zcGxpdChkZWxpbSk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAmJiBhcmdzWzBdKSB7XG4gICAgICAgICAgcGFyYW1zLmFyZ3MgPSBhcmdzO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWF0Y2hDb21tYW5kXzogZnVuY3Rpb24oY29tbWFuZE5hbWUpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBjb21tYW5kIGluIHRoZSBjb21tYW5kIG1hcCB0aGF0IG1hdGNoZXMgdGhlIHNob3J0ZXN0XG4gICAgICAgIC8vIHByZWZpeCBvZiB0aGUgcGFzc2VkIGluIGNvbW1hbmQgbmFtZS4gVGhlIG1hdGNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcbiAgICAgICAgLy8gdW5hbWJpZ3VvdXMgaWYgdGhlIGRlZmF1bHRFeENvbW1hbmRNYXAncyBzaG9ydE5hbWVzIGFyZSBzZXQgdXBcbiAgICAgICAgLy8gY29ycmVjdGx5LiAoc2VlIEBjb2Rle2RlZmF1bHRFeENvbW1hbmRNYXB9KS5cbiAgICAgICAgZm9yICh2YXIgaSA9IGNvbW1hbmROYW1lLmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBjb21tYW5kTmFtZS5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICAgICAgaWYgKHRoaXMuY29tbWFuZE1hcF9bcHJlZml4XSkge1xuICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRNYXBfW3ByZWZpeF07XG4gICAgICAgICAgICBpZiAoY29tbWFuZC5uYW1lLmluZGV4T2YoY29tbWFuZE5hbWUpID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb21tYW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBidWlsZENvbW1hbmRNYXBfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kTWFwXyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZmF1bHRFeENvbW1hbmRNYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY29tbWFuZCA9IGRlZmF1bHRFeENvbW1hbmRNYXBbaV07XG4gICAgICAgICAgdmFyIGtleSA9IGNvbW1hbmQuc2hvcnROYW1lIHx8IGNvbW1hbmQubmFtZTtcbiAgICAgICAgICB0aGlzLmNvbW1hbmRNYXBfW2tleV0gPSBjb21tYW5kO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWFwOiBmdW5jdGlvbihsaHMsIHJocywgY3R4KSB7XG4gICAgICAgIGlmIChsaHMgIT0gJzonICYmIGxocy5jaGFyQXQoMCkgPT0gJzonKSB7XG4gICAgICAgICAgaWYgKGN0eCkgeyB0aHJvdyBFcnJvcignTW9kZSBub3Qgc3VwcG9ydGVkIGZvciBleCBtYXBwaW5ncycpOyB9XG4gICAgICAgICAgdmFyIGNvbW1hbmROYW1lID0gbGhzLnN1YnN0cmluZygxKTtcbiAgICAgICAgICBpZiAocmhzICE9ICc6JyAmJiByaHMuY2hhckF0KDApID09ICc6Jykge1xuICAgICAgICAgICAgLy8gRXggdG8gRXggbWFwcGluZ1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kTWFwX1tjb21tYW5kTmFtZV0gPSB7XG4gICAgICAgICAgICAgIG5hbWU6IGNvbW1hbmROYW1lLFxuICAgICAgICAgICAgICB0eXBlOiAnZXhUb0V4JyxcbiAgICAgICAgICAgICAgdG9JbnB1dDogcmhzLnN1YnN0cmluZygxKSxcbiAgICAgICAgICAgICAgdXNlcjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRXggdG8ga2V5IG1hcHBpbmdcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZE1hcF9bY29tbWFuZE5hbWVdID0ge1xuICAgICAgICAgICAgICBuYW1lOiBjb21tYW5kTmFtZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2V4VG9LZXknLFxuICAgICAgICAgICAgICB0b0tleXM6IHJocyxcbiAgICAgICAgICAgICAgdXNlcjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJocyAhPSAnOicgJiYgcmhzLmNoYXJBdCgwKSA9PSAnOicpIHtcbiAgICAgICAgICAgIC8vIEtleSB0byBFeCBtYXBwaW5nLlxuICAgICAgICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgIGtleXM6IGxocyxcbiAgICAgICAgICAgICAgdHlwZTogJ2tleVRvRXgnLFxuICAgICAgICAgICAgICBleEFyZ3M6IHsgaW5wdXQ6IHJocy5zdWJzdHJpbmcoMSkgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHgpIHsgbWFwcGluZy5jb250ZXh0ID0gY3R4OyB9XG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwLnVuc2hpZnQobWFwcGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEtleSB0byBrZXkgbWFwcGluZ1xuICAgICAgICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgIGtleXM6IGxocyxcbiAgICAgICAgICAgICAgdHlwZTogJ2tleVRvS2V5JyxcbiAgICAgICAgICAgICAgdG9LZXlzOiByaHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3R4KSB7IG1hcHBpbmcuY29udGV4dCA9IGN0eDsgfVxuICAgICAgICAgICAgZGVmYXVsdEtleW1hcC51bnNoaWZ0KG1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVubWFwOiBmdW5jdGlvbihsaHMsIGN0eCkge1xuICAgICAgICBpZiAobGhzICE9ICc6JyAmJiBsaHMuY2hhckF0KDApID09ICc6Jykge1xuICAgICAgICAgIC8vIEV4IHRvIEV4IG9yIEV4IHRvIGtleSBtYXBwaW5nXG4gICAgICAgICAgaWYgKGN0eCkgeyB0aHJvdyBFcnJvcignTW9kZSBub3Qgc3VwcG9ydGVkIGZvciBleCBtYXBwaW5ncycpOyB9XG4gICAgICAgICAgdmFyIGNvbW1hbmROYW1lID0gbGhzLnN1YnN0cmluZygxKTtcbiAgICAgICAgICBpZiAodGhpcy5jb21tYW5kTWFwX1tjb21tYW5kTmFtZV0gJiYgdGhpcy5jb21tYW5kTWFwX1tjb21tYW5kTmFtZV0udXNlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29tbWFuZE1hcF9bY29tbWFuZE5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBLZXkgdG8gRXggb3Iga2V5IHRvIGtleSBtYXBwaW5nXG4gICAgICAgICAgdmFyIGtleXMgPSBsaHM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZhdWx0S2V5bWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoa2V5cyA9PSBkZWZhdWx0S2V5bWFwW2ldLmtleXNcbiAgICAgICAgICAgICAgICAmJiBkZWZhdWx0S2V5bWFwW2ldLmNvbnRleHQgPT09IGN0eCkge1xuICAgICAgICAgICAgICBkZWZhdWx0S2V5bWFwLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBFcnJvcignTm8gc3VjaCBtYXBwaW5nLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZXhDb21tYW5kcyA9IHtcbiAgICAgIGNvbG9yc2NoZW1lOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7XG4gICAgICAgIGlmICghcGFyYW1zLmFyZ3MgfHwgcGFyYW1zLmFyZ3MubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHNob3dDb25maXJtKGNtLCBjbS5nZXRPcHRpb24oJ3RoZW1lJykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbS5zZXRPcHRpb24oJ3RoZW1lJywgcGFyYW1zLmFyZ3NbMF0pO1xuICAgICAgfSxcbiAgICAgIG1hcDogZnVuY3Rpb24oY20sIHBhcmFtcywgY3R4KSB7XG4gICAgICAgIHZhciBtYXBBcmdzID0gcGFyYW1zLmFyZ3M7XG4gICAgICAgIGlmICghbWFwQXJncyB8fCBtYXBBcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICBpZiAoY20pIHtcbiAgICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnSW52YWxpZCBtYXBwaW5nOiAnICsgcGFyYW1zLmlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIubWFwKG1hcEFyZ3NbMF0sIG1hcEFyZ3NbMV0sIGN0eCk7XG4gICAgICB9LFxuICAgICAgaW1hcDogZnVuY3Rpb24oY20sIHBhcmFtcykgeyB0aGlzLm1hcChjbSwgcGFyYW1zLCAnaW5zZXJ0Jyk7IH0sXG4gICAgICBubWFwOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7IHRoaXMubWFwKGNtLCBwYXJhbXMsICdub3JtYWwnKTsgfSxcbiAgICAgIHZtYXA6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHsgdGhpcy5tYXAoY20sIHBhcmFtcywgJ3Zpc3VhbCcpOyB9LFxuICAgICAgdW5tYXA6IGZ1bmN0aW9uKGNtLCBwYXJhbXMsIGN0eCkge1xuICAgICAgICB2YXIgbWFwQXJncyA9IHBhcmFtcy5hcmdzO1xuICAgICAgICBpZiAoIW1hcEFyZ3MgfHwgbWFwQXJncy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgaWYgKGNtKSB7XG4gICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ05vIHN1Y2ggbWFwcGluZzogJyArIHBhcmFtcy5pbnB1dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBleENvbW1hbmREaXNwYXRjaGVyLnVubWFwKG1hcEFyZ3NbMF0sIGN0eCk7XG4gICAgICB9LFxuICAgICAgbW92ZTogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgICBjb21tYW5kRGlzcGF0Y2hlci5wcm9jZXNzQ29tbWFuZChjbSwgY20uc3RhdGUudmltLCB7XG4gICAgICAgICAgICB0eXBlOiAnbW90aW9uJyxcbiAgICAgICAgICAgIG1vdGlvbjogJ21vdmVUb0xpbmVPckVkZ2VPZkRvY3VtZW50JyxcbiAgICAgICAgICAgIG1vdGlvbkFyZ3M6IHsgZm9yd2FyZDogZmFsc2UsIGV4cGxpY2l0UmVwZWF0OiB0cnVlLFxuICAgICAgICAgICAgICBsaW5ld2lzZTogdHJ1ZSB9LFxuICAgICAgICAgICAgcmVwZWF0T3ZlcnJpZGU6IHBhcmFtcy5saW5lKzF9KTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGNtLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNldEFyZ3MgPSBwYXJhbXMuYXJncztcbiAgICAgICAgLy8gT3B0aW9ucyBwYXNzZWQgdGhyb3VnaCB0byB0aGUgc2V0T3B0aW9uL2dldE9wdGlvbiBjYWxscy4gTWF5IGJlIHBhc3NlZCBpbiBieSB0aGVcbiAgICAgICAgLy8gbG9jYWwvZ2xvYmFsIHZlcnNpb25zIG9mIHRoZSBzZXQgY29tbWFuZFxuICAgICAgICB2YXIgc2V0Q2ZnID0gcGFyYW1zLnNldENmZyB8fCB7fTtcbiAgICAgICAgaWYgKCFzZXRBcmdzIHx8IHNldEFyZ3MubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIGlmIChjbSkge1xuICAgICAgICAgICAgc2hvd0NvbmZpcm0oY20sICdJbnZhbGlkIG1hcHBpbmc6ICcgKyBwYXJhbXMuaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cHIgPSBzZXRBcmdzWzBdLnNwbGl0KCc9Jyk7XG4gICAgICAgIHZhciBvcHRpb25OYW1lID0gZXhwclswXTtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwclsxXTtcbiAgICAgICAgdmFyIGZvcmNlR2V0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG9wdGlvbk5hbWUuY2hhckF0KG9wdGlvbk5hbWUubGVuZ3RoIC0gMSkgPT0gJz8nKSB7XG4gICAgICAgICAgLy8gSWYgcG9zdC1maXhlZCB3aXRoID8sIHRoZW4gdGhlIHNldCBpcyBhY3R1YWxseSBhIGdldC5cbiAgICAgICAgICBpZiAodmFsdWUpIHsgdGhyb3cgRXJyb3IoJ1RyYWlsaW5nIGNoYXJhY3RlcnM6ICcgKyBwYXJhbXMuYXJnU3RyaW5nKTsgfVxuICAgICAgICAgIG9wdGlvbk5hbWUgPSBvcHRpb25OYW1lLnN1YnN0cmluZygwLCBvcHRpb25OYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGZvcmNlR2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25OYW1lLnN1YnN0cmluZygwLCAyKSA9PSAnbm8nKSB7XG4gICAgICAgICAgLy8gVG8gc2V0IGJvb2xlYW4gb3B0aW9ucyB0byBmYWxzZSwgdGhlIG9wdGlvbiBuYW1lIGlzIHByZWZpeGVkIHdpdGhcbiAgICAgICAgICAvLyAnbm8nLlxuICAgICAgICAgIG9wdGlvbk5hbWUgPSBvcHRpb25OYW1lLnN1YnN0cmluZygyKTtcbiAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbklzQm9vbGVhbiA9IG9wdGlvbnNbb3B0aW9uTmFtZV0gJiYgb3B0aW9uc1tvcHRpb25OYW1lXS50eXBlID09ICdib29sZWFuJztcbiAgICAgICAgaWYgKG9wdGlvbklzQm9vbGVhbiAmJiB2YWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBDYWxsaW5nIHNldCB3aXRoIGEgYm9vbGVhbiBvcHRpb24gc2V0cyBpdCB0byB0cnVlLlxuICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyB2YWx1ZSBpcyBwcm92aWRlZCwgdGhlbiB3ZSBhc3N1bWUgdGhpcyBpcyBhIGdldC5cbiAgICAgICAgaWYgKCFvcHRpb25Jc0Jvb2xlYW4gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBmb3JjZUdldCkge1xuICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IGdldE9wdGlvbihvcHRpb25OYW1lLCBjbSwgc2V0Q2ZnKTtcbiAgICAgICAgICBpZiAob2xkVmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgc2hvd0NvbmZpcm0oY20sIG9sZFZhbHVlLm1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgPT09IHRydWUgfHwgb2xkVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJyAnICsgKG9sZFZhbHVlID8gJycgOiAnbm8nKSArIG9wdGlvbk5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJyAgJyArIG9wdGlvbk5hbWUgKyAnPScgKyBvbGRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzZXRPcHRpb25SZXR1cm4gPSBzZXRPcHRpb24ob3B0aW9uTmFtZSwgdmFsdWUsIGNtLCBzZXRDZmcpO1xuICAgICAgICAgIGlmIChzZXRPcHRpb25SZXR1cm4gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgc2hvd0NvbmZpcm0oY20sIHNldE9wdGlvblJldHVybi5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRsb2NhbDogZnVuY3Rpb24gKGNtLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gc2V0Q2ZnIGlzIHBhc3NlZCB0aHJvdWdoIHRvIHNldE9wdGlvblxuICAgICAgICBwYXJhbXMuc2V0Q2ZnID0ge3Njb3BlOiAnbG9jYWwnfTtcbiAgICAgICAgdGhpcy5zZXQoY20sIHBhcmFtcyk7XG4gICAgICB9LFxuICAgICAgc2V0Z2xvYmFsOiBmdW5jdGlvbiAoY20sIHBhcmFtcykge1xuICAgICAgICAvLyBzZXRDZmcgaXMgcGFzc2VkIHRocm91Z2ggdG8gc2V0T3B0aW9uXG4gICAgICAgIHBhcmFtcy5zZXRDZmcgPSB7c2NvcGU6ICdnbG9iYWwnfTtcbiAgICAgICAgdGhpcy5zZXQoY20sIHBhcmFtcyk7XG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJzOiBmdW5jdGlvbihjbSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciByZWdBcmdzID0gcGFyYW1zLmFyZ3M7XG4gICAgICAgIHZhciByZWdpc3RlcnMgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucmVnaXN0ZXJzO1xuICAgICAgICB2YXIgcmVnSW5mbyA9ICctLS0tLS0tLS0tUmVnaXN0ZXJzLS0tLS0tLS0tLVxcblxcbic7XG4gICAgICAgIGlmICghcmVnQXJncykge1xuICAgICAgICAgIGZvciAodmFyIHJlZ2lzdGVyTmFtZSBpbiByZWdpc3RlcnMpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gcmVnaXN0ZXJzW3JlZ2lzdGVyTmFtZV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZWdJbmZvICs9ICdcIicgKyByZWdpc3Rlck5hbWUgKyAnICAgICcgKyB0ZXh0ICsgJ1xcbidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdGVyTmFtZTtcbiAgICAgICAgICByZWdBcmdzID0gcmVnQXJncy5qb2luKCcnKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ0FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyTmFtZSA9IHJlZ0FyZ3MuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKCF2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIuaXNWYWxpZFJlZ2lzdGVyKHJlZ2lzdGVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVnaXN0ZXIgPSByZWdpc3RlcnNbcmVnaXN0ZXJOYW1lXSB8fCBuZXcgUmVnaXN0ZXIoKTtcbiAgICAgICAgICAgIHJlZ0luZm8gKz0gJ1wiJyArIHJlZ2lzdGVyTmFtZSArICcgICAgJyArIHJlZ2lzdGVyLnRvU3RyaW5nKCkgKyAnXFxuJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaG93Q29uZmlybShjbSwgcmVnSW5mbyk7XG4gICAgICB9LFxuICAgICAgc29ydDogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgICB2YXIgcmV2ZXJzZSwgaWdub3JlQ2FzZSwgdW5pcXVlLCBudW1iZXIsIHBhdHRlcm47XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlQXJncygpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmFyZ1N0cmluZykge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQ29kZU1pcnJvci5TdHJpbmdTdHJlYW0ocGFyYW1zLmFyZ1N0cmluZyk7XG4gICAgICAgICAgICBpZiAoYXJncy5lYXQoJyEnKSkgeyByZXZlcnNlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKGFyZ3MuZW9sKCkpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICBpZiAoIWFyZ3MuZWF0U3BhY2UoKSkgeyByZXR1cm4gJ0ludmFsaWQgYXJndW1lbnRzJzsgfVxuICAgICAgICAgICAgdmFyIG9wdHMgPSBhcmdzLm1hdGNoKC8oW2RpbnVveF0rKT9cXHMqKFxcLy4rXFwvKT9cXHMqLyk7XG4gICAgICAgICAgICBpZiAoIW9wdHMgJiYgIWFyZ3MuZW9sKCkpIHsgcmV0dXJuICdJbnZhbGlkIGFyZ3VtZW50cyc7IH1cbiAgICAgICAgICAgIGlmIChvcHRzWzFdKSB7XG4gICAgICAgICAgICAgIGlnbm9yZUNhc2UgPSBvcHRzWzFdLmluZGV4T2YoJ2knKSAhPSAtMTtcbiAgICAgICAgICAgICAgdW5pcXVlID0gb3B0c1sxXS5pbmRleE9mKCd1JykgIT0gLTE7XG4gICAgICAgICAgICAgIHZhciBkZWNpbWFsID0gb3B0c1sxXS5pbmRleE9mKCdkJykgIT0gLTEgfHwgb3B0c1sxXS5pbmRleE9mKCduJykgIT0gLTEgJiYgMTtcbiAgICAgICAgICAgICAgdmFyIGhleCA9IG9wdHNbMV0uaW5kZXhPZigneCcpICE9IC0xICYmIDE7XG4gICAgICAgICAgICAgIHZhciBvY3RhbCA9IG9wdHNbMV0uaW5kZXhPZignbycpICE9IC0xICYmIDE7XG4gICAgICAgICAgICAgIGlmIChkZWNpbWFsICsgaGV4ICsgb2N0YWwgPiAxKSB7IHJldHVybiAnSW52YWxpZCBhcmd1bWVudHMnOyB9XG4gICAgICAgICAgICAgIG51bWJlciA9IGRlY2ltYWwgJiYgJ2RlY2ltYWwnIHx8IGhleCAmJiAnaGV4JyB8fCBvY3RhbCAmJiAnb2N0YWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHNbMl0pIHtcbiAgICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAob3B0c1syXS5zdWJzdHIoMSwgb3B0c1syXS5sZW5ndGggLSAyKSwgaWdub3JlQ2FzZSA/ICdpJyA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyciA9IHBhcnNlQXJncygpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgc2hvd0NvbmZpcm0oY20sIGVyciArICc6ICcgKyBwYXJhbXMuYXJnU3RyaW5nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVTdGFydCA9IHBhcmFtcy5saW5lIHx8IGNtLmZpcnN0TGluZSgpO1xuICAgICAgICB2YXIgbGluZUVuZCA9IHBhcmFtcy5saW5lRW5kIHx8IHBhcmFtcy5saW5lIHx8IGNtLmxhc3RMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lU3RhcnQgPT0gbGluZUVuZCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIGN1clN0YXJ0ID0gUG9zKGxpbmVTdGFydCwgMCk7XG4gICAgICAgIHZhciBjdXJFbmQgPSBQb3MobGluZUVuZCwgbGluZUxlbmd0aChjbSwgbGluZUVuZCkpO1xuICAgICAgICB2YXIgdGV4dCA9IGNtLmdldFJhbmdlKGN1clN0YXJ0LCBjdXJFbmQpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIG51bWJlclJlZ2V4ID0gcGF0dGVybiA/IHBhdHRlcm4gOlxuICAgICAgICAgICAobnVtYmVyID09ICdkZWNpbWFsJykgPyAvKC0/KShbXFxkXSspLyA6XG4gICAgICAgICAgIChudW1iZXIgPT0gJ2hleCcpID8gLygtPykoPzoweCk/KFswLTlhLWZdKykvaSA6XG4gICAgICAgICAgIChudW1iZXIgPT0gJ29jdGFsJykgPyAvKFswLTddKykvIDogbnVsbDtcbiAgICAgICAgdmFyIHJhZGl4ID0gKG51bWJlciA9PSAnZGVjaW1hbCcpID8gMTAgOiAobnVtYmVyID09ICdoZXgnKSA/IDE2IDogKG51bWJlciA9PSAnb2N0YWwnKSA/IDggOiBudWxsO1xuICAgICAgICB2YXIgbnVtUGFydCA9IFtdLCB0ZXh0UGFydCA9IFtdO1xuICAgICAgICBpZiAobnVtYmVyIHx8IHBhdHRlcm4pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtYXRjaFBhcnQgPSBwYXR0ZXJuID8gdGV4dFtpXS5tYXRjaChwYXR0ZXJuKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAobWF0Y2hQYXJ0ICYmIG1hdGNoUGFydFswXSAhPSAnJykge1xuICAgICAgICAgICAgICBudW1QYXJ0LnB1c2gobWF0Y2hQYXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBhdHRlcm4gJiYgbnVtYmVyUmVnZXguZXhlYyh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICBudW1QYXJ0LnB1c2godGV4dFtpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ZXh0UGFydC5wdXNoKHRleHRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0UGFydCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUZuKGEsIGIpIHtcbiAgICAgICAgICBpZiAocmV2ZXJzZSkgeyB2YXIgdG1wOyB0bXAgPSBhOyBhID0gYjsgYiA9IHRtcDsgfVxuICAgICAgICAgIGlmIChpZ25vcmVDYXNlKSB7IGEgPSBhLnRvTG93ZXJDYXNlKCk7IGIgPSBiLnRvTG93ZXJDYXNlKCk7IH1cbiAgICAgICAgICB2YXIgYW51bSA9IG51bWJlciAmJiBudW1iZXJSZWdleC5leGVjKGEpO1xuICAgICAgICAgIHZhciBibnVtID0gbnVtYmVyICYmIG51bWJlclJlZ2V4LmV4ZWMoYik7XG4gICAgICAgICAgaWYgKCFhbnVtKSB7IHJldHVybiBhIDwgYiA/IC0xIDogMTsgfVxuICAgICAgICAgIGFudW0gPSBwYXJzZUludCgoYW51bVsxXSArIGFudW1bMl0pLnRvTG93ZXJDYXNlKCksIHJhZGl4KTtcbiAgICAgICAgICBibnVtID0gcGFyc2VJbnQoKGJudW1bMV0gKyBibnVtWzJdKS50b0xvd2VyQ2FzZSgpLCByYWRpeCk7XG4gICAgICAgICAgcmV0dXJuIGFudW0gLSBibnVtO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmVQYXR0ZXJuRm4oYSwgYikge1xuICAgICAgICAgIGlmIChyZXZlcnNlKSB7IHZhciB0bXA7IHRtcCA9IGE7IGEgPSBiOyBiID0gdG1wOyB9XG4gICAgICAgICAgaWYgKGlnbm9yZUNhc2UpIHsgYVswXSA9IGFbMF0udG9Mb3dlckNhc2UoKTsgYlswXSA9IGJbMF0udG9Mb3dlckNhc2UoKTsgfVxuICAgICAgICAgIHJldHVybiAoYVswXSA8IGJbMF0pID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIG51bVBhcnQuc29ydChwYXR0ZXJuID8gY29tcGFyZVBhdHRlcm5GbiA6IGNvbXBhcmVGbik7XG4gICAgICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1QYXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBudW1QYXJ0W2ldID0gbnVtUGFydFtpXS5pbnB1dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIW51bWJlcikgeyB0ZXh0UGFydC5zb3J0KGNvbXBhcmVGbik7IH1cbiAgICAgICAgdGV4dCA9ICghcmV2ZXJzZSkgPyB0ZXh0UGFydC5jb25jYXQobnVtUGFydCkgOiBudW1QYXJ0LmNvbmNhdCh0ZXh0UGFydCk7XG4gICAgICAgIGlmICh1bmlxdWUpIHsgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBsaW5lc1xuICAgICAgICAgIHZhciB0ZXh0T2xkID0gdGV4dDtcbiAgICAgICAgICB2YXIgbGFzdExpbmU7XG4gICAgICAgICAgdGV4dCA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dE9sZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRleHRPbGRbaV0gIT0gbGFzdExpbmUpIHtcbiAgICAgICAgICAgICAgdGV4dC5wdXNoKHRleHRPbGRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdExpbmUgPSB0ZXh0T2xkW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbS5yZXBsYWNlUmFuZ2UodGV4dC5qb2luKCdcXG4nKSwgY3VyU3RhcnQsIGN1ckVuZCk7XG4gICAgICB9LFxuICAgICAgdmdsb2JhbDogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgICAvLyBnbG9iYWwgaW5zcGVjdHMgcGFyYW1zLmNvbW1hbmROYW1lXG4gICAgICAgIHRoaXMuZ2xvYmFsKGNtLCBwYXJhbXMpO1xuICAgICAgfSxcbiAgICAgIGdsb2JhbDogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgICAvLyBhIGdsb2JhbCBjb21tYW5kIGlzIG9mIHRoZSBmb3JtXG4gICAgICAgIC8vIDpbcmFuZ2VdZy9wYXR0ZXJuL1tjbWRdXG4gICAgICAgIC8vIGFyZ1N0cmluZyBob2xkcyB0aGUgc3RyaW5nIC9wYXR0ZXJuL1tjbWRdXG4gICAgICAgIHZhciBhcmdTdHJpbmcgPSBwYXJhbXMuYXJnU3RyaW5nO1xuICAgICAgICBpZiAoIWFyZ1N0cmluZykge1xuICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnUmVndWxhciBFeHByZXNzaW9uIG1pc3NpbmcgZnJvbSBnbG9iYWwnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludmVydGVkID0gcGFyYW1zLmNvbW1hbmROYW1lWzBdID09PSAndic7XG4gICAgICAgIC8vIHJhbmdlIGlzIHNwZWNpZmllZCBoZXJlXG4gICAgICAgIHZhciBsaW5lU3RhcnQgPSAocGFyYW1zLmxpbmUgIT09IHVuZGVmaW5lZCkgPyBwYXJhbXMubGluZSA6IGNtLmZpcnN0TGluZSgpO1xuICAgICAgICB2YXIgbGluZUVuZCA9IHBhcmFtcy5saW5lRW5kIHx8IHBhcmFtcy5saW5lIHx8IGNtLmxhc3RMaW5lKCk7XG4gICAgICAgIC8vIGdldCB0aGUgdG9rZW5zIGZyb20gYXJnU3RyaW5nXG4gICAgICAgIHZhciB0b2tlbnMgPSBzcGxpdEJ5U2xhc2goYXJnU3RyaW5nKTtcbiAgICAgICAgdmFyIHJlZ2V4UGFydCA9IGFyZ1N0cmluZywgY21kO1xuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgIHJlZ2V4UGFydCA9IHRva2Vuc1swXTtcbiAgICAgICAgICBjbWQgPSB0b2tlbnMuc2xpY2UoMSwgdG9rZW5zLmxlbmd0aCkuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdleFBhcnQpIHtcbiAgICAgICAgICAvLyBJZiByZWdleCBwYXJ0IGlzIGVtcHR5LCB0aGVuIHVzZSB0aGUgcHJldmlvdXMgcXVlcnkuIE90aGVyd2lzZVxuICAgICAgICAgIC8vIHVzZSB0aGUgcmVnZXggcGFydCBhcyB0aGUgbmV3IHF1ZXJ5LlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgIHVwZGF0ZVNlYXJjaFF1ZXJ5KGNtLCByZWdleFBhcnQsIHRydWUgLyoqIGlnbm9yZUNhc2UgKi8sXG4gICAgICAgICAgICAgdHJ1ZSAvKiogc21hcnRDYXNlICovKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnSW52YWxpZCByZWdleDogJyArIHJlZ2V4UGFydCk7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgcmVnZXhQYXJ0LCBzZWFyY2ggZm9yIHJlZ2V4IG1hdGNoZXMgaW4gdGhlXG4gICAgICAgIC8vIHNwZWNpZmllZCByYW5nZSBvZiBsaW5lc1xuICAgICAgICB2YXIgcXVlcnkgPSBnZXRTZWFyY2hTdGF0ZShjbSkuZ2V0UXVlcnkoKTtcbiAgICAgICAgdmFyIG1hdGNoZWRMaW5lcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gbGluZVN0YXJ0OyBpIDw9IGxpbmVFbmQ7IGkrKykge1xuICAgICAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZUhhbmRsZShpKTtcbiAgICAgICAgICB2YXIgbWF0Y2hlZCA9IHF1ZXJ5LnRlc3QobGluZS50ZXh0KTtcbiAgICAgICAgICBpZiAobWF0Y2hlZCAhPT0gaW52ZXJ0ZWQpIHtcbiAgICAgICAgICAgIG1hdGNoZWRMaW5lcy5wdXNoKGNtZCA/IGxpbmUgOiBsaW5lLnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBbY21kXSwganVzdCBkaXNwbGF5IHRoZSBsaXN0IG9mIG1hdGNoZWQgbGluZXNcbiAgICAgICAgaWYgKCFjbWQpIHtcbiAgICAgICAgICBzaG93Q29uZmlybShjbSwgbWF0Y2hlZExpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG5leHRDb21tYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgbWF0Y2hlZExpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBtYXRjaGVkTGluZXNbaW5kZXgrK107XG4gICAgICAgICAgICB2YXIgbGluZU51bSA9IGNtLmdldExpbmVOdW1iZXIobGluZSk7XG4gICAgICAgICAgICBpZiAobGluZU51bSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG5leHRDb21tYW5kKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21tYW5kID0gKGxpbmVOdW0gKyAxKSArIGNtZDtcbiAgICAgICAgICAgIGV4Q29tbWFuZERpc3BhdGNoZXIucHJvY2Vzc0NvbW1hbmQoY20sIGNvbW1hbmQsIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IG5leHRDb21tYW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG5leHRDb21tYW5kKCk7XG4gICAgICB9LFxuICAgICAgc3Vic3RpdHV0ZTogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgICBpZiAoIWNtLmdldFNlYXJjaEN1cnNvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VhcmNoIGZlYXR1cmUgbm90IGF2YWlsYWJsZS4gUmVxdWlyZXMgc2VhcmNoY3Vyc29yLmpzIG9yICcgK1xuICAgICAgICAgICAgICAnYW55IG90aGVyIGdldFNlYXJjaEN1cnNvciBpbXBsZW1lbnRhdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJnU3RyaW5nID0gcGFyYW1zLmFyZ1N0cmluZztcbiAgICAgICAgdmFyIHRva2VucyA9IGFyZ1N0cmluZyA/IHNwbGl0QnlTZXBhcmF0b3IoYXJnU3RyaW5nLCBhcmdTdHJpbmdbMF0pIDogW107XG4gICAgICAgIHZhciByZWdleFBhcnQsIHJlcGxhY2VQYXJ0ID0gJycsIHRyYWlsaW5nLCBmbGFnc1BhcnQsIGNvdW50O1xuICAgICAgICB2YXIgY29uZmlybSA9IGZhbHNlOyAvLyBXaGV0aGVyIHRvIGNvbmZpcm0gZWFjaCByZXBsYWNlLlxuICAgICAgICB2YXIgZ2xvYmFsID0gZmFsc2U7IC8vIFRydWUgdG8gcmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9uIGEgbGluZSwgZmFsc2UgdG8gcmVwbGFjZSBvbmx5IDEuXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVnZXhQYXJ0ID0gdG9rZW5zWzBdO1xuICAgICAgICAgIGlmIChnZXRPcHRpb24oJ3BjcmUnKSAmJiByZWdleFBhcnQgIT09ICcnKSB7XG4gICAgICAgICAgICAgIHJlZ2V4UGFydCA9IG5ldyBSZWdFeHAocmVnZXhQYXJ0KS5zb3VyY2U7IC8vbm9ybWFsaXplIG5vdCBlc2NhcGVkIGNoYXJhY3RlcnNcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwbGFjZVBhcnQgPSB0b2tlbnNbMV07XG4gICAgICAgICAgLy8gSWYgdGhlIHBhdHRlcm4gZW5kcyB3aXRoICQgKGxpbmUgYm91bmRhcnkgYXNzZXJ0aW9uKSwgY2hhbmdlICQgdG8gXFxuLlxuICAgICAgICAgIC8vIENhdmVhdDogdGhpcyB3b3JrYXJvdW5kIGNhbm5vdCBtYXRjaCBvbiB0aGUgbGFzdCBsaW5lIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICBpZiAoLyhefFteXFxcXF0pKFxcXFxcXFxcKSpcXCQkLy50ZXN0KHJlZ2V4UGFydCkpIHtcbiAgICAgICAgICAgIHJlZ2V4UGFydCA9IHJlZ2V4UGFydC5zbGljZSgwLCAtMSkgKyAnXFxcXG4nO1xuICAgICAgICAgICAgcmVwbGFjZVBhcnQgPSAocmVwbGFjZVBhcnQgfHwgJycpICsgJ1xcbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXBsYWNlUGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZ2V0T3B0aW9uKCdwY3JlJykpIHtcbiAgICAgICAgICAgICAgcmVwbGFjZVBhcnQgPSB1bmVzY2FwZVJlZ2V4UmVwbGFjZShyZXBsYWNlUGFydC5yZXBsYWNlKC8oW15cXFxcXSkmL2csXCIkMSQkJlwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXBsYWNlUGFydCA9IHRyYW5zbGF0ZVJlZ2V4UmVwbGFjZShyZXBsYWNlUGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aW1HbG9iYWxTdGF0ZS5sYXN0U3Vic3RpdHV0ZVJlcGxhY2VQYXJ0ID0gcmVwbGFjZVBhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYWlsaW5nID0gdG9rZW5zWzJdID8gdG9rZW5zWzJdLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlaXRoZXIgdGhlIGFyZ1N0cmluZyBpcyBlbXB0eSBvciBpdHMgb2YgdGhlIGZvcm0gJyBoZWxsby93b3JsZCdcbiAgICAgICAgICAvLyBhY3R1YWxseSBzcGxpdEJ5U2xhc2ggcmV0dXJucyBhIGxpc3Qgb2YgdG9rZW5zXG4gICAgICAgICAgLy8gb25seSBpZiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIGEgJy8nXG4gICAgICAgICAgaWYgKGFyZ1N0cmluZyAmJiBhcmdTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ1N1YnN0aXR1dGlvbnMgc2hvdWxkIGJlIG9mIHRoZSBmb3JtICcgK1xuICAgICAgICAgICAgICAgICc6cy9wYXR0ZXJuL3JlcGxhY2UvJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFmdGVyIHRoZSAzcmQgc2xhc2gsIHdlIGNhbiBoYXZlIGZsYWdzIGZvbGxvd2VkIGJ5IGEgc3BhY2UgZm9sbG93ZWRcbiAgICAgICAgLy8gYnkgY291bnQuXG4gICAgICAgIGlmICh0cmFpbGluZykge1xuICAgICAgICAgIGZsYWdzUGFydCA9IHRyYWlsaW5nWzBdO1xuICAgICAgICAgIGNvdW50ID0gcGFyc2VJbnQodHJhaWxpbmdbMV0pO1xuICAgICAgICAgIGlmIChmbGFnc1BhcnQpIHtcbiAgICAgICAgICAgIGlmIChmbGFnc1BhcnQuaW5kZXhPZignYycpICE9IC0xKSB7XG4gICAgICAgICAgICAgIGNvbmZpcm0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzUGFydC5pbmRleE9mKCdnJykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgZ2xvYmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRPcHRpb24oJ3BjcmUnKSkge1xuICAgICAgICAgICAgICAgcmVnZXhQYXJ0ID0gcmVnZXhQYXJ0ICsgJy8nICsgZmxhZ3NQYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHJlZ2V4UGFydCA9IHJlZ2V4UGFydC5yZXBsYWNlKC9cXC8vZywgXCJcXFxcL1wiKSArICcvJyArIGZsYWdzUGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZ2V4UGFydCkge1xuICAgICAgICAgIC8vIElmIHJlZ2V4IHBhcnQgaXMgZW1wdHksIHRoZW4gdXNlIHRoZSBwcmV2aW91cyBxdWVyeS4gT3RoZXJ3aXNlIHVzZVxuICAgICAgICAgIC8vIHRoZSByZWdleCBwYXJ0IGFzIHRoZSBuZXcgcXVlcnkuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVwZGF0ZVNlYXJjaFF1ZXJ5KGNtLCByZWdleFBhcnQsIHRydWUgLyoqIGlnbm9yZUNhc2UgKi8sXG4gICAgICAgICAgICAgIHRydWUgLyoqIHNtYXJ0Q2FzZSAqLyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgc2hvd0NvbmZpcm0oY20sICdJbnZhbGlkIHJlZ2V4OiAnICsgcmVnZXhQYXJ0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZVBhcnQgPSByZXBsYWNlUGFydCB8fCB2aW1HbG9iYWxTdGF0ZS5sYXN0U3Vic3RpdHV0ZVJlcGxhY2VQYXJ0O1xuICAgICAgICBpZiAocmVwbGFjZVBhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnTm8gcHJldmlvdXMgc3Vic3RpdHV0ZSByZWd1bGFyIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0U2VhcmNoU3RhdGUoY20pO1xuICAgICAgICB2YXIgcXVlcnkgPSBzdGF0ZS5nZXRRdWVyeSgpO1xuICAgICAgICB2YXIgbGluZVN0YXJ0ID0gKHBhcmFtcy5saW5lICE9PSB1bmRlZmluZWQpID8gcGFyYW1zLmxpbmUgOiBjbS5nZXRDdXJzb3IoKS5saW5lO1xuICAgICAgICB2YXIgbGluZUVuZCA9IHBhcmFtcy5saW5lRW5kIHx8IGxpbmVTdGFydDtcbiAgICAgICAgaWYgKGxpbmVTdGFydCA9PSBjbS5maXJzdExpbmUoKSAmJiBsaW5lRW5kID09IGNtLmxhc3RMaW5lKCkpIHtcbiAgICAgICAgICBsaW5lRW5kID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgbGluZVN0YXJ0ID0gbGluZUVuZDtcbiAgICAgICAgICBsaW5lRW5kID0gbGluZVN0YXJ0ICsgY291bnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydFBvcyA9IGNsaXBDdXJzb3JUb0NvbnRlbnQoY20sIFBvcyhsaW5lU3RhcnQsIDApKTtcbiAgICAgICAgdmFyIGN1cnNvciA9IGNtLmdldFNlYXJjaEN1cnNvcihxdWVyeSwgc3RhcnRQb3MpO1xuICAgICAgICBkb1JlcGxhY2UoY20sIGNvbmZpcm0sIGdsb2JhbCwgbGluZVN0YXJ0LCBsaW5lRW5kLCBjdXJzb3IsIHF1ZXJ5LCByZXBsYWNlUGFydCwgcGFyYW1zLmNhbGxiYWNrKTtcbiAgICAgIH0sXG4gICAgICByZWRvOiBDb2RlTWlycm9yLmNvbW1hbmRzLnJlZG8sXG4gICAgICB1bmRvOiBDb2RlTWlycm9yLmNvbW1hbmRzLnVuZG8sXG4gICAgICB3cml0ZTogZnVuY3Rpb24oY20pIHtcbiAgICAgICAgaWYgKENvZGVNaXJyb3IuY29tbWFuZHMuc2F2ZSkge1xuICAgICAgICAgIC8vIElmIGEgc2F2ZSBjb21tYW5kIGlzIGRlZmluZWQsIGNhbGwgaXQuXG4gICAgICAgICAgQ29kZU1pcnJvci5jb21tYW5kcy5zYXZlKGNtKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbS5zYXZlKSB7XG4gICAgICAgICAgLy8gU2F2ZXMgdG8gdGV4dCBhcmVhIGlmIG5vIHNhdmUgY29tbWFuZCBpcyBkZWZpbmVkIGFuZCBjbS5zYXZlKCkgaXMgYXZhaWxhYmxlLlxuICAgICAgICAgIGNtLnNhdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vaGxzZWFyY2g6IGZ1bmN0aW9uKGNtKSB7XG4gICAgICAgIGNsZWFyU2VhcmNoSGlnaGxpZ2h0KGNtKTtcbiAgICAgIH0sXG4gICAgICB5YW5rOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgdmFyIGN1ciA9IGNvcHlDdXJzb3IoY20uZ2V0Q3Vyc29yKCkpO1xuICAgICAgICB2YXIgbGluZSA9IGN1ci5saW5lO1xuICAgICAgICB2YXIgbGluZVRleHQgPSBjbS5nZXRMaW5lKGxpbmUpO1xuICAgICAgICB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIucHVzaFRleHQoXG4gICAgICAgICAgJzAnLCAneWFuaycsIGxpbmVUZXh0LCB0cnVlLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBkZWxtYXJrczogZnVuY3Rpb24oY20sIHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy5hcmdTdHJpbmcgfHwgIXRyaW0ocGFyYW1zLmFyZ1N0cmluZykpIHtcbiAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0FyZ3VtZW50IHJlcXVpcmVkJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXRlID0gY20uc3RhdGUudmltO1xuICAgICAgICB2YXIgc3RyZWFtID0gbmV3IENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtKHRyaW0ocGFyYW1zLmFyZ1N0cmluZykpO1xuICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuXG4gICAgICAgICAgLy8gUmVjb3JkIHRoZSBzdHJlYW1zIHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxvb3AgZm9yIHVzZVxuICAgICAgICAgIC8vIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICAgIHZhciBjb3VudCA9IHN0cmVhbS5wb3M7XG5cbiAgICAgICAgICBpZiAoIXN0cmVhbS5tYXRjaCgvW2EtekEtWl0vLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHNob3dDb25maXJtKGNtLCAnSW52YWxpZCBhcmd1bWVudDogJyArIHBhcmFtcy5hcmdTdHJpbmcuc3Vic3RyaW5nKGNvdW50KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN5bSA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBzeW1ib2wgaXMgcGFydCBvZiBhIHJhbmdlXG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgnLScsIHRydWUpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHN5bWJvbCBpcyBwYXJ0IG9mIGEgcmFuZ2UuXG5cbiAgICAgICAgICAgIC8vIFRoZSByYW5nZSBtdXN0IHRlcm1pbmF0ZSBhdCBhbiBhbHBoYWJldGljIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGlmICghc3RyZWFtLm1hdGNoKC9bYS16QS1aXS8sIGZhbHNlKSkge1xuICAgICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgYXJndW1lbnQ6ICcgKyBwYXJhbXMuYXJnU3RyaW5nLnN1YnN0cmluZyhjb3VudCkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGFydE1hcmsgPSBzeW07XG4gICAgICAgICAgICB2YXIgZmluaXNoTWFyayA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICAvLyBUaGUgcmFuZ2UgbXVzdCB0ZXJtaW5hdGUgYXQgYW4gYWxwaGFiZXRpYyBjaGFyYWN0ZXIgd2hpY2hcbiAgICAgICAgICAgIC8vIHNoYXJlcyB0aGUgc2FtZSBjYXNlIGFzIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICAgICAgICBpZiAoaXNMb3dlckNhc2Uoc3RhcnRNYXJrKSAmJiBpc0xvd2VyQ2FzZShmaW5pc2hNYXJrKSB8fFxuICAgICAgICAgICAgICAgIGlzVXBwZXJDYXNlKHN0YXJ0TWFyaykgJiYgaXNVcHBlckNhc2UoZmluaXNoTWFyaykpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc3RhcnRNYXJrLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIHZhciBmaW5pc2ggPSBmaW5pc2hNYXJrLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+PSBmaW5pc2gpIHtcbiAgICAgICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgYXJndW1lbnQ6ICcgKyBwYXJhbXMuYXJnU3RyaW5nLnN1YnN0cmluZyhjb3VudCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEJlY2F1c2UgbWFya3MgYXJlIGFsd2F5cyBBU0NJSSB2YWx1ZXMsIGFuZCB3ZSBoYXZlXG4gICAgICAgICAgICAgIC8vIGRldGVybWluZWQgdGhhdCB0aGV5IGFyZSB0aGUgc2FtZSBjYXNlLCB3ZSBjYW4gdXNlXG4gICAgICAgICAgICAgIC8vIHRoZWlyIGNoYXIgY29kZXMgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBkZWZpbmVkIHJhbmdlLlxuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBmaW5pc2ggLSBzdGFydDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmsgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0ICsgaik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLm1hcmtzW21hcmtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzaG93Q29uZmlybShjbSwgJ0ludmFsaWQgYXJndW1lbnQ6ICcgKyBzdGFydE1hcmsgKyAnLScpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc3ltYm9sIGlzIGEgdmFsaWQgbWFyaywgYW5kIGlzIG5vdCBwYXJ0IG9mIGEgcmFuZ2UuXG4gICAgICAgICAgICBkZWxldGUgc3RhdGUubWFya3Nbc3ltXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGV4Q29tbWFuZERpc3BhdGNoZXIgPSBuZXcgRXhDb21tYW5kRGlzcGF0Y2hlcigpO1xuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0NvZGVNaXJyb3J9IGNtIENvZGVNaXJyb3IgaW5zdGFuY2Ugd2UgYXJlIGluLlxuICAgICogQHBhcmFtIHtib29sZWFufSBjb25maXJtIFdoZXRoZXIgdG8gY29uZmlybSBlYWNoIHJlcGxhY2UuXG4gICAgKiBAcGFyYW0ge0N1cnNvcn0gbGluZVN0YXJ0IExpbmUgdG8gc3RhcnQgcmVwbGFjaW5nIGZyb20uXG4gICAgKiBAcGFyYW0ge0N1cnNvcn0gbGluZUVuZCBMaW5lIHRvIHN0b3AgcmVwbGFjaW5nIGF0LlxuICAgICogQHBhcmFtIHtSZWdFeHB9IHF1ZXJ5IFF1ZXJ5IGZvciBwZXJmb3JtaW5nIG1hdGNoZXMgd2l0aC5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXBsYWNlV2l0aCBUZXh0IHRvIHJlcGxhY2UgbWF0Y2hlcyB3aXRoLiBNYXkgY29udGFpbiAkMSxcbiAgICAqICAgICAkMiwgZXRjIGZvciByZXBsYWNpbmcgY2FwdHVyZWQgZ3JvdXBzIHVzaW5nIEphdmFTY3JpcHQgcmVwbGFjZS5cbiAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQSBjYWxsYmFjayBmb3Igd2hlbiB0aGUgcmVwbGFjZSBpcyBkb25lLlxuICAgICovXG4gICAgZnVuY3Rpb24gZG9SZXBsYWNlKGNtLCBjb25maXJtLCBnbG9iYWwsIGxpbmVTdGFydCwgbGluZUVuZCwgc2VhcmNoQ3Vyc29yLCBxdWVyeSxcbiAgICAgICAgcmVwbGFjZVdpdGgsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBTZXQgdXAgYWxsIHRoZSBmdW5jdGlvbnMuXG4gICAgICBjbS5zdGF0ZS52aW0uZXhNb2RlID0gdHJ1ZTtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICB2YXIgbGFzdFBvcywgbW9kaWZpZWRMaW5lTnVtYmVyLCBqb2luZWQ7XG4gICAgICBmdW5jdGlvbiByZXBsYWNlQWxsKCkge1xuICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICByZXBsYWNlKCk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNtLmdldFJhbmdlKHNlYXJjaEN1cnNvci5mcm9tKCksIHNlYXJjaEN1cnNvci50bygpKTtcbiAgICAgICAgdmFyIG5ld1RleHQgPSB0ZXh0LnJlcGxhY2UocXVlcnksIHJlcGxhY2VXaXRoKTtcbiAgICAgICAgdmFyIHVubW9kaWZpZWRMaW5lTnVtYmVyID0gc2VhcmNoQ3Vyc29yLnRvKCkubGluZTtcbiAgICAgICAgc2VhcmNoQ3Vyc29yLnJlcGxhY2UobmV3VGV4dCk7XG4gICAgICAgIG1vZGlmaWVkTGluZU51bWJlciA9IHNlYXJjaEN1cnNvci50bygpLmxpbmU7XG4gICAgICAgIGxpbmVFbmQgKz0gbW9kaWZpZWRMaW5lTnVtYmVyIC0gdW5tb2RpZmllZExpbmVOdW1iZXI7XG4gICAgICAgIGpvaW5lZCA9IG1vZGlmaWVkTGluZU51bWJlciA8IHVubW9kaWZpZWRMaW5lTnVtYmVyO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgLy8gVGhlIGJlbG93IG9ubHkgbG9vcHMgdG8gc2tpcCBvdmVyIG11bHRpcGxlIG9jY3VycmVuY2VzIG9uIHRoZSBzYW1lXG4gICAgICAgIC8vIGxpbmUgd2hlbiAnZ2xvYmFsJyBpcyBub3QgdHJ1ZS5cbiAgICAgICAgd2hpbGUoc2VhcmNoQ3Vyc29yLmZpbmROZXh0KCkgJiZcbiAgICAgICAgICAgICAgaXNJblJhbmdlKHNlYXJjaEN1cnNvci5mcm9tKCksIGxpbmVTdGFydCwgbGluZUVuZCkpIHtcbiAgICAgICAgICBpZiAoIWdsb2JhbCAmJiBzZWFyY2hDdXJzb3IuZnJvbSgpLmxpbmUgPT0gbW9kaWZpZWRMaW5lTnVtYmVyICYmICFqb2luZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbS5zY3JvbGxJbnRvVmlldyhzZWFyY2hDdXJzb3IuZnJvbSgpLCAzMCk7XG4gICAgICAgICAgY20uc2V0U2VsZWN0aW9uKHNlYXJjaEN1cnNvci5mcm9tKCksIHNlYXJjaEN1cnNvci50bygpKTtcbiAgICAgICAgICBsYXN0UG9zID0gc2VhcmNoQ3Vyc29yLmZyb20oKTtcbiAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3RvcChjbG9zZSkge1xuICAgICAgICBpZiAoY2xvc2UpIHsgY2xvc2UoKTsgfVxuICAgICAgICBjbS5mb2N1cygpO1xuICAgICAgICBpZiAobGFzdFBvcykge1xuICAgICAgICAgIGNtLnNldEN1cnNvcihsYXN0UG9zKTtcbiAgICAgICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgICAgIHZpbS5leE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICB2aW0ubGFzdEhQb3MgPSB2aW0ubGFzdEhTUG9zID0gbGFzdFBvcy5jaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soKTsgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25Qcm9tcHRLZXlEb3duKGUsIF92YWx1ZSwgY2xvc2UpIHtcbiAgICAgICAgLy8gU3dhbGxvdyBhbGwga2V5cy5cbiAgICAgICAgQ29kZU1pcnJvci5lX3N0b3AoZSk7XG4gICAgICAgIHZhciBrZXlOYW1lID0gQ29kZU1pcnJvci5rZXlOYW1lKGUpO1xuICAgICAgICBzd2l0Y2ggKGtleU5hbWUpIHtcbiAgICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICAgIHJlcGxhY2UoKTsgbmV4dCgpOyBicmVhaztcbiAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgIG5leHQoKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyByZXBsYWNlQWxsIGNvbnRhaW5zIGEgY2FsbCB0byBjbG9zZSBvZiBpdHMgb3duLiBXZSBkb24ndCB3YW50IGl0XG4gICAgICAgICAgICAvLyB0byBmaXJlIHRvbyBlYXJseSBvciBtdWx0aXBsZSB0aW1lcy5cbiAgICAgICAgICAgIHZhciBzYXZlZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNtLm9wZXJhdGlvbihyZXBsYWNlQWxsKTtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gc2F2ZWRDYWxsYmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgcmVwbGFjZSgpO1xuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIGFuZCBleGl0LlxuICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgIGNhc2UgJ0VzYyc6XG4gICAgICAgICAgY2FzZSAnQ3RybC1DJzpcbiAgICAgICAgICBjYXNlICdDdHJsLVsnOlxuICAgICAgICAgICAgc3RvcChjbG9zZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9uZSkgeyBzdG9wKGNsb3NlKTsgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQWN0dWFsbHkgZG8gcmVwbGFjZS5cbiAgICAgIG5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHNob3dDb25maXJtKGNtLCAnTm8gbWF0Y2hlcyBmb3IgJyArIHF1ZXJ5LnNvdXJjZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghY29uZmlybSkge1xuICAgICAgICByZXBsYWNlQWxsKCk7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjaygpOyB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNob3dQcm9tcHQoY20sIHtcbiAgICAgICAgcHJlZml4OiBkb20oJ3NwYW4nLCAncmVwbGFjZSB3aXRoICcsIGRvbSgnc3Ryb25nJywgcmVwbGFjZVdpdGgpLCAnICh5L24vYS9xL2wpJyksXG4gICAgICAgIG9uS2V5RG93bjogb25Qcm9tcHRLZXlEb3duXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBDb2RlTWlycm9yLmtleU1hcC52aW0gPSB7XG4gICAgICBhdHRhY2g6IGF0dGFjaFZpbU1hcCxcbiAgICAgIGRldGFjaDogZGV0YWNoVmltTWFwLFxuICAgICAgY2FsbDogY21LZXlcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZXhpdEluc2VydE1vZGUoY20pIHtcbiAgICAgIHZhciB2aW0gPSBjbS5zdGF0ZS52aW07XG4gICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgIHZhciBpbnNlcnRNb2RlQ2hhbmdlUmVnaXN0ZXIgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIuZ2V0UmVnaXN0ZXIoJy4nKTtcbiAgICAgIHZhciBpc1BsYXlpbmcgPSBtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmc7XG4gICAgICB2YXIgbGFzdENoYW5nZSA9IG1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcztcbiAgICAgIGlmICghaXNQbGF5aW5nKSB7XG4gICAgICAgIGNtLm9mZignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgICAgICBDb2RlTWlycm9yLm9mZihjbS5nZXRJbnB1dEZpZWxkKCksICdrZXlkb3duJywgb25LZXlFdmVudFRhcmdldEtleURvd24pO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BsYXlpbmcgJiYgdmltLmluc2VydE1vZGVSZXBlYXQgPiAxKSB7XG4gICAgICAgIC8vIFBlcmZvcm0gaW5zZXJ0IG1vZGUgcmVwZWF0IGZvciBjb21tYW5kcyBsaWtlIDMsYSBhbmQgMyxvLlxuICAgICAgICByZXBlYXRMYXN0RWRpdChjbSwgdmltLCB2aW0uaW5zZXJ0TW9kZVJlcGVhdCAtIDEsXG4gICAgICAgICAgICB0cnVlIC8qKiByZXBlYXRGb3JJbnNlcnQgKi8pO1xuICAgICAgICB2aW0ubGFzdEVkaXRJbnB1dFN0YXRlLnJlcGVhdE92ZXJyaWRlID0gdmltLmluc2VydE1vZGVSZXBlYXQ7XG4gICAgICB9XG4gICAgICBkZWxldGUgdmltLmluc2VydE1vZGVSZXBlYXQ7XG4gICAgICB2aW0uaW5zZXJ0TW9kZSA9IGZhbHNlO1xuICAgICAgY20uc2V0Q3Vyc29yKGNtLmdldEN1cnNvcigpLmxpbmUsIGNtLmdldEN1cnNvcigpLmNoLTEpO1xuICAgICAgY20uc2V0T3B0aW9uKCdrZXlNYXAnLCAndmltJyk7XG4gICAgICBjbS5zZXRPcHRpb24oJ2Rpc2FibGVJbnB1dCcsIHRydWUpO1xuICAgICAgY20udG9nZ2xlT3ZlcndyaXRlKGZhbHNlKTsgLy8gZXhpdCByZXBsYWNlIG1vZGUgaWYgd2Ugd2VyZSBpbiBpdC5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgXCIuIHJlZ2lzdGVyIGJlZm9yZSBleGl0aW5nIGluc2VydCBtb2RlXG4gICAgICBpbnNlcnRNb2RlQ2hhbmdlUmVnaXN0ZXIuc2V0VGV4dChsYXN0Q2hhbmdlLmNoYW5nZXMuam9pbignJykpO1xuICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcIm5vcm1hbFwifSk7XG4gICAgICBpZiAobWFjcm9Nb2RlU3RhdGUuaXNSZWNvcmRpbmcpIHtcbiAgICAgICAgbG9nSW5zZXJ0TW9kZUNoYW5nZShtYWNyb01vZGVTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX21hcENvbW1hbmQoY29tbWFuZCkge1xuICAgICAgZGVmYXVsdEtleW1hcC51bnNoaWZ0KGNvbW1hbmQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcENvbW1hbmQoa2V5cywgdHlwZSwgbmFtZSwgYXJncywgZXh0cmEpIHtcbiAgICAgIHZhciBjb21tYW5kID0ge2tleXM6IGtleXMsIHR5cGU6IHR5cGV9O1xuICAgICAgY29tbWFuZFt0eXBlXSA9IG5hbWU7XG4gICAgICBjb21tYW5kW3R5cGUgKyBcIkFyZ3NcIl0gPSBhcmdzO1xuICAgICAgZm9yICh2YXIga2V5IGluIGV4dHJhKVxuICAgICAgICBjb21tYW5kW2tleV0gPSBleHRyYVtrZXldO1xuICAgICAgX21hcENvbW1hbmQoY29tbWFuZCk7XG4gICAgfVxuXG4gICAgLy8gVGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHdvLWNoYXJhY3RlciBFU0Mga2V5bWFwIHNob3VsZCBiZVxuICAgIC8vIGFkanVzdGVkIGFjY29yZGluZyB0byB5b3VyIHR5cGluZyBzcGVlZCB0byBwcmV2ZW50IGZhbHNlIHBvc2l0aXZlcy5cbiAgICBkZWZpbmVPcHRpb24oJ2luc2VydE1vZGVFc2NLZXlzVGltZW91dCcsIDIwMCwgJ251bWJlcicpO1xuXG4gICAgQ29kZU1pcnJvci5rZXlNYXBbJ3ZpbS1pbnNlcnQnXSA9IHtcbiAgICAgIC8vIFRPRE86IG92ZXJyaWRlIG5hdmlnYXRpb24ga2V5cyBzbyB0aGF0IEVzYyB3aWxsIGNhbmNlbCBhdXRvbWF0aWNcbiAgICAgIC8vIGluZGVudGF0aW9uIGZyb20gbywgTywgaV88Q1I+XG4gICAgICBmYWxsdGhyb3VnaDogWydkZWZhdWx0J10sXG4gICAgICBhdHRhY2g6IGF0dGFjaFZpbU1hcCxcbiAgICAgIGRldGFjaDogZGV0YWNoVmltTWFwLFxuICAgICAgY2FsbDogY21LZXlcbiAgICB9O1xuXG4gICAgQ29kZU1pcnJvci5rZXlNYXBbJ3ZpbS1yZXBsYWNlJ10gPSB7XG4gICAgICAnQmFja3NwYWNlJzogJ2dvQ2hhckxlZnQnLFxuICAgICAgZmFsbHRocm91Z2g6IFsndmltLWluc2VydCddLFxuICAgICAgYXR0YWNoOiBhdHRhY2hWaW1NYXAsXG4gICAgICBkZXRhY2g6IGRldGFjaFZpbU1hcCxcbiAgICAgIGNhbGw6IGNtS2V5XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVNYWNyb1JlZ2lzdGVyKGNtLCB2aW0sIG1hY3JvTW9kZVN0YXRlLCByZWdpc3Rlck5hbWUpIHtcbiAgICAgIHZhciByZWdpc3RlciA9IHZpbUdsb2JhbFN0YXRlLnJlZ2lzdGVyQ29udHJvbGxlci5nZXRSZWdpc3RlcihyZWdpc3Rlck5hbWUpO1xuICAgICAgaWYgKHJlZ2lzdGVyTmFtZSA9PSAnOicpIHtcbiAgICAgICAgLy8gUmVhZC1vbmx5IHJlZ2lzdGVyIGNvbnRhaW5pbmcgbGFzdCBFeCBjb21tYW5kLlxuICAgICAgICBpZiAocmVnaXN0ZXIua2V5QnVmZmVyWzBdKSB7XG4gICAgICAgICAgZXhDb21tYW5kRGlzcGF0Y2hlci5wcm9jZXNzQ29tbWFuZChjbSwgcmVnaXN0ZXIua2V5QnVmZmVyWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGtleUJ1ZmZlciA9IHJlZ2lzdGVyLmtleUJ1ZmZlcjtcbiAgICAgIHZhciBpbWMgPSAwO1xuICAgICAgbWFjcm9Nb2RlU3RhdGUuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgIG1hY3JvTW9kZVN0YXRlLnJlcGxheVNlYXJjaFF1ZXJpZXMgPSByZWdpc3Rlci5zZWFyY2hRdWVyaWVzLnNsaWNlKDApO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRleHQgPSBrZXlCdWZmZXJbaV07XG4gICAgICAgIHZhciBtYXRjaCwga2V5O1xuICAgICAgICB3aGlsZSAodGV4dCkge1xuICAgICAgICAgIC8vIFB1bGwgb2ZmIG9uZSBjb21tYW5kIGtleSwgd2hpY2ggaXMgZWl0aGVyIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgIC8vIG9yIGEgc3BlY2lhbCBzZXF1ZW5jZSB3cmFwcGVkIGluICc8JyBhbmQgJz4nLCBlLmcuICc8U3BhY2U+Jy5cbiAgICAgICAgICBtYXRjaCA9ICgvPFxcdystLis/Pnw8XFx3Kz58Li8pLmV4ZWModGV4dCk7XG4gICAgICAgICAga2V5ID0gbWF0Y2hbMF07XG4gICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKG1hdGNoLmluZGV4ICsga2V5Lmxlbmd0aCk7XG4gICAgICAgICAgQ29kZU1pcnJvci5WaW0uaGFuZGxlS2V5KGNtLCBrZXksICdtYWNybycpO1xuICAgICAgICAgIGlmICh2aW0uaW5zZXJ0TW9kZSkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSByZWdpc3Rlci5pbnNlcnRNb2RlQ2hhbmdlc1tpbWMrK10uY2hhbmdlcztcbiAgICAgICAgICAgIHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcy5jaGFuZ2VzID1cbiAgICAgICAgICAgICAgICBjaGFuZ2VzO1xuICAgICAgICAgICAgcmVwZWF0SW5zZXJ0TW9kZUNoYW5nZXMoY20sIGNoYW5nZXMsIDEpO1xuICAgICAgICAgICAgZXhpdEluc2VydE1vZGUoY20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWFjcm9Nb2RlU3RhdGUuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9nS2V5KG1hY3JvTW9kZVN0YXRlLCBrZXkpIHtcbiAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgcmVnaXN0ZXJOYW1lID0gbWFjcm9Nb2RlU3RhdGUubGF0ZXN0UmVnaXN0ZXI7XG4gICAgICB2YXIgcmVnaXN0ZXIgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIuZ2V0UmVnaXN0ZXIocmVnaXN0ZXJOYW1lKTtcbiAgICAgIGlmIChyZWdpc3Rlcikge1xuICAgICAgICByZWdpc3Rlci5wdXNoVGV4dChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvZ0luc2VydE1vZGVDaGFuZ2UobWFjcm9Nb2RlU3RhdGUpIHtcbiAgICAgIGlmIChtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHsgcmV0dXJuOyB9XG4gICAgICB2YXIgcmVnaXN0ZXJOYW1lID0gbWFjcm9Nb2RlU3RhdGUubGF0ZXN0UmVnaXN0ZXI7XG4gICAgICB2YXIgcmVnaXN0ZXIgPSB2aW1HbG9iYWxTdGF0ZS5yZWdpc3RlckNvbnRyb2xsZXIuZ2V0UmVnaXN0ZXIocmVnaXN0ZXJOYW1lKTtcbiAgICAgIGlmIChyZWdpc3RlciAmJiByZWdpc3Rlci5wdXNoSW5zZXJ0TW9kZUNoYW5nZXMpIHtcbiAgICAgICAgcmVnaXN0ZXIucHVzaEluc2VydE1vZGVDaGFuZ2VzKG1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9nU2VhcmNoUXVlcnkobWFjcm9Nb2RlU3RhdGUsIHF1ZXJ5KSB7XG4gICAgICBpZiAobWFjcm9Nb2RlU3RhdGUuaXNQbGF5aW5nKSB7IHJldHVybjsgfVxuICAgICAgdmFyIHJlZ2lzdGVyTmFtZSA9IG1hY3JvTW9kZVN0YXRlLmxhdGVzdFJlZ2lzdGVyO1xuICAgICAgdmFyIHJlZ2lzdGVyID0gdmltR2xvYmFsU3RhdGUucmVnaXN0ZXJDb250cm9sbGVyLmdldFJlZ2lzdGVyKHJlZ2lzdGVyTmFtZSk7XG4gICAgICBpZiAocmVnaXN0ZXIgJiYgcmVnaXN0ZXIucHVzaFNlYXJjaFF1ZXJ5KSB7XG4gICAgICAgIHJlZ2lzdGVyLnB1c2hTZWFyY2hRdWVyeShxdWVyeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdGVucyBmb3IgY2hhbmdlcyBtYWRlIGluIGluc2VydCBtb2RlLlxuICAgICAqIFNob3VsZCBvbmx5IGJlIGFjdGl2ZSBpbiBpbnNlcnQgbW9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShjbSwgY2hhbmdlT2JqKSB7XG4gICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgIHZhciBsYXN0Q2hhbmdlID0gbWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzO1xuICAgICAgaWYgKCFtYWNyb01vZGVTdGF0ZS5pc1BsYXlpbmcpIHtcbiAgICAgICAgd2hpbGUoY2hhbmdlT2JqKSB7XG4gICAgICAgICAgbGFzdENoYW5nZS5leHBlY3RDdXJzb3JBY3Rpdml0eUZvckNoYW5nZSA9IHRydWU7XG4gICAgICAgICAgaWYgKGxhc3RDaGFuZ2UuaWdub3JlQ291bnQgPiAxKSB7XG4gICAgICAgICAgICBsYXN0Q2hhbmdlLmlnbm9yZUNvdW50LS07XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFuZ2VPYmoub3JpZ2luID09ICcraW5wdXQnIHx8IGNoYW5nZU9iai5vcmlnaW4gPT0gJ3Bhc3RlJ1xuICAgICAgICAgICAgICB8fCBjaGFuZ2VPYmoub3JpZ2luID09PSB1bmRlZmluZWQgLyogb25seSBpbiB0ZXN0aW5nICovKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uQ291bnQgPSBjbS5saXN0U2VsZWN0aW9ucygpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Db3VudCA+IDEpXG4gICAgICAgICAgICAgIGxhc3RDaGFuZ2UuaWdub3JlQ291bnQgPSBzZWxlY3Rpb25Db3VudDtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gY2hhbmdlT2JqLnRleHQuam9pbignXFxuJyk7XG4gICAgICAgICAgICBpZiAobGFzdENoYW5nZS5tYXliZVJlc2V0KSB7XG4gICAgICAgICAgICAgIGxhc3RDaGFuZ2UuY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgICBsYXN0Q2hhbmdlLm1heWJlUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgIGlmIChjbS5zdGF0ZS5vdmVyd3JpdGUgJiYgIS9cXG4vLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICBsYXN0Q2hhbmdlLmNoYW5nZXMucHVzaChbdGV4dF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhc3RDaGFuZ2UuY2hhbmdlcy5wdXNoKHRleHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENoYW5nZSBvYmplY3RzIG1heSBiZSBjaGFpbmVkIHdpdGggbmV4dC5cbiAgICAgICAgICBjaGFuZ2VPYmogPSBjaGFuZ2VPYmoubmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogTGlzdGVucyBmb3IgYW55IGtpbmQgb2YgY3Vyc29yIGFjdGl2aXR5IG9uIENvZGVNaXJyb3IuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBvbkN1cnNvckFjdGl2aXR5KGNtKSB7XG4gICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgaWYgKHZpbS5pbnNlcnRNb2RlKSB7XG4gICAgICAgIC8vIFRyYWNraW5nIGN1cnNvciBhY3Rpdml0eSBpbiBpbnNlcnQgbW9kZSAoZm9yIG1hY3JvIHN1cHBvcnQpLlxuICAgICAgICB2YXIgbWFjcm9Nb2RlU3RhdGUgPSB2aW1HbG9iYWxTdGF0ZS5tYWNyb01vZGVTdGF0ZTtcbiAgICAgICAgaWYgKG1hY3JvTW9kZVN0YXRlLmlzUGxheWluZykgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIGxhc3RDaGFuZ2UgPSBtYWNyb01vZGVTdGF0ZS5sYXN0SW5zZXJ0TW9kZUNoYW5nZXM7XG4gICAgICAgIGlmIChsYXN0Q2hhbmdlLmV4cGVjdEN1cnNvckFjdGl2aXR5Rm9yQ2hhbmdlKSB7XG4gICAgICAgICAgbGFzdENoYW5nZS5leHBlY3RDdXJzb3JBY3Rpdml0eUZvckNoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEN1cnNvciBtb3ZlZCBvdXRzaWRlIHRoZSBjb250ZXh0IG9mIGFuIGVkaXQuIFJlc2V0IHRoZSBjaGFuZ2UuXG4gICAgICAgICAgbGFzdENoYW5nZS5tYXliZVJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghY20uY3VyT3AuaXNWaW1PcCkge1xuICAgICAgICBoYW5kbGVFeHRlcm5hbFNlbGVjdGlvbihjbSwgdmltKTtcbiAgICAgIH1cbiAgICAgIGlmICh2aW0udmlzdWFsTW9kZSkge1xuICAgICAgICB1cGRhdGVGYWtlQ3Vyc29yKGNtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogS2VlcHMgdHJhY2sgb2YgYSBmYWtlIGN1cnNvciB0byBzdXBwb3J0IHZpc3VhbCBtb2RlIGN1cnNvciBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVGYWtlQ3Vyc29yKGNtKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gJ2NtLWFuaW1hdGUtZmF0LWN1cnNvcic7XG4gICAgICB2YXIgdmltID0gY20uc3RhdGUudmltO1xuICAgICAgdmFyIGZyb20gPSBjbGlwQ3Vyc29yVG9Db250ZW50KGNtLCBjb3B5Q3Vyc29yKHZpbS5zZWwuaGVhZCkpO1xuICAgICAgdmFyIHRvID0gb2Zmc2V0Q3Vyc29yKGZyb20sIDAsIDEpO1xuICAgICAgY2xlYXJGYWtlQ3Vyc29yKHZpbSk7XG4gICAgICAvLyBJbiB2aXN1YWwgbW9kZSwgdGhlIGN1cnNvciBtYXkgYmUgcG9zaXRpb25lZCBvdmVyIEVPTC5cbiAgICAgIGlmIChmcm9tLmNoID09IGNtLmdldExpbmUoZnJvbS5saW5lKS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHdpZGdldCA9IGRvbSgnc3BhbicsIHsgJ2NsYXNzJzogY2xhc3NOYW1lIH0sICdcXHUwMGEwJyk7XG4gICAgICAgIHZpbS5mYWtlQ3Vyc29yQm9va21hcmsgPSBjbS5zZXRCb29rbWFyayhmcm9tLCB7d2lkZ2V0OiB3aWRnZXR9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpbS5mYWtlQ3Vyc29yID0gY20ubWFya1RleHQoZnJvbSwgdG8sIHtjbGFzc05hbWU6IGNsYXNzTmFtZX0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhckZha2VDdXJzb3IodmltKSB7XG4gICAgICBpZiAodmltLmZha2VDdXJzb3IpIHtcbiAgICAgICAgdmltLmZha2VDdXJzb3IuY2xlYXIoKTtcbiAgICAgICAgdmltLmZha2VDdXJzb3IgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHZpbS5mYWtlQ3Vyc29yQm9va21hcmspIHtcbiAgICAgICAgdmltLmZha2VDdXJzb3JCb29rbWFyay5jbGVhcigpO1xuICAgICAgICB2aW0uZmFrZUN1cnNvckJvb2ttYXJrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRXh0ZXJuYWxTZWxlY3Rpb24oY20sIHZpbSkge1xuICAgICAgdmFyIGFuY2hvciA9IGNtLmdldEN1cnNvcignYW5jaG9yJyk7XG4gICAgICB2YXIgaGVhZCA9IGNtLmdldEN1cnNvcignaGVhZCcpO1xuICAgICAgLy8gRW50ZXIgb3IgZXhpdCB2aXN1YWwgbW9kZSB0byBtYXRjaCBtb3VzZSBzZWxlY3Rpb24uXG4gICAgICBpZiAodmltLnZpc3VhbE1vZGUgJiYgIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgICAgZXhpdFZpc3VhbE1vZGUoY20sIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoIXZpbS52aXN1YWxNb2RlICYmICF2aW0uaW5zZXJ0TW9kZSAmJiBjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgIHZpbS52aXN1YWxNb2RlID0gdHJ1ZTtcbiAgICAgICAgdmltLnZpc3VhbExpbmUgPSBmYWxzZTtcbiAgICAgICAgQ29kZU1pcnJvci5zaWduYWwoY20sIFwidmltLW1vZGUtY2hhbmdlXCIsIHttb2RlOiBcInZpc3VhbFwifSk7XG4gICAgICB9XG4gICAgICBpZiAodmltLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgLy8gQmluZCBDb2RlTWlycm9yIHNlbGVjdGlvbiBtb2RlbCB0byB2aW0gc2VsZWN0aW9uIG1vZGVsLlxuICAgICAgICAvLyBNb3VzZSBzZWxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIHZpc3VhbCBjaGFyYWN0ZXJ3aXNlLlxuICAgICAgICB2YXIgaGVhZE9mZnNldCA9ICFjdXJzb3JJc0JlZm9yZShoZWFkLCBhbmNob3IpID8gLTEgOiAwO1xuICAgICAgICB2YXIgYW5jaG9yT2Zmc2V0ID0gY3Vyc29ySXNCZWZvcmUoaGVhZCwgYW5jaG9yKSA/IC0xIDogMDtcbiAgICAgICAgaGVhZCA9IG9mZnNldEN1cnNvcihoZWFkLCAwLCBoZWFkT2Zmc2V0KTtcbiAgICAgICAgYW5jaG9yID0gb2Zmc2V0Q3Vyc29yKGFuY2hvciwgMCwgYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgdmltLnNlbCA9IHtcbiAgICAgICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgICAgICBoZWFkOiBoZWFkXG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgJzwnLCBjdXJzb3JNaW4oaGVhZCwgYW5jaG9yKSk7XG4gICAgICAgIHVwZGF0ZU1hcmsoY20sIHZpbSwgJz4nLCBjdXJzb3JNYXgoaGVhZCwgYW5jaG9yKSk7XG4gICAgICB9IGVsc2UgaWYgKCF2aW0uaW5zZXJ0TW9kZSkge1xuICAgICAgICAvLyBSZXNldCBsYXN0SFBvcyBpZiBzZWxlY3Rpb24gd2FzIG1vZGlmaWVkIGJ5IHNvbWV0aGluZyBvdXRzaWRlIG9mIHZpbSBtb2RlIGUuZy4gYnkgbW91c2UuXG4gICAgICAgIHZpbS5sYXN0SFBvcyA9IGNtLmdldEN1cnNvcigpLmNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBXcmFwcGVyIGZvciBzcGVjaWFsIGtleXMgcHJlc3NlZCBpbiBpbnNlcnQgbW9kZSAqL1xuICAgIGZ1bmN0aW9uIEluc2VydE1vZGVLZXkoa2V5TmFtZSkge1xuICAgICAgdGhpcy5rZXlOYW1lID0ga2V5TmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEhhbmRsZXMgcmF3IGtleSBkb3duIGV2ZW50cyBmcm9tIHRoZSB0ZXh0IGFyZWEuXG4gICAgKiAtIFNob3VsZCBvbmx5IGJlIGFjdGl2ZSBpbiBpbnNlcnQgbW9kZS5cbiAgICAqIC0gRm9yIHJlY29yZGluZyBkZWxldGVzIGluIGluc2VydCBtb2RlLlxuICAgICovXG4gICAgZnVuY3Rpb24gb25LZXlFdmVudFRhcmdldEtleURvd24oZSkge1xuICAgICAgdmFyIG1hY3JvTW9kZVN0YXRlID0gdmltR2xvYmFsU3RhdGUubWFjcm9Nb2RlU3RhdGU7XG4gICAgICB2YXIgbGFzdENoYW5nZSA9IG1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcztcbiAgICAgIHZhciBrZXlOYW1lID0gQ29kZU1pcnJvci5rZXlOYW1lKGUpO1xuICAgICAgaWYgKCFrZXlOYW1lKSB7IHJldHVybjsgfVxuICAgICAgZnVuY3Rpb24gb25LZXlGb3VuZCgpIHtcbiAgICAgICAgaWYgKGxhc3RDaGFuZ2UubWF5YmVSZXNldCkge1xuICAgICAgICAgIGxhc3RDaGFuZ2UuY2hhbmdlcyA9IFtdO1xuICAgICAgICAgIGxhc3RDaGFuZ2UubWF5YmVSZXNldCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDaGFuZ2UuY2hhbmdlcy5wdXNoKG5ldyBJbnNlcnRNb2RlS2V5KGtleU5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5TmFtZS5pbmRleE9mKCdEZWxldGUnKSAhPSAtMSB8fCBrZXlOYW1lLmluZGV4T2YoJ0JhY2tzcGFjZScpICE9IC0xKSB7XG4gICAgICAgIENvZGVNaXJyb3IubG9va3VwS2V5KGtleU5hbWUsICd2aW0taW5zZXJ0Jywgb25LZXlGb3VuZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgbGFzdCBlZGl0LCB3aGljaCBpbmNsdWRlcyBleGFjdGx5IDEgY29tbWFuZCBhbmQgYXQgbW9zdCAxXG4gICAgICogaW5zZXJ0LiBPcGVyYXRvciBhbmQgbW90aW9uIGNvbW1hbmRzIGFyZSByZWFkIGZyb20gbGFzdEVkaXRJbnB1dFN0YXRlLFxuICAgICAqIHdoaWxlIGFjdGlvbiBjb21tYW5kcyBhcmUgcmVhZCBmcm9tIGxhc3RFZGl0QWN0aW9uQ29tbWFuZC5cbiAgICAgKlxuICAgICAqIElmIHJlcGVhdEZvckluc2VydCBpcyB0cnVlLCB0aGVuIHRoZSBmdW5jdGlvbiB3YXMgY2FsbGVkIGJ5XG4gICAgICogZXhpdEluc2VydE1vZGUgdG8gcmVwZWF0IHRoZSBpbnNlcnQgbW9kZSBjaGFuZ2VzIHRoZSB1c2VyIGp1c3QgbWFkZS4gVGhlXG4gICAgICogY29ycmVzcG9uZGluZyBlbnRlckluc2VydE1vZGUgY2FsbCB3YXMgbWFkZSB3aXRoIGEgY291bnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwZWF0TGFzdEVkaXQoY20sIHZpbSwgcmVwZWF0LCByZXBlYXRGb3JJbnNlcnQpIHtcbiAgICAgIHZhciBtYWNyb01vZGVTdGF0ZSA9IHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlO1xuICAgICAgbWFjcm9Nb2RlU3RhdGUuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpc0FjdGlvbiA9ICEhdmltLmxhc3RFZGl0QWN0aW9uQ29tbWFuZDtcbiAgICAgIHZhciBjYWNoZWRJbnB1dFN0YXRlID0gdmltLmlucHV0U3RhdGU7XG4gICAgICBmdW5jdGlvbiByZXBlYXRDb21tYW5kKCkge1xuICAgICAgICBpZiAoaXNBY3Rpb24pIHtcbiAgICAgICAgICBjb21tYW5kRGlzcGF0Y2hlci5wcm9jZXNzQWN0aW9uKGNtLCB2aW0sIHZpbS5sYXN0RWRpdEFjdGlvbkNvbW1hbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1hbmREaXNwYXRjaGVyLmV2YWxJbnB1dChjbSwgdmltKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVwZWF0SW5zZXJ0KHJlcGVhdCkge1xuICAgICAgICBpZiAobWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzLmNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgcmVwZWF0IGN3IGluIGRlc2t0b3AgVklNIGRvZXMgbm90IHJlcGVhdFxuICAgICAgICAgIC8vIGluc2VydCBtb2RlIGNoYW5nZXMuIFdpbGwgY29uZm9ybSB0byB0aGF0IGJlaGF2aW9yLlxuICAgICAgICAgIHJlcGVhdCA9ICF2aW0ubGFzdEVkaXRBY3Rpb25Db21tYW5kID8gMSA6IHJlcGVhdDtcbiAgICAgICAgICB2YXIgY2hhbmdlT2JqZWN0ID0gbWFjcm9Nb2RlU3RhdGUubGFzdEluc2VydE1vZGVDaGFuZ2VzO1xuICAgICAgICAgIHJlcGVhdEluc2VydE1vZGVDaGFuZ2VzKGNtLCBjaGFuZ2VPYmplY3QuY2hhbmdlcywgcmVwZWF0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmltLmlucHV0U3RhdGUgPSB2aW0ubGFzdEVkaXRJbnB1dFN0YXRlO1xuICAgICAgaWYgKGlzQWN0aW9uICYmIHZpbS5sYXN0RWRpdEFjdGlvbkNvbW1hbmQuaW50ZXJsYWNlSW5zZXJ0UmVwZWF0KSB7XG4gICAgICAgIC8vIG8gYW5kIE8gcmVwZWF0IGhhdmUgdG8gYmUgaW50ZXJsYWNlZCB3aXRoIGluc2VydCByZXBlYXRzIHNvIHRoYXQgdGhlXG4gICAgICAgIC8vIGluc2VydGlvbnMgYXBwZWFyIG9uIHNlcGFyYXRlIGxpbmVzIGluc3RlYWQgb2YgdGhlIGxhc3QgbGluZS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBlYXQ7IGkrKykge1xuICAgICAgICAgIHJlcGVhdENvbW1hbmQoKTtcbiAgICAgICAgICByZXBlYXRJbnNlcnQoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghcmVwZWF0Rm9ySW5zZXJ0KSB7XG4gICAgICAgICAgLy8gSGFjayB0byBnZXQgdGhlIGN1cnNvciB0byBlbmQgdXAgYXQgdGhlIHJpZ2h0IHBsYWNlLiBJZiBJIGlzXG4gICAgICAgICAgLy8gcmVwZWF0ZWQgaW4gaW5zZXJ0IG1vZGUgcmVwZWF0LCBjdXJzb3Igd2lsbCBiZSAxIGluc2VydFxuICAgICAgICAgIC8vIGNoYW5nZSBzZXQgbGVmdCBvZiB3aGVyZSBpdCBzaG91bGQgYmUuXG4gICAgICAgICAgcmVwZWF0Q29tbWFuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGVhdEluc2VydChyZXBlYXQpO1xuICAgICAgfVxuICAgICAgdmltLmlucHV0U3RhdGUgPSBjYWNoZWRJbnB1dFN0YXRlO1xuICAgICAgaWYgKHZpbS5pbnNlcnRNb2RlICYmICFyZXBlYXRGb3JJbnNlcnQpIHtcbiAgICAgICAgLy8gRG9uJ3QgZXhpdCBpbnNlcnQgbW9kZSB0d2ljZS4gSWYgcmVwZWF0Rm9ySW5zZXJ0IGlzIHNldCwgdGhlbiB3ZVxuICAgICAgICAvLyB3ZXJlIGNhbGxlZCBieSBhbiBleGl0SW5zZXJ0TW9kZSBjYWxsIGxvd2VyIG9uIHRoZSBzdGFjay5cbiAgICAgICAgZXhpdEluc2VydE1vZGUoY20pO1xuICAgICAgfVxuICAgICAgbWFjcm9Nb2RlU3RhdGUuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwZWF0SW5zZXJ0TW9kZUNoYW5nZXMoY20sIGNoYW5nZXMsIHJlcGVhdCkge1xuICAgICAgZnVuY3Rpb24ga2V5SGFuZGxlcihiaW5kaW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYmluZGluZyA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIENvZGVNaXJyb3IuY29tbWFuZHNbYmluZGluZ10oY20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJpbmRpbmcoY20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGhlYWQgPSBjbS5nZXRDdXJzb3IoJ2hlYWQnKTtcbiAgICAgIHZhciB2aXN1YWxCbG9jayA9IHZpbUdsb2JhbFN0YXRlLm1hY3JvTW9kZVN0YXRlLmxhc3RJbnNlcnRNb2RlQ2hhbmdlcy52aXN1YWxCbG9jaztcbiAgICAgIGlmICh2aXN1YWxCbG9jaykge1xuICAgICAgICAvLyBTZXQgdXAgYmxvY2sgc2VsZWN0aW9uIGFnYWluIGZvciByZXBlYXRpbmcgdGhlIGNoYW5nZXMuXG4gICAgICAgIHNlbGVjdEZvckluc2VydChjbSwgaGVhZCwgdmlzdWFsQmxvY2sgKyAxKTtcbiAgICAgICAgcmVwZWF0ID0gY20ubGlzdFNlbGVjdGlvbnMoKS5sZW5ndGg7XG4gICAgICAgIGNtLnNldEN1cnNvcihoZWFkKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwZWF0OyBpKyspIHtcbiAgICAgICAgaWYgKHZpc3VhbEJsb2NrKSB7XG4gICAgICAgICAgY20uc2V0Q3Vyc29yKG9mZnNldEN1cnNvcihoZWFkLCBpLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFuZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbal07XG4gICAgICAgICAgaWYgKGNoYW5nZSBpbnN0YW5jZW9mIEluc2VydE1vZGVLZXkpIHtcbiAgICAgICAgICAgIENvZGVNaXJyb3IubG9va3VwS2V5KGNoYW5nZS5rZXlOYW1lLCAndmltLWluc2VydCcsIGtleUhhbmRsZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoYW5nZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoY2hhbmdlLCBjdXIsIGN1cik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IG9mZnNldEN1cnNvcihzdGFydCwgMCwgY2hhbmdlWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoY2hhbmdlWzBdLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2aXN1YWxCbG9jaykge1xuICAgICAgICBjbS5zZXRDdXJzb3Iob2Zmc2V0Q3Vyc29yKGhlYWQsIDAsIDEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldFZpbUdsb2JhbFN0YXRlKCk7XG4gICAgcmV0dXJuIHZpbUFwaTtcbiAgfTtcbiAgLy8gSW5pdGlhbGl6ZSBWaW0gYW5kIG1ha2UgaXQgYXZhaWxhYmxlIGFzIGFuIEFQSS5cbiAgQ29kZU1pcnJvci5WaW0gPSBWaW0oKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==