(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_typestyle_lib_es2015_index_js"],{

/***/ "./node_modules/typestyle/lib.es2015/index.js":
/*!****************************************************!*\
  !*** ./node_modules/typestyle/lib.es2015/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypeStyle": () => (/* reexport safe */ _internal_typestyle__WEBPACK_IMPORTED_MODULE_0__.TypeStyle),
/* harmony export */   "types": () => (/* reexport module object */ _types__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   "extend": () => (/* reexport safe */ _internal_utilities__WEBPACK_IMPORTED_MODULE_2__.extend),
/* harmony export */   "classes": () => (/* reexport safe */ _internal_utilities__WEBPACK_IMPORTED_MODULE_2__.classes),
/* harmony export */   "media": () => (/* reexport safe */ _internal_utilities__WEBPACK_IMPORTED_MODULE_2__.media),
/* harmony export */   "setStylesTarget": () => (/* binding */ setStylesTarget),
/* harmony export */   "cssRaw": () => (/* binding */ cssRaw),
/* harmony export */   "cssRule": () => (/* binding */ cssRule),
/* harmony export */   "forceRenderStyles": () => (/* binding */ forceRenderStyles),
/* harmony export */   "fontFace": () => (/* binding */ fontFace),
/* harmony export */   "getStyles": () => (/* binding */ getStyles),
/* harmony export */   "keyframes": () => (/* binding */ keyframes),
/* harmony export */   "reinit": () => (/* binding */ reinit),
/* harmony export */   "style": () => (/* binding */ style),
/* harmony export */   "stylesheet": () => (/* binding */ stylesheet),
/* harmony export */   "createTypeStyle": () => (/* binding */ createTypeStyle)
/* harmony export */ });
/* harmony import */ var _internal_typestyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/typestyle */ "./node_modules/typestyle/lib.es2015/internal/typestyle.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/typestyle/lib.es2015/types.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _internal_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/utilities */ "./node_modules/typestyle/lib.es2015/internal/utilities.js");


/**
 * All the CSS types in the 'types' namespace
 */


/**
 * Export certain utilities
 */

/** Zero configuration, default instance of TypeStyle */
var ts = new _internal_typestyle__WEBPACK_IMPORTED_MODULE_0__.TypeStyle({ autoGenerateTag: true });
/** Sets the target tag where we write the css on style updates */
var setStylesTarget = ts.setStylesTarget;
/**
 * Insert `raw` CSS as a string. This is useful for e.g.
 * - third party CSS that you are customizing with template strings
 * - generating raw CSS in JavaScript
 * - reset libraries like normalize.css that you can use without loaders
 */
var cssRaw = ts.cssRaw;
/**
 * Takes CSSProperties and registers it to a global selector (body, html, etc.)
 */
var cssRule = ts.cssRule;
/**
 * Renders styles to the singleton tag imediately
 * NOTE: You should only call it on initial render to prevent any non CSS flash.
 * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.
 **/
var forceRenderStyles = ts.forceRenderStyles;
/**
 * Utility function to register an @font-face
 */
var fontFace = ts.fontFace;
/**
 * Allows use to use the stylesheet in a node.js environment
 */
var getStyles = ts.getStyles;
/**
 * Takes keyframes and returns a generated animationName
 */
var keyframes = ts.keyframes;
/**
 * Helps with testing. Reinitializes FreeStyle + raw
 */
var reinit = ts.reinit;
/**
 * Takes CSSProperties and return a generated className you can use on your component
 */
var style = ts.style;
/**
 * Takes an object where property names are ideal class names and property values are CSSProperties, and
 * returns an object where property names are the same ideal class names and the property values are
 * the actual generated class names using the ideal class name as the $debugName
 */
var stylesheet = ts.stylesheet;
/**
 * Creates a new instance of TypeStyle separate from the default instance.
 *
 * - Use this for creating a different typestyle instance for a shadow dom component.
 * - Use this if you don't want an auto tag generated and you just want to collect the CSS.
 *
 * NOTE: styles aren't shared between different instances.
 */
function createTypeStyle(target) {
    var instance = new _internal_typestyle__WEBPACK_IMPORTED_MODULE_0__.TypeStyle({ autoGenerateTag: false });
    if (target) {
        instance.setStylesTarget(target);
    }
    return instance;
}


/***/ }),

/***/ "./node_modules/typestyle/lib.es2015/internal/formatting.js":
/*!******************************************************************!*\
  !*** ./node_modules/typestyle/lib.es2015/internal/formatting.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertToStyles": () => (/* binding */ convertToStyles),
/* harmony export */   "convertToKeyframes": () => (/* binding */ convertToKeyframes)
/* harmony export */ });
/**
 * We need to do the following to *our* objects before passing to freestyle:
 * - For any `$nest` directive move up to FreeStyle style nesting
 * - For any `$unique` directive map to FreeStyle Unique
 * - For any `$debugName` directive return the debug name
 */
function convertToStyles(object) {
    /** The final result we will return */
    var styles = {};
    for (var key in object) {
        /** Grab the value upfront */
        var val = object[key];
        /** TypeStyle configuration options */
        if (key === '$nest') {
            var nested = val;
            for (var selector in nested) {
                var subproperties = nested[selector];
                styles[selector] = convertToStyles(subproperties);
            }
        }
        else if (key === '$debugName') {
            styles.$displayName = val;
        }
        else {
            styles[key] = val;
        }
    }
    return styles;
}
// todo: better name here
function convertToKeyframes(frames) {
    var result = {};
    for (var offset in frames) {
        if (offset !== '$debugName') {
            result[offset] = frames[offset];
        }
    }
    if (frames.$debugName) {
        result.$displayName = frames.$debugName;
    }
    return result;
}


/***/ }),

/***/ "./node_modules/typestyle/lib.es2015/internal/typestyle.js":
/*!*****************************************************************!*\
  !*** ./node_modules/typestyle/lib.es2015/internal/typestyle.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypeStyle": () => (/* binding */ TypeStyle)
/* harmony export */ });
/* harmony import */ var free_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! free-style */ "./node_modules/free-style/dist.es2015/index.js");
/* harmony import */ var _formatting__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatting */ "./node_modules/typestyle/lib.es2015/internal/formatting.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities */ "./node_modules/typestyle/lib.es2015/internal/utilities.js");



/**
 * Creates an instance of free style with our options
 */
var createFreeStyle = function () { return free_style__WEBPACK_IMPORTED_MODULE_2__.create(); };
/**
 * Maintains a single stylesheet and keeps it in sync with requested styles
 */
var TypeStyle = /** @class */ (function () {
    function TypeStyle(_a) {
        var _this = this;
        var autoGenerateTag = _a.autoGenerateTag;
        /**
         * Insert `raw` CSS as a string. This is useful for e.g.
         * - third party CSS that you are customizing with template strings
         * - generating raw CSS in JavaScript
         * - reset libraries like normalize.css that you can use without loaders
         */
        this.cssRaw = function (mustBeValidCSS) {
            if (!mustBeValidCSS) {
                return;
            }
            _this._raw += mustBeValidCSS || '';
            _this._pendingRawChange = true;
            _this._styleUpdated();
        };
        /**
         * Takes CSSProperties and registers it to a global selector (body, html, etc.)
         */
        this.cssRule = function (selector) {
            var objects = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                objects[_i - 1] = arguments[_i];
            }
            var styles = (0,_formatting__WEBPACK_IMPORTED_MODULE_0__.convertToStyles)(_utilities__WEBPACK_IMPORTED_MODULE_1__.extend.apply(void 0, objects));
            _this._freeStyle.registerRule(selector, styles);
            _this._styleUpdated();
            return;
        };
        /**
         * Renders styles to the singleton tag imediately
         * NOTE: You should only call it on initial render to prevent any non CSS flash.
         * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.
         **/
        this.forceRenderStyles = function () {
            var target = _this._getTag();
            if (!target) {
                return;
            }
            target.textContent = _this.getStyles();
        };
        /**
         * Utility function to register an @font-face
         */
        this.fontFace = function () {
            var fontFace = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                fontFace[_i] = arguments[_i];
            }
            var freeStyle = _this._freeStyle;
            for (var _a = 0, _b = fontFace; _a < _b.length; _a++) {
                var face = _b[_a];
                freeStyle.registerRule('@font-face', face);
            }
            _this._styleUpdated();
            return;
        };
        /**
         * Allows use to use the stylesheet in a node.js environment
         */
        this.getStyles = function () {
            return (_this._raw || '') + _this._freeStyle.getStyles();
        };
        /**
         * Takes keyframes and returns a generated animationName
         */
        this.keyframes = function (frames) {
            var keyframes = (0,_formatting__WEBPACK_IMPORTED_MODULE_0__.convertToKeyframes)(frames);
            // TODO: replace $debugName with display name
            var animationName = _this._freeStyle.registerKeyframes(keyframes);
            _this._styleUpdated();
            return animationName;
        };
        /**
         * Helps with testing. Reinitializes FreeStyle + raw
         */
        this.reinit = function () {
            /** reinit freestyle */
            var freeStyle = createFreeStyle();
            _this._freeStyle = freeStyle;
            _this._lastFreeStyleChangeId = freeStyle.changeId;
            /** reinit raw */
            _this._raw = '';
            _this._pendingRawChange = false;
            /** Clear any styles that were flushed */
            var target = _this._getTag();
            if (target) {
                target.textContent = '';
            }
        };
        /** Sets the target tag where we write the css on style updates */
        this.setStylesTarget = function (tag) {
            /** Clear any data in any previous tag */
            if (_this._tag) {
                _this._tag.textContent = '';
            }
            _this._tag = tag;
            /** This special time buffer immediately */
            _this.forceRenderStyles();
        };
        /**
         * Takes an object where property names are ideal class names and property values are CSSProperties, and
         * returns an object where property names are the same ideal class names and the property values are
         * the actual generated class names using the ideal class name as the $debugName
         */
        this.stylesheet = function (classes) {
            var classNames = Object.getOwnPropertyNames(classes);
            var result = {};
            for (var _i = 0, classNames_1 = classNames; _i < classNames_1.length; _i++) {
                var className = classNames_1[_i];
                var classDef = classes[className];
                if (classDef) {
                    classDef.$debugName = className;
                    result[className] = _this.style(classDef);
                }
            }
            return result;
        };
        var freeStyle = createFreeStyle();
        this._autoGenerateTag = autoGenerateTag;
        this._freeStyle = freeStyle;
        this._lastFreeStyleChangeId = freeStyle.changeId;
        this._pending = 0;
        this._pendingRawChange = false;
        this._raw = '';
        this._tag = undefined;
        // rebind prototype to TypeStyle.  It might be better to do a function() { return this.style.apply(this, arguments)}
        this.style = this.style.bind(this);
    }
    /**
     * Only calls cb all sync operations settle
     */
    TypeStyle.prototype._afterAllSync = function (cb) {
        var _this = this;
        this._pending++;
        var pending = this._pending;
        (0,_utilities__WEBPACK_IMPORTED_MODULE_1__.raf)(function () {
            if (pending !== _this._pending) {
                return;
            }
            cb();
        });
    };
    TypeStyle.prototype._getTag = function () {
        if (this._tag) {
            return this._tag;
        }
        if (this._autoGenerateTag) {
            var tag = typeof window === 'undefined'
                ? { textContent: '' }
                : document.createElement('style');
            if (typeof document !== 'undefined') {
                document.head.appendChild(tag);
            }
            this._tag = tag;
            return tag;
        }
        return undefined;
    };
    /** Checks if the style tag needs updating and if so queues up the change */
    TypeStyle.prototype._styleUpdated = function () {
        var _this = this;
        var changeId = this._freeStyle.changeId;
        var lastChangeId = this._lastFreeStyleChangeId;
        if (!this._pendingRawChange && changeId === lastChangeId) {
            return;
        }
        this._lastFreeStyleChangeId = changeId;
        this._pendingRawChange = false;
        this._afterAllSync(function () { return _this.forceRenderStyles(); });
    };
    TypeStyle.prototype.style = function () {
        var className = this._freeStyle.registerStyle((0,_formatting__WEBPACK_IMPORTED_MODULE_0__.convertToStyles)(_utilities__WEBPACK_IMPORTED_MODULE_1__.extend.apply(undefined, arguments)));
        this._styleUpdated();
        return className;
    };
    return TypeStyle;
}());



/***/ }),

/***/ "./node_modules/typestyle/lib.es2015/internal/utilities.js":
/*!*****************************************************************!*\
  !*** ./node_modules/typestyle/lib.es2015/internal/utilities.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "raf": () => (/* binding */ raf),
/* harmony export */   "classes": () => (/* binding */ classes),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "media": () => (/* binding */ media)
/* harmony export */ });
/** Raf for node + browser */
var raf = typeof requestAnimationFrame === 'undefined'
    /**
     * Make sure setTimeout is always invoked with
     * `this` set to `window` or `global` automatically
     **/
    ? function (cb) { return setTimeout(cb); }
    /**
     * Make sure window.requestAnimationFrame is always invoked with `this` window
     * We might have raf without window in case of `raf/polyfill` (recommended by React)
     **/
    : typeof window === 'undefined'
        ? requestAnimationFrame
        : requestAnimationFrame.bind(window);
/**
 * Utility to join classes conditionally
 */
function classes() {
    var classes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        classes[_i] = arguments[_i];
    }
    return classes
        .map(function (c) { return c && typeof c === 'object' ? Object.keys(c).map(function (key) { return !!c[key] && key; }) : [c]; })
        .reduce(function (flattened, c) { return flattened.concat(c); }, [])
        .filter(function (c) { return !!c; })
        .join(' ');
}
/**
 * Merges various styles into a single style object.
 * Note: if two objects have the same property the last one wins
 */
function extend() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
    }
    /** The final result we will return */
    var result = {};
    for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {
        var object = objects_1[_a];
        if (object == null || object === false) {
            continue;
        }
        for (var key in object) {
            /** Falsy values except a explicit 0 is ignored */
            var val = object[key];
            if (!val && val !== 0) {
                continue;
            }
            /** if nested media or pseudo selector */
            if (key === '$nest' && val) {
                result[key] = result['$nest'] ? extend(result['$nest'], val) : val;
            }
            /** if freestyle sub key that needs merging. We come here due to our recursive calls */
            else if ((key.indexOf('&') !== -1 || key.indexOf('@media') === 0)) {
                result[key] = result[key] ? extend(result[key], val) : val;
            }
            else {
                result[key] = val;
            }
        }
    }
    return result;
}
/**
 * Utility to help customize styles with media queries. e.g.
 * ```
 * style(
 *  media({maxWidth:500}, {color:'red'})
 * )
 * ```
 */
var media = function (mediaQuery) {
    var _a;
    var objects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
    }
    var mediaQuerySections = [];
    if (mediaQuery.type)
        mediaQuerySections.push(mediaQuery.type);
    if (mediaQuery.orientation)
        mediaQuerySections.push("(orientation: " + mediaQuery.orientation + ")");
    if (mediaQuery.minWidth)
        mediaQuerySections.push("(min-width: " + mediaLength(mediaQuery.minWidth) + ")");
    if (mediaQuery.maxWidth)
        mediaQuerySections.push("(max-width: " + mediaLength(mediaQuery.maxWidth) + ")");
    if (mediaQuery.minHeight)
        mediaQuerySections.push("(min-height: " + mediaLength(mediaQuery.minHeight) + ")");
    if (mediaQuery.maxHeight)
        mediaQuerySections.push("(max-height: " + mediaLength(mediaQuery.maxHeight) + ")");
    var stringMediaQuery = "@media " + mediaQuerySections.join(' and ');
    var object = {
        $nest: (_a = {},
            _a[stringMediaQuery] = extend.apply(void 0, objects),
            _a)
    };
    return object;
};
var mediaLength = function (value) {
    return typeof value === 'string' ? value : value + "px";
};


/***/ }),

/***/ "./node_modules/typestyle/lib.es2015/types.js":
/*!****************************************************!*\
  !*** ./node_modules/typestyle/lib.es2015/types.js ***!
  \****************************************************/
/***/ (() => {



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdHlwZXN0eWxlL2xpYi5lczIwMTUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3R5cGVzdHlsZS9saWIuZXMyMDE1L2ludGVybmFsL2Zvcm1hdHRpbmcuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3R5cGVzdHlsZS9saWIuZXMyMDE1L2ludGVybmFsL3R5cGVzdHlsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdHlwZXN0eWxlL2xpYi5lczIwMTUvaW50ZXJuYWwvdXRpbGl0aWVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQzVCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNpQztBQUNoQjtBQUNqQjtBQUNBO0FBQ0E7QUFDOEQ7QUFDOUQ7QUFDQSxhQUFhLDBEQUFTLEVBQUUsd0JBQXdCO0FBQ2hEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1QiwwREFBUyxFQUFFLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWEsR0FBRyxZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6InZlbmRvcnMtbm9kZV9tb2R1bGVzX3R5cGVzdHlsZV9saWJfZXMyMDE1X2luZGV4X2pzLmRiZjM3YjQyNTdmNzUyNTYyMzk5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHlwZVN0eWxlIH0gZnJvbSAnLi9pbnRlcm5hbC90eXBlc3R5bGUnO1xuZXhwb3J0IHsgVHlwZVN0eWxlIH07XG4vKipcbiAqIEFsbCB0aGUgQ1NTIHR5cGVzIGluIHRoZSAndHlwZXMnIG5hbWVzcGFjZVxuICovXG5pbXBvcnQgKiBhcyB0eXBlcyBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCB7IHR5cGVzIH07XG4vKipcbiAqIEV4cG9ydCBjZXJ0YWluIHV0aWxpdGllc1xuICovXG5leHBvcnQgeyBleHRlbmQsIGNsYXNzZXMsIG1lZGlhIH0gZnJvbSAnLi9pbnRlcm5hbC91dGlsaXRpZXMnO1xuLyoqIFplcm8gY29uZmlndXJhdGlvbiwgZGVmYXVsdCBpbnN0YW5jZSBvZiBUeXBlU3R5bGUgKi9cbnZhciB0cyA9IG5ldyBUeXBlU3R5bGUoeyBhdXRvR2VuZXJhdGVUYWc6IHRydWUgfSk7XG4vKiogU2V0cyB0aGUgdGFyZ2V0IHRhZyB3aGVyZSB3ZSB3cml0ZSB0aGUgY3NzIG9uIHN0eWxlIHVwZGF0ZXMgKi9cbmV4cG9ydCB2YXIgc2V0U3R5bGVzVGFyZ2V0ID0gdHMuc2V0U3R5bGVzVGFyZ2V0O1xuLyoqXG4gKiBJbnNlcnQgYHJhd2AgQ1NTIGFzIGEgc3RyaW5nLiBUaGlzIGlzIHVzZWZ1bCBmb3IgZS5nLlxuICogLSB0aGlyZCBwYXJ0eSBDU1MgdGhhdCB5b3UgYXJlIGN1c3RvbWl6aW5nIHdpdGggdGVtcGxhdGUgc3RyaW5nc1xuICogLSBnZW5lcmF0aW5nIHJhdyBDU1MgaW4gSmF2YVNjcmlwdFxuICogLSByZXNldCBsaWJyYXJpZXMgbGlrZSBub3JtYWxpemUuY3NzIHRoYXQgeW91IGNhbiB1c2Ugd2l0aG91dCBsb2FkZXJzXG4gKi9cbmV4cG9ydCB2YXIgY3NzUmF3ID0gdHMuY3NzUmF3O1xuLyoqXG4gKiBUYWtlcyBDU1NQcm9wZXJ0aWVzIGFuZCByZWdpc3RlcnMgaXQgdG8gYSBnbG9iYWwgc2VsZWN0b3IgKGJvZHksIGh0bWwsIGV0Yy4pXG4gKi9cbmV4cG9ydCB2YXIgY3NzUnVsZSA9IHRzLmNzc1J1bGU7XG4vKipcbiAqIFJlbmRlcnMgc3R5bGVzIHRvIHRoZSBzaW5nbGV0b24gdGFnIGltZWRpYXRlbHlcbiAqIE5PVEU6IFlvdSBzaG91bGQgb25seSBjYWxsIGl0IG9uIGluaXRpYWwgcmVuZGVyIHRvIHByZXZlbnQgYW55IG5vbiBDU1MgZmxhc2guXG4gKiBBZnRlciB0aGF0IGl0IGlzIGtlcHQgc3luYyB1c2luZyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhbmQgd2UgaGF2ZW4ndCBub3RpY2VkIGFueSBiYWQgZmxhc2hlcy5cbiAqKi9cbmV4cG9ydCB2YXIgZm9yY2VSZW5kZXJTdHlsZXMgPSB0cy5mb3JjZVJlbmRlclN0eWxlcztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byByZWdpc3RlciBhbiBAZm9udC1mYWNlXG4gKi9cbmV4cG9ydCB2YXIgZm9udEZhY2UgPSB0cy5mb250RmFjZTtcbi8qKlxuICogQWxsb3dzIHVzZSB0byB1c2UgdGhlIHN0eWxlc2hlZXQgaW4gYSBub2RlLmpzIGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCB2YXIgZ2V0U3R5bGVzID0gdHMuZ2V0U3R5bGVzO1xuLyoqXG4gKiBUYWtlcyBrZXlmcmFtZXMgYW5kIHJldHVybnMgYSBnZW5lcmF0ZWQgYW5pbWF0aW9uTmFtZVxuICovXG5leHBvcnQgdmFyIGtleWZyYW1lcyA9IHRzLmtleWZyYW1lcztcbi8qKlxuICogSGVscHMgd2l0aCB0ZXN0aW5nLiBSZWluaXRpYWxpemVzIEZyZWVTdHlsZSArIHJhd1xuICovXG5leHBvcnQgdmFyIHJlaW5pdCA9IHRzLnJlaW5pdDtcbi8qKlxuICogVGFrZXMgQ1NTUHJvcGVydGllcyBhbmQgcmV0dXJuIGEgZ2VuZXJhdGVkIGNsYXNzTmFtZSB5b3UgY2FuIHVzZSBvbiB5b3VyIGNvbXBvbmVudFxuICovXG5leHBvcnQgdmFyIHN0eWxlID0gdHMuc3R5bGU7XG4vKipcbiAqIFRha2VzIGFuIG9iamVjdCB3aGVyZSBwcm9wZXJ0eSBuYW1lcyBhcmUgaWRlYWwgY2xhc3MgbmFtZXMgYW5kIHByb3BlcnR5IHZhbHVlcyBhcmUgQ1NTUHJvcGVydGllcywgYW5kXG4gKiByZXR1cm5zIGFuIG9iamVjdCB3aGVyZSBwcm9wZXJ0eSBuYW1lcyBhcmUgdGhlIHNhbWUgaWRlYWwgY2xhc3MgbmFtZXMgYW5kIHRoZSBwcm9wZXJ0eSB2YWx1ZXMgYXJlXG4gKiB0aGUgYWN0dWFsIGdlbmVyYXRlZCBjbGFzcyBuYW1lcyB1c2luZyB0aGUgaWRlYWwgY2xhc3MgbmFtZSBhcyB0aGUgJGRlYnVnTmFtZVxuICovXG5leHBvcnQgdmFyIHN0eWxlc2hlZXQgPSB0cy5zdHlsZXNoZWV0O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFR5cGVTdHlsZSBzZXBhcmF0ZSBmcm9tIHRoZSBkZWZhdWx0IGluc3RhbmNlLlxuICpcbiAqIC0gVXNlIHRoaXMgZm9yIGNyZWF0aW5nIGEgZGlmZmVyZW50IHR5cGVzdHlsZSBpbnN0YW5jZSBmb3IgYSBzaGFkb3cgZG9tIGNvbXBvbmVudC5cbiAqIC0gVXNlIHRoaXMgaWYgeW91IGRvbid0IHdhbnQgYW4gYXV0byB0YWcgZ2VuZXJhdGVkIGFuZCB5b3UganVzdCB3YW50IHRvIGNvbGxlY3QgdGhlIENTUy5cbiAqXG4gKiBOT1RFOiBzdHlsZXMgYXJlbid0IHNoYXJlZCBiZXR3ZWVuIGRpZmZlcmVudCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUeXBlU3R5bGUodGFyZ2V0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IFR5cGVTdHlsZSh7IGF1dG9HZW5lcmF0ZVRhZzogZmFsc2UgfSk7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRTdHlsZXNUYXJnZXQodGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuIiwiLyoqXG4gKiBXZSBuZWVkIHRvIGRvIHRoZSBmb2xsb3dpbmcgdG8gKm91ciogb2JqZWN0cyBiZWZvcmUgcGFzc2luZyB0byBmcmVlc3R5bGU6XG4gKiAtIEZvciBhbnkgYCRuZXN0YCBkaXJlY3RpdmUgbW92ZSB1cCB0byBGcmVlU3R5bGUgc3R5bGUgbmVzdGluZ1xuICogLSBGb3IgYW55IGAkdW5pcXVlYCBkaXJlY3RpdmUgbWFwIHRvIEZyZWVTdHlsZSBVbmlxdWVcbiAqIC0gRm9yIGFueSBgJGRlYnVnTmFtZWAgZGlyZWN0aXZlIHJldHVybiB0aGUgZGVidWcgbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvU3R5bGVzKG9iamVjdCkge1xuICAgIC8qKiBUaGUgZmluYWwgcmVzdWx0IHdlIHdpbGwgcmV0dXJuICovXG4gICAgdmFyIHN0eWxlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgLyoqIEdyYWIgdGhlIHZhbHVlIHVwZnJvbnQgKi9cbiAgICAgICAgdmFyIHZhbCA9IG9iamVjdFtrZXldO1xuICAgICAgICAvKiogVHlwZVN0eWxlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAqL1xuICAgICAgICBpZiAoa2V5ID09PSAnJG5lc3QnKSB7XG4gICAgICAgICAgICB2YXIgbmVzdGVkID0gdmFsO1xuICAgICAgICAgICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gbmVzdGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnByb3BlcnRpZXMgPSBuZXN0ZWRbc2VsZWN0b3JdO1xuICAgICAgICAgICAgICAgIHN0eWxlc1tzZWxlY3Rvcl0gPSBjb252ZXJ0VG9TdHlsZXMoc3VicHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnJGRlYnVnTmFtZScpIHtcbiAgICAgICAgICAgIHN0eWxlcy4kZGlzcGxheU5hbWUgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXNba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xufVxuLy8gdG9kbzogYmV0dGVyIG5hbWUgaGVyZVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0tleWZyYW1lcyhmcmFtZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgb2Zmc2V0IGluIGZyYW1lcykge1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSAnJGRlYnVnTmFtZScpIHtcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXRdID0gZnJhbWVzW29mZnNldF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZyYW1lcy4kZGVidWdOYW1lKSB7XG4gICAgICAgIHJlc3VsdC4kZGlzcGxheU5hbWUgPSBmcmFtZXMuJGRlYnVnTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCAqIGFzIEZyZWVTdHlsZSBmcm9tIFwiZnJlZS1zdHlsZVwiO1xuaW1wb3J0IHsgY29udmVydFRvU3R5bGVzLCBjb252ZXJ0VG9LZXlmcmFtZXMgfSBmcm9tICcuL2Zvcm1hdHRpbmcnO1xuaW1wb3J0IHsgZXh0ZW5kLCByYWYgfSBmcm9tICcuL3V0aWxpdGllcyc7XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZnJlZSBzdHlsZSB3aXRoIG91ciBvcHRpb25zXG4gKi9cbnZhciBjcmVhdGVGcmVlU3R5bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBGcmVlU3R5bGUuY3JlYXRlKCk7IH07XG4vKipcbiAqIE1haW50YWlucyBhIHNpbmdsZSBzdHlsZXNoZWV0IGFuZCBrZWVwcyBpdCBpbiBzeW5jIHdpdGggcmVxdWVzdGVkIHN0eWxlc1xuICovXG52YXIgVHlwZVN0eWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVTdHlsZShfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXV0b0dlbmVyYXRlVGFnID0gX2EuYXV0b0dlbmVyYXRlVGFnO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IGByYXdgIENTUyBhcyBhIHN0cmluZy4gVGhpcyBpcyB1c2VmdWwgZm9yIGUuZy5cbiAgICAgICAgICogLSB0aGlyZCBwYXJ0eSBDU1MgdGhhdCB5b3UgYXJlIGN1c3RvbWl6aW5nIHdpdGggdGVtcGxhdGUgc3RyaW5nc1xuICAgICAgICAgKiAtIGdlbmVyYXRpbmcgcmF3IENTUyBpbiBKYXZhU2NyaXB0XG4gICAgICAgICAqIC0gcmVzZXQgbGlicmFyaWVzIGxpa2Ugbm9ybWFsaXplLmNzcyB0aGF0IHlvdSBjYW4gdXNlIHdpdGhvdXQgbG9hZGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jc3NSYXcgPSBmdW5jdGlvbiAobXVzdEJlVmFsaWRDU1MpIHtcbiAgICAgICAgICAgIGlmICghbXVzdEJlVmFsaWRDU1MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fcmF3ICs9IG11c3RCZVZhbGlkQ1NTIHx8ICcnO1xuICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdSYXdDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX3N0eWxlVXBkYXRlZCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgQ1NTUHJvcGVydGllcyBhbmQgcmVnaXN0ZXJzIGl0IHRvIGEgZ2xvYmFsIHNlbGVjdG9yIChib2R5LCBodG1sLCBldGMuKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jc3NSdWxlID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBvYmplY3RzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IGNvbnZlcnRUb1N0eWxlcyhleHRlbmQuYXBwbHkodm9pZCAwLCBvYmplY3RzKSk7XG4gICAgICAgICAgICBfdGhpcy5fZnJlZVN0eWxlLnJlZ2lzdGVyUnVsZShzZWxlY3Rvciwgc3R5bGVzKTtcbiAgICAgICAgICAgIF90aGlzLl9zdHlsZVVwZGF0ZWQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlcnMgc3R5bGVzIHRvIHRoZSBzaW5nbGV0b24gdGFnIGltZWRpYXRlbHlcbiAgICAgICAgICogTk9URTogWW91IHNob3VsZCBvbmx5IGNhbGwgaXQgb24gaW5pdGlhbCByZW5kZXIgdG8gcHJldmVudCBhbnkgbm9uIENTUyBmbGFzaC5cbiAgICAgICAgICogQWZ0ZXIgdGhhdCBpdCBpcyBrZXB0IHN5bmMgdXNpbmcgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYW5kIHdlIGhhdmVuJ3Qgbm90aWNlZCBhbnkgYmFkIGZsYXNoZXMuXG4gICAgICAgICAqKi9cbiAgICAgICAgdGhpcy5mb3JjZVJlbmRlclN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfdGhpcy5fZ2V0VGFnKCk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC50ZXh0Q29udGVudCA9IF90aGlzLmdldFN0eWxlcygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXRpbGl0eSBmdW5jdGlvbiB0byByZWdpc3RlciBhbiBAZm9udC1mYWNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvbnRGYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZvbnRGYWNlID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGZvbnRGYWNlW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnJlZVN0eWxlID0gX3RoaXMuX2ZyZWVTdHlsZTtcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSBmb250RmFjZTsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZmFjZSA9IF9iW19hXTtcbiAgICAgICAgICAgICAgICBmcmVlU3R5bGUucmVnaXN0ZXJSdWxlKCdAZm9udC1mYWNlJywgZmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fc3R5bGVVcGRhdGVkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgdXNlIHRvIHVzZSB0aGUgc3R5bGVzaGVldCBpbiBhIG5vZGUuanMgZW52aXJvbm1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0U3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5fcmF3IHx8ICcnKSArIF90aGlzLl9mcmVlU3R5bGUuZ2V0U3R5bGVzKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBrZXlmcmFtZXMgYW5kIHJldHVybnMgYSBnZW5lcmF0ZWQgYW5pbWF0aW9uTmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZXlmcmFtZXMgPSBmdW5jdGlvbiAoZnJhbWVzKSB7XG4gICAgICAgICAgICB2YXIga2V5ZnJhbWVzID0gY29udmVydFRvS2V5ZnJhbWVzKGZyYW1lcyk7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlICRkZWJ1Z05hbWUgd2l0aCBkaXNwbGF5IG5hbWVcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25OYW1lID0gX3RoaXMuX2ZyZWVTdHlsZS5yZWdpc3RlcktleWZyYW1lcyhrZXlmcmFtZXMpO1xuICAgICAgICAgICAgX3RoaXMuX3N0eWxlVXBkYXRlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbk5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwcyB3aXRoIHRlc3RpbmcuIFJlaW5pdGlhbGl6ZXMgRnJlZVN0eWxlICsgcmF3XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8qKiByZWluaXQgZnJlZXN0eWxlICovXG4gICAgICAgICAgICB2YXIgZnJlZVN0eWxlID0gY3JlYXRlRnJlZVN0eWxlKCk7XG4gICAgICAgICAgICBfdGhpcy5fZnJlZVN0eWxlID0gZnJlZVN0eWxlO1xuICAgICAgICAgICAgX3RoaXMuX2xhc3RGcmVlU3R5bGVDaGFuZ2VJZCA9IGZyZWVTdHlsZS5jaGFuZ2VJZDtcbiAgICAgICAgICAgIC8qKiByZWluaXQgcmF3ICovXG4gICAgICAgICAgICBfdGhpcy5fcmF3ID0gJyc7XG4gICAgICAgICAgICBfdGhpcy5fcGVuZGluZ1Jhd0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqIENsZWFyIGFueSBzdHlsZXMgdGhhdCB3ZXJlIGZsdXNoZWQgKi9cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfdGhpcy5fZ2V0VGFnKCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBTZXRzIHRoZSB0YXJnZXQgdGFnIHdoZXJlIHdlIHdyaXRlIHRoZSBjc3Mgb24gc3R5bGUgdXBkYXRlcyAqL1xuICAgICAgICB0aGlzLnNldFN0eWxlc1RhcmdldCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgIC8qKiBDbGVhciBhbnkgZGF0YSBpbiBhbnkgcHJldmlvdXMgdGFnICovXG4gICAgICAgICAgICBpZiAoX3RoaXMuX3RhZykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YWcudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl90YWcgPSB0YWc7XG4gICAgICAgICAgICAvKiogVGhpcyBzcGVjaWFsIHRpbWUgYnVmZmVyIGltbWVkaWF0ZWx5ICovXG4gICAgICAgICAgICBfdGhpcy5mb3JjZVJlbmRlclN0eWxlcygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYW4gb2JqZWN0IHdoZXJlIHByb3BlcnR5IG5hbWVzIGFyZSBpZGVhbCBjbGFzcyBuYW1lcyBhbmQgcHJvcGVydHkgdmFsdWVzIGFyZSBDU1NQcm9wZXJ0aWVzLCBhbmRcbiAgICAgICAgICogcmV0dXJucyBhbiBvYmplY3Qgd2hlcmUgcHJvcGVydHkgbmFtZXMgYXJlIHRoZSBzYW1lIGlkZWFsIGNsYXNzIG5hbWVzIGFuZCB0aGUgcHJvcGVydHkgdmFsdWVzIGFyZVxuICAgICAgICAgKiB0aGUgYWN0dWFsIGdlbmVyYXRlZCBjbGFzcyBuYW1lcyB1c2luZyB0aGUgaWRlYWwgY2xhc3MgbmFtZSBhcyB0aGUgJGRlYnVnTmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHlsZXNoZWV0ID0gZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2xhc3Nlcyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNsYXNzTmFtZXNfMSA9IGNsYXNzTmFtZXM7IF9pIDwgY2xhc3NOYW1lc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzXzFbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc0RlZiA9IGNsYXNzZXNbY2xhc3NOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NEZWYuJGRlYnVnTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2NsYXNzTmFtZV0gPSBfdGhpcy5zdHlsZShjbGFzc0RlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZyZWVTdHlsZSA9IGNyZWF0ZUZyZWVTdHlsZSgpO1xuICAgICAgICB0aGlzLl9hdXRvR2VuZXJhdGVUYWcgPSBhdXRvR2VuZXJhdGVUYWc7XG4gICAgICAgIHRoaXMuX2ZyZWVTdHlsZSA9IGZyZWVTdHlsZTtcbiAgICAgICAgdGhpcy5fbGFzdEZyZWVTdHlsZUNoYW5nZUlkID0gZnJlZVN0eWxlLmNoYW5nZUlkO1xuICAgICAgICB0aGlzLl9wZW5kaW5nID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1Jhd0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yYXcgPSAnJztcbiAgICAgICAgdGhpcy5fdGFnID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyByZWJpbmQgcHJvdG90eXBlIHRvIFR5cGVTdHlsZS4gIEl0IG1pZ2h0IGJlIGJldHRlciB0byBkbyBhIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdHlsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpfVxuICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5zdHlsZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IGNhbGxzIGNiIGFsbCBzeW5jIG9wZXJhdGlvbnMgc2V0dGxlXG4gICAgICovXG4gICAgVHlwZVN0eWxlLnByb3RvdHlwZS5fYWZ0ZXJBbGxTeW5jID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3BlbmRpbmcrKztcbiAgICAgICAgdmFyIHBlbmRpbmcgPSB0aGlzLl9wZW5kaW5nO1xuICAgICAgICByYWYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcgIT09IF90aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUeXBlU3R5bGUucHJvdG90eXBlLl9nZXRUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90YWcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90YWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2F1dG9HZW5lcmF0ZVRhZykge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB7IHRleHRDb250ZW50OiAnJyB9XG4gICAgICAgICAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90YWcgPSB0YWc7XG4gICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKiogQ2hlY2tzIGlmIHRoZSBzdHlsZSB0YWcgbmVlZHMgdXBkYXRpbmcgYW5kIGlmIHNvIHF1ZXVlcyB1cCB0aGUgY2hhbmdlICovXG4gICAgVHlwZVN0eWxlLnByb3RvdHlwZS5fc3R5bGVVcGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hhbmdlSWQgPSB0aGlzLl9mcmVlU3R5bGUuY2hhbmdlSWQ7XG4gICAgICAgIHZhciBsYXN0Q2hhbmdlSWQgPSB0aGlzLl9sYXN0RnJlZVN0eWxlQ2hhbmdlSWQ7XG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZ1Jhd0NoYW5nZSAmJiBjaGFuZ2VJZCA9PT0gbGFzdENoYW5nZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdEZyZWVTdHlsZUNoYW5nZUlkID0gY2hhbmdlSWQ7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdSYXdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJBbGxTeW5jKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZvcmNlUmVuZGVyU3R5bGVzKCk7IH0pO1xuICAgIH07XG4gICAgVHlwZVN0eWxlLnByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuX2ZyZWVTdHlsZS5yZWdpc3RlclN0eWxlKGNvbnZlcnRUb1N0eWxlcyhleHRlbmQuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKSk7XG4gICAgICAgIHRoaXMuX3N0eWxlVXBkYXRlZCgpO1xuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIFR5cGVTdHlsZTtcbn0oKSk7XG5leHBvcnQgeyBUeXBlU3R5bGUgfTtcbiIsIi8qKiBSYWYgZm9yIG5vZGUgKyBicm93c2VyICovXG5leHBvcnQgdmFyIHJhZiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICd1bmRlZmluZWQnXG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHNldFRpbWVvdXQgaXMgYWx3YXlzIGludm9rZWQgd2l0aFxuICAgICAqIGB0aGlzYCBzZXQgdG8gYHdpbmRvd2Agb3IgYGdsb2JhbGAgYXV0b21hdGljYWxseVxuICAgICAqKi9cbiAgICA/IGZ1bmN0aW9uIChjYikgeyByZXR1cm4gc2V0VGltZW91dChjYik7IH1cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSBpcyBhbHdheXMgaW52b2tlZCB3aXRoIGB0aGlzYCB3aW5kb3dcbiAgICAgKiBXZSBtaWdodCBoYXZlIHJhZiB3aXRob3V0IHdpbmRvdyBpbiBjYXNlIG9mIGByYWYvcG9seWZpbGxgIChyZWNvbW1lbmRlZCBieSBSZWFjdClcbiAgICAgKiovXG4gICAgOiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICA6IHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyk7XG4vKipcbiAqIFV0aWxpdHkgdG8gam9pbiBjbGFzc2VzIGNvbmRpdGlvbmFsbHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjbGFzc2VzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBjbGFzc2VzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgJiYgdHlwZW9mIGMgPT09ICdvYmplY3QnID8gT2JqZWN0LmtleXMoYykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICEhY1trZXldICYmIGtleTsgfSkgOiBbY107IH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGZsYXR0ZW5lZCwgYykgeyByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChjKTsgfSwgW10pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICEhYzsgfSlcbiAgICAgICAgLmpvaW4oJyAnKTtcbn1cbi8qKlxuICogTWVyZ2VzIHZhcmlvdXMgc3R5bGVzIGludG8gYSBzaW5nbGUgc3R5bGUgb2JqZWN0LlxuICogTm90ZTogaWYgdHdvIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBwcm9wZXJ0eSB0aGUgbGFzdCBvbmUgd2luc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JqZWN0c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICAvKiogVGhlIGZpbmFsIHJlc3VsdCB3ZSB3aWxsIHJldHVybiAqL1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBfYSA9IDAsIG9iamVjdHNfMSA9IG9iamVjdHM7IF9hIDwgb2JqZWN0c18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0c18xW19hXTtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsIHx8IG9iamVjdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIC8qKiBGYWxzeSB2YWx1ZXMgZXhjZXB0IGEgZXhwbGljaXQgMCBpcyBpZ25vcmVkICovXG4gICAgICAgICAgICB2YXIgdmFsID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAoIXZhbCAmJiB2YWwgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKiBpZiBuZXN0ZWQgbWVkaWEgb3IgcHNldWRvIHNlbGVjdG9yICovXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnJG5lc3QnICYmIHZhbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcmVzdWx0WyckbmVzdCddID8gZXh0ZW5kKHJlc3VsdFsnJG5lc3QnXSwgdmFsKSA6IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKiBpZiBmcmVlc3R5bGUgc3ViIGtleSB0aGF0IG5lZWRzIG1lcmdpbmcuIFdlIGNvbWUgaGVyZSBkdWUgdG8gb3VyIHJlY3Vyc2l2ZSBjYWxscyAqL1xuICAgICAgICAgICAgZWxzZSBpZiAoKGtleS5pbmRleE9mKCcmJykgIT09IC0xIHx8IGtleS5pbmRleE9mKCdAbWVkaWEnKSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHJlc3VsdFtrZXldID8gZXh0ZW5kKHJlc3VsdFtrZXldLCB2YWwpIDogdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVXRpbGl0eSB0byBoZWxwIGN1c3RvbWl6ZSBzdHlsZXMgd2l0aCBtZWRpYSBxdWVyaWVzLiBlLmcuXG4gKiBgYGBcbiAqIHN0eWxlKFxuICogIG1lZGlhKHttYXhXaWR0aDo1MDB9LCB7Y29sb3I6J3JlZCd9KVxuICogKVxuICogYGBgXG4gKi9cbmV4cG9ydCB2YXIgbWVkaWEgPSBmdW5jdGlvbiAobWVkaWFRdWVyeSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9iamVjdHNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBtZWRpYVF1ZXJ5U2VjdGlvbnMgPSBbXTtcbiAgICBpZiAobWVkaWFRdWVyeS50eXBlKVxuICAgICAgICBtZWRpYVF1ZXJ5U2VjdGlvbnMucHVzaChtZWRpYVF1ZXJ5LnR5cGUpO1xuICAgIGlmIChtZWRpYVF1ZXJ5Lm9yaWVudGF0aW9uKVxuICAgICAgICBtZWRpYVF1ZXJ5U2VjdGlvbnMucHVzaChcIihvcmllbnRhdGlvbjogXCIgKyBtZWRpYVF1ZXJ5Lm9yaWVudGF0aW9uICsgXCIpXCIpO1xuICAgIGlmIChtZWRpYVF1ZXJ5Lm1pbldpZHRoKVxuICAgICAgICBtZWRpYVF1ZXJ5U2VjdGlvbnMucHVzaChcIihtaW4td2lkdGg6IFwiICsgbWVkaWFMZW5ndGgobWVkaWFRdWVyeS5taW5XaWR0aCkgKyBcIilcIik7XG4gICAgaWYgKG1lZGlhUXVlcnkubWF4V2lkdGgpXG4gICAgICAgIG1lZGlhUXVlcnlTZWN0aW9ucy5wdXNoKFwiKG1heC13aWR0aDogXCIgKyBtZWRpYUxlbmd0aChtZWRpYVF1ZXJ5Lm1heFdpZHRoKSArIFwiKVwiKTtcbiAgICBpZiAobWVkaWFRdWVyeS5taW5IZWlnaHQpXG4gICAgICAgIG1lZGlhUXVlcnlTZWN0aW9ucy5wdXNoKFwiKG1pbi1oZWlnaHQ6IFwiICsgbWVkaWFMZW5ndGgobWVkaWFRdWVyeS5taW5IZWlnaHQpICsgXCIpXCIpO1xuICAgIGlmIChtZWRpYVF1ZXJ5Lm1heEhlaWdodClcbiAgICAgICAgbWVkaWFRdWVyeVNlY3Rpb25zLnB1c2goXCIobWF4LWhlaWdodDogXCIgKyBtZWRpYUxlbmd0aChtZWRpYVF1ZXJ5Lm1heEhlaWdodCkgKyBcIilcIik7XG4gICAgdmFyIHN0cmluZ01lZGlhUXVlcnkgPSBcIkBtZWRpYSBcIiArIG1lZGlhUXVlcnlTZWN0aW9ucy5qb2luKCcgYW5kICcpO1xuICAgIHZhciBvYmplY3QgPSB7XG4gICAgICAgICRuZXN0OiAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW3N0cmluZ01lZGlhUXVlcnldID0gZXh0ZW5kLmFwcGx5KHZvaWQgMCwgb2JqZWN0cyksXG4gICAgICAgICAgICBfYSlcbiAgICB9O1xuICAgIHJldHVybiBvYmplY3Q7XG59O1xudmFyIG1lZGlhTGVuZ3RoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IHZhbHVlICsgXCJweFwiO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=