(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_vega-util_build_vega-util_module_js"],{

/***/ "./node_modules/vega-util/build/vega-util.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/vega-util/build/vega-util.module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Debug": () => (/* binding */ Debug),
/* harmony export */   "Error": () => (/* binding */ Error$1),
/* harmony export */   "Info": () => (/* binding */ Info),
/* harmony export */   "None": () => (/* binding */ None),
/* harmony export */   "Warn": () => (/* binding */ Warn),
/* harmony export */   "accessor": () => (/* binding */ accessor),
/* harmony export */   "accessorFields": () => (/* binding */ accessorFields),
/* harmony export */   "accessorName": () => (/* binding */ accessorName),
/* harmony export */   "array": () => (/* binding */ array),
/* harmony export */   "ascending": () => (/* binding */ ascending),
/* harmony export */   "clampRange": () => (/* binding */ clampRange),
/* harmony export */   "compare": () => (/* binding */ compare),
/* harmony export */   "constant": () => (/* binding */ constant),
/* harmony export */   "debounce": () => (/* binding */ debounce),
/* harmony export */   "error": () => (/* binding */ error),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "extent": () => (/* binding */ extent),
/* harmony export */   "extentIndex": () => (/* binding */ extentIndex),
/* harmony export */   "falsy": () => (/* binding */ falsy),
/* harmony export */   "fastmap": () => (/* binding */ fastmap),
/* harmony export */   "field": () => (/* binding */ field),
/* harmony export */   "flush": () => (/* binding */ flush),
/* harmony export */   "hasOwnProperty": () => (/* binding */ has),
/* harmony export */   "id": () => (/* binding */ id),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "inherits": () => (/* binding */ inherits),
/* harmony export */   "inrange": () => (/* binding */ inrange),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isIterable": () => (/* binding */ isIterable),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isRegExp": () => (/* binding */ isRegExp),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "key": () => (/* binding */ key),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "logger": () => (/* binding */ logger),
/* harmony export */   "lruCache": () => (/* binding */ lruCache),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "mergeConfig": () => (/* binding */ mergeConfig),
/* harmony export */   "one": () => (/* binding */ one),
/* harmony export */   "pad": () => (/* binding */ pad),
/* harmony export */   "panLinear": () => (/* binding */ panLinear),
/* harmony export */   "panLog": () => (/* binding */ panLog),
/* harmony export */   "panPow": () => (/* binding */ panPow),
/* harmony export */   "panSymlog": () => (/* binding */ panSymlog),
/* harmony export */   "peek": () => (/* binding */ peek),
/* harmony export */   "quarter": () => (/* binding */ quarter),
/* harmony export */   "repeat": () => (/* binding */ repeat),
/* harmony export */   "span": () => (/* binding */ span),
/* harmony export */   "splitAccessPath": () => (/* binding */ splitAccessPath),
/* harmony export */   "stringValue": () => (/* binding */ $),
/* harmony export */   "toBoolean": () => (/* binding */ toBoolean),
/* harmony export */   "toDate": () => (/* binding */ toDate),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toSet": () => (/* binding */ toSet),
/* harmony export */   "toString": () => (/* binding */ toString),
/* harmony export */   "truncate": () => (/* binding */ truncate),
/* harmony export */   "truthy": () => (/* binding */ truthy),
/* harmony export */   "utcquarter": () => (/* binding */ utcquarter),
/* harmony export */   "visitArray": () => (/* binding */ visitArray),
/* harmony export */   "writeConfig": () => (/* binding */ writeConfig),
/* harmony export */   "zero": () => (/* binding */ zero),
/* harmony export */   "zoomLinear": () => (/* binding */ zoomLinear),
/* harmony export */   "zoomLog": () => (/* binding */ zoomLog),
/* harmony export */   "zoomPow": () => (/* binding */ zoomPow),
/* harmony export */   "zoomSymlog": () => (/* binding */ zoomSymlog)
/* harmony export */ });
function accessor (fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function accessorName(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}

function getter (path) {
  return path.length === 1 ? get1(path[0]) : getN(path);
}

const get1 = field => function (obj) {
  return obj[field];
};

const getN = path => {
  const len = path.length;
  return function (obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path[i]];
    }

    return obj;
  };
};

function error (message) {
  throw Error(message);
}

function splitAccessPath (p) {
  const path = [],
        n = p.length;
  let q = null,
      b = 0,
      s = '',
      i,
      j,
      c;
  p = p + '';

  function push() {
    path.push(s + p.substring(i, j));
    s = '';
    i = j + 1;
  }

  for (i = j = 0; j < n; ++j) {
    c = p[j];

    if (c === '\\') {
      s += p.substring(i, j);
      s += p.substring(++j, ++j);
      i = j;
    } else if (c === q) {
      push();
      q = null;
      b = -1;
    } else if (q) {
      continue;
    } else if (i === b && c === '"') {
      i = j + 1;
      q = c;
    } else if (i === b && c === "'") {
      i = j + 1;
      q = c;
    } else if (c === '.' && !b) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c === '[') {
      if (j > i) push();
      b = i = j + 1;
    } else if (c === ']') {
      if (!b) error('Access path missing open bracket: ' + p);
      if (b > 0) push();
      b = 0;
      i = j + 1;
    }
  }

  if (b) error('Access path missing closing bracket: ' + p);
  if (q) error('Access path missing closing quote: ' + p);

  if (j > i) {
    j++;
    push();
  }

  return path;
}

function field (field, name, opt) {
  const path = splitAccessPath(field);
  field = path.length === 1 ? path[0] : field;
  return accessor((opt && opt.get || getter)(path), [field], name || field);
}

const id = field('id');
const identity = accessor(_ => _, [], 'identity');
const zero = accessor(() => 0, [], 'zero');
const one = accessor(() => 1, [], 'one');
const truthy = accessor(() => true, [], 'true');
const falsy = accessor(() => false, [], 'false');

function log$1(method, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method].apply(console, args); // eslint-disable-line no-console
}

const None = 0;
const Error$1 = 1;
const Warn = 2;
const Info = 3;
const Debug = 4;
function logger (_, method, handler = log$1) {
  let level = _ || None;
  return {
    level(_) {
      if (arguments.length) {
        level = +_;
        return this;
      } else {
        return level;
      }
    },

    error() {
      if (level >= Error$1) handler(method || 'error', 'ERROR', arguments);
      return this;
    },

    warn() {
      if (level >= Warn) handler(method || 'warn', 'WARN', arguments);
      return this;
    },

    info() {
      if (level >= Info) handler(method || 'log', 'INFO', arguments);
      return this;
    },

    debug() {
      if (level >= Debug) handler(method || 'log', 'DEBUG', arguments);
      return this;
    }

  };
}

var isArray = Array.isArray;

function isObject (_) {
  return _ === Object(_);
}

const isLegalKey = key => key !== '__proto__';

function mergeConfig(...configs) {
  return configs.reduce((out, source) => {
    for (const key in source) {
      if (key === 'signals') {
        // for signals, we merge the signals arrays
        // source signals take precedence over
        // existing signals with the same name
        out.signals = mergeNamed(out.signals, source.signals);
      } else {
        // otherwise, merge objects subject to recursion constraints
        // for legend block, recurse for the layout entry only
        // for style block, recurse for all properties
        // otherwise, no recursion: objects overwrite, no merging
        const r = key === 'legend' ? {
          layout: 1
        } : key === 'style' ? true : null;
        writeConfig(out, key, source[key], r);
      }
    }

    return out;
  }, {});
}
function writeConfig(output, key, value, recurse) {
  if (!isLegalKey(key)) return;
  let k, o;

  if (isObject(value) && !isArray(value)) {
    o = isObject(output[key]) ? output[key] : output[key] = {};

    for (k in value) {
      if (recurse && (recurse === true || recurse[k])) {
        writeConfig(o, k, value[k]);
      } else if (isLegalKey(k)) {
        o[k] = value[k];
      }
    }
  } else {
    output[key] = value;
  }
}

function mergeNamed(a, b) {
  if (a == null) return b;
  const map = {},
        out = [];

  function add(_) {
    if (!map[_.name]) {
      map[_.name] = 1;
      out.push(_);
    }
  }

  b.forEach(add);
  a.forEach(add);
  return out;
}

function peek (array) {
  return array[array.length - 1];
}

function toNumber (_) {
  return _ == null || _ === '' ? null : +_;
}

const exp = sign => x => sign * Math.exp(x);

const log = sign => x => Math.log(sign * x);

const symlog = c => x => Math.sign(x) * Math.log1p(Math.abs(x / c));

const symexp = c => x => Math.sign(x) * Math.expm1(Math.abs(x)) * c;

const pow = exponent => x => x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);

function pan(domain, delta, lift, ground) {
  const d0 = lift(domain[0]),
        d1 = lift(peek(domain)),
        dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}

function panLinear(domain, delta) {
  return pan(domain, delta, toNumber, identity);
}
function panLog(domain, delta) {
  var sign = Math.sign(domain[0]);
  return pan(domain, delta, log(sign), exp(sign));
}
function panPow(domain, delta, exponent) {
  return pan(domain, delta, pow(exponent), pow(1 / exponent));
}
function panSymlog(domain, delta, constant) {
  return pan(domain, delta, symlog(constant), symexp(constant));
}

function zoom(domain, anchor, scale, lift, ground) {
  const d0 = lift(domain[0]),
        d1 = lift(peek(domain)),
        da = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da + (d0 - da) * scale), ground(da + (d1 - da) * scale)];
}

function zoomLinear(domain, anchor, scale) {
  return zoom(domain, anchor, scale, toNumber, identity);
}
function zoomLog(domain, anchor, scale) {
  const sign = Math.sign(domain[0]);
  return zoom(domain, anchor, scale, log(sign), exp(sign));
}
function zoomPow(domain, anchor, scale, exponent) {
  return zoom(domain, anchor, scale, pow(exponent), pow(1 / exponent));
}
function zoomSymlog(domain, anchor, scale, constant) {
  return zoom(domain, anchor, scale, symlog(constant), symexp(constant));
}

function quarter(date) {
  return 1 + ~~(new Date(date).getMonth() / 3);
}
function utcquarter(date) {
  return 1 + ~~(new Date(date).getUTCMonth() / 3);
}

function array (_) {
  return _ != null ? isArray(_) ? _ : [_] : [];
}

/**
 * Span-preserving range clamp. If the span of the input range is less
 * than (max - min) and an endpoint exceeds either the min or max value,
 * the range is translated such that the span is preserved and one
 * endpoint touches the boundary of the min/max range.
 * If the span exceeds (max - min), the range [min, max] is returned.
 */
function clampRange (range, min, max) {
  let lo = range[0],
      hi = range[1],
      span;

  if (hi < lo) {
    span = hi;
    hi = lo;
    lo = span;
  }

  span = hi - lo;
  return span >= max - min ? [min, max] : [lo = Math.min(Math.max(lo, min), max - span), lo + span];
}

function isFunction (_) {
  return typeof _ === 'function';
}

const DESCENDING = 'descending';
function compare (fields, orders, opt) {
  opt = opt || {};
  orders = array(orders) || [];
  const ord = [],
        get = [],
        fmap = {},
        gen = opt.comparator || comparator;
  array(fields).forEach((f, i) => {
    if (f == null) return;
    ord.push(orders[i] === DESCENDING ? -1 : 1);
    get.push(f = isFunction(f) ? f : field(f, null, opt));
    (accessorFields(f) || []).forEach(_ => fmap[_] = 1);
  });
  return get.length === 0 ? null : accessor(gen(get, ord), Object.keys(fmap));
}
const ascending = (u, v) => (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;

const comparator = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);

const compare1 = (field, order) => function (a, b) {
  return ascending(field(a), field(b)) * order;
};

const compareN = (fields, orders, n) => {
  orders.push(0); // pad zero for convenient lookup

  return function (a, b) {
    let f,
        c = 0,
        i = -1;

    while (c === 0 && ++i < n) {
      f = fields[i];
      c = ascending(f(a), f(b));
    }

    return c * orders[i];
  };
};

function constant (_) {
  return isFunction(_) ? _ : () => _;
}

function debounce (delay, handler) {
  let tid;
  return e => {
    if (tid) clearTimeout(tid);
    tid = setTimeout(() => (handler(e), tid = null), delay);
  };
}

function extend (_) {
  for (let x, k, i = 1, len = arguments.length; i < len; ++i) {
    x = arguments[i];

    for (k in x) {
      _[k] = x[k];
    }
  }

  return _;
}

/**
 * Return an array with minimum and maximum values, in the
 * form [min, max]. Ignores null, undefined, and NaN values.
 */
function extent (array, f) {
  let i = 0,
      n,
      v,
      min,
      max;

  if (array && (n = array.length)) {
    if (f == null) {
      // find first valid value
      for (v = array[i]; i < n && (v == null || v !== v); v = array[++i]);

      min = max = v; // visit all other values

      for (; i < n; ++i) {
        v = array[i]; // skip null/undefined; NaN will fail all comparisons

        if (v != null) {
          if (v < min) min = v;
          if (v > max) max = v;
        }
      }
    } else {
      // find first valid value
      for (v = f(array[i]); i < n && (v == null || v !== v); v = f(array[++i]));

      min = max = v; // visit all other values

      for (; i < n; ++i) {
        v = f(array[i]); // skip null/undefined; NaN will fail all comparisons

        if (v != null) {
          if (v < min) min = v;
          if (v > max) max = v;
        }
      }
    }
  }

  return [min, max];
}

function extentIndex (array, f) {
  const n = array.length;
  let i = -1,
      a,
      b,
      c,
      u,
      v;

  if (f == null) {
    while (++i < n) {
      b = array[i];

      if (b != null && b >= b) {
        a = c = b;
        break;
      }
    }

    if (i === n) return [-1, -1];
    u = v = i;

    while (++i < n) {
      b = array[i];

      if (b != null) {
        if (a > b) {
          a = b;
          u = i;
        }

        if (c < b) {
          c = b;
          v = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b = f(array[i], i, array);

      if (b != null && b >= b) {
        a = c = b;
        break;
      }
    }

    if (i === n) return [-1, -1];
    u = v = i;

    while (++i < n) {
      b = f(array[i], i, array);

      if (b != null) {
        if (a > b) {
          a = b;
          u = i;
        }

        if (c < b) {
          c = b;
          v = i;
        }
      }
    }
  }

  return [u, v];
}

const hop = Object.prototype.hasOwnProperty;
function has (object, property) {
  return hop.call(object, property);
}

const NULL = {};
function fastmap (input) {
  let obj = {},
      test;

  function has$1(key) {
    return has(obj, key) && obj[key] !== NULL;
  }

  const map = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,

    get(key) {
      return has$1(key) ? obj[key] : undefined;
    },

    set(key, value) {
      if (!has$1(key)) {
        ++map.size;
        if (obj[key] === NULL) --map.empty;
      }

      obj[key] = value;
      return this;
    },

    delete(key) {
      if (has$1(key)) {
        --map.size;
        ++map.empty;
        obj[key] = NULL;
      }

      return this;
    },

    clear() {
      map.size = map.empty = 0;
      map.object = obj = {};
    },

    test(_) {
      if (arguments.length) {
        test = _;
        return map;
      } else {
        return test;
      }
    },

    clean() {
      const next = {};
      let size = 0;

      for (const key in obj) {
        const value = obj[key];

        if (value !== NULL && (!test || !test(value))) {
          next[key] = value;
          ++size;
        }
      }

      map.size = size;
      map.empty = 0;
      map.object = obj = next;
    }

  };
  if (input) Object.keys(input).forEach(key => {
    map.set(key, input[key]);
  });
  return map;
}

function flush (range, value, threshold, left, right, center) {
  if (!threshold && threshold !== 0) return center;
  const t = +threshold;
  let a = range[0],
      b = peek(range),
      l; // swap endpoints if range is reversed

  if (b < a) {
    l = a;
    a = b;
    b = l;
  } // compare value to endpoints


  l = Math.abs(value - a);
  const r = Math.abs(b - value); // adjust if value is within threshold distance of endpoint

  return l < r && l <= t ? left : r <= t ? right : center;
}

function inherits (child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, 'constructor', {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend(proto, members);
}

/**
 * Predicate that returns true if the value lies within the span
 * of the given range. The left and right flags control the use
 * of inclusive (true) or exclusive (false) comparisons.
 */
function inrange (value, range, left, right) {
  let r0 = range[0],
      r1 = range[range.length - 1],
      t;

  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }

  left = left === undefined || left;
  right = right === undefined || right;
  return (left ? r0 <= value : r0 < value) && (right ? value <= r1 : value < r1);
}

function isBoolean (_) {
  return typeof _ === 'boolean';
}

function isDate (_) {
  return Object.prototype.toString.call(_) === '[object Date]';
}

function isIterable (_) {
  return _ && isFunction(_[Symbol.iterator]);
}

function isNumber (_) {
  return typeof _ === 'number';
}

function isRegExp (_) {
  return Object.prototype.toString.call(_) === '[object RegExp]';
}

function isString (_) {
  return typeof _ === 'string';
}

function key (fields, flat, opt) {
  if (fields) {
    fields = flat ? array(fields).map(f => f.replace(/\\(.)/g, '$1')) : array(fields);
  }

  const len = fields && fields.length,
        gen = opt && opt.get || getter,
        map = f => gen(flat ? [f] : splitAccessPath(f));

  let fn;

  if (!len) {
    fn = function () {
      return '';
    };
  } else if (len === 1) {
    const get = map(fields[0]);

    fn = function (_) {
      return '' + get(_);
    };
  } else {
    const get = fields.map(map);

    fn = function (_) {
      let s = '' + get[0](_),
          i = 0;

      while (++i < len) s += '|' + get[i](_);

      return s;
    };
  }

  return accessor(fn, fields, 'key');
}

function lerp (array, frac) {
  const lo = array[0],
        hi = peek(array),
        f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}

const DEFAULT_MAX_SIZE = 10000; // adapted from https://github.com/dominictarr/hashlru/ (MIT License)

function lruCache (maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE;
  let curr, prev, size;

  const clear = () => {
    curr = {};
    prev = {};
    size = 0;
  };

  const update = (key, value) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }

    return curr[key] = value;
  };

  clear();
  return {
    clear,
    has: key => has(curr, key) || has(prev, key),
    get: key => has(curr, key) ? curr[key] : has(prev, key) ? update(key, prev[key]) : undefined,
    set: (key, value) => has(curr, key) ? curr[key] = value : update(key, value)
  };
}

function merge (compare, array0, array1, output) {
  const n0 = array0.length,
        n1 = array1.length;
  if (!n1) return array0;
  if (!n0) return array1;
  const merged = output || new array0.constructor(n0 + n1);
  let i0 = 0,
      i1 = 0,
      i = 0;

  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }

  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }

  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }

  return merged;
}

function repeat (str, reps) {
  let s = '';

  while (--reps >= 0) s += str;

  return s;
}

function pad (str, length, padchar, align) {
  const c = padchar || ' ',
        s = str + '',
        n = length - s.length;
  return n <= 0 ? s : align === 'left' ? repeat(c, n) + s : align === 'center' ? repeat(c, ~~(n / 2)) + s + repeat(c, Math.ceil(n / 2)) : s + repeat(c, n);
}

/**
 * Return the numerical span of an array: the difference between
 * the last and first values.
 */

function span (array) {
  return array && peek(array) - array[0] || 0;
}

function $(x) {
  return isArray(x) ? '[' + x.map($) + ']' : isObject(x) || isString(x) ? // Output valid JSON and JS source strings.
  // See http://timelessrepo.com/json-isnt-a-javascript-subset
  JSON.stringify(x).replace('\u2028', '\\u2028').replace('\u2029', '\\u2029') : x;
}

function toBoolean (_) {
  return _ == null || _ === '' ? null : !_ || _ === 'false' || _ === '0' ? false : !!_;
}

const defaultParser = _ => isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);

function toDate (_, parser) {
  parser = parser || defaultParser;
  return _ == null || _ === '' ? null : parser(_);
}

function toString (_) {
  return _ == null || _ === '' ? null : _ + '';
}

function toSet (_) {
  const s = {},
        n = _.length;

  for (let i = 0; i < n; ++i) s[_[i]] = true;

  return s;
}

function truncate (str, length, align, ellipsis) {
  const e = ellipsis != null ? ellipsis : '\u2026',
        s = str + '',
        n = s.length,
        l = Math.max(0, length - e.length);
  return n <= length ? s : align === 'left' ? e + s.slice(n - l) : align === 'center' ? s.slice(0, Math.ceil(l / 2)) + e + s.slice(n - ~~(l / 2)) : s.slice(0, l) + e;
}

function visitArray (array, filter, visitor) {
  if (array) {
    if (filter) {
      const n = array.length;

      for (let i = 0; i < n; ++i) {
        const t = filter(array[i]);
        if (t) visitor(t, i, array);
      }
    } else {
      array.forEach(visitor);
    }
  }
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS11dGlsL2J1aWxkL3ZlZ2EtdXRpbC5tb2R1bGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQzs7QUFFekQsb0JBQW9COztBQUVwQixZQUFZLE9BQU87QUFDbkIscUJBQXFCLHdCQUF3Qjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQixpQ0FBaUM7O0FBRTVELG9CQUFvQjs7QUFFcEIsWUFBWSxPQUFPO0FBQ25CLHdCQUF3Qix3QkFBd0I7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLG9CQUFvQjtBQUM1QjtBQUNBOztBQUVBLFFBQVEsU0FBUztBQUNqQjtBQUNBOztBQUVBLFFBQVEsU0FBUztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkOztBQUVBLGlCQUFpQixPQUFPOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFb3FCIiwiZmlsZSI6InZlbmRvcnMtbm9kZV9tb2R1bGVzX3ZlZ2EtdXRpbF9idWlsZF92ZWdhLXV0aWxfbW9kdWxlX2pzLjZlODZjZmY1MTQ5ODUxZjY5ZTA2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gYWNjZXNzb3IgKGZuLCBmaWVsZHMsIG5hbWUpIHtcbiAgZm4uZmllbGRzID0gZmllbGRzIHx8IFtdO1xuICBmbi5mbmFtZSA9IG5hbWU7XG4gIHJldHVybiBmbjtcbn1cbmZ1bmN0aW9uIGFjY2Vzc29yTmFtZShmbikge1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IG51bGwgOiBmbi5mbmFtZTtcbn1cbmZ1bmN0aW9uIGFjY2Vzc29yRmllbGRzKGZuKSB7XG4gIHJldHVybiBmbiA9PSBudWxsID8gbnVsbCA6IGZuLmZpZWxkcztcbn1cblxuZnVuY3Rpb24gZ2V0dGVyIChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gMSA/IGdldDEocGF0aFswXSkgOiBnZXROKHBhdGgpO1xufVxuXG5jb25zdCBnZXQxID0gZmllbGQgPT4gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqW2ZpZWxkXTtcbn07XG5cbmNvbnN0IGdldE4gPSBwYXRoID0+IHtcbiAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgb2JqID0gb2JqW3BhdGhbaV1dO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH07XG59O1xuXG5mdW5jdGlvbiBlcnJvciAobWVzc2FnZSkge1xuICB0aHJvdyBFcnJvcihtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gc3BsaXRBY2Nlc3NQYXRoIChwKSB7XG4gIGNvbnN0IHBhdGggPSBbXSxcbiAgICAgICAgbiA9IHAubGVuZ3RoO1xuICBsZXQgcSA9IG51bGwsXG4gICAgICBiID0gMCxcbiAgICAgIHMgPSAnJyxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgYztcbiAgcCA9IHAgKyAnJztcblxuICBmdW5jdGlvbiBwdXNoKCkge1xuICAgIHBhdGgucHVzaChzICsgcC5zdWJzdHJpbmcoaSwgaikpO1xuICAgIHMgPSAnJztcbiAgICBpID0gaiArIDE7XG4gIH1cblxuICBmb3IgKGkgPSBqID0gMDsgaiA8IG47ICsraikge1xuICAgIGMgPSBwW2pdO1xuXG4gICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgcyArPSBwLnN1YnN0cmluZyhpLCBqKTtcbiAgICAgIHMgKz0gcC5zdWJzdHJpbmcoKytqLCArK2opO1xuICAgICAgaSA9IGo7XG4gICAgfSBlbHNlIGlmIChjID09PSBxKSB7XG4gICAgICBwdXNoKCk7XG4gICAgICBxID0gbnVsbDtcbiAgICAgIGIgPSAtMTtcbiAgICB9IGVsc2UgaWYgKHEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gYiAmJiBjID09PSAnXCInKSB7XG4gICAgICBpID0gaiArIDE7XG4gICAgICBxID0gYztcbiAgICB9IGVsc2UgaWYgKGkgPT09IGIgJiYgYyA9PT0gXCInXCIpIHtcbiAgICAgIGkgPSBqICsgMTtcbiAgICAgIHEgPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gJy4nICYmICFiKSB7XG4gICAgICBpZiAoaiA+IGkpIHtcbiAgICAgICAgcHVzaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IGogKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICBpZiAoaiA+IGkpIHB1c2goKTtcbiAgICAgIGIgPSBpID0gaiArIDE7XG4gICAgfSBlbHNlIGlmIChjID09PSAnXScpIHtcbiAgICAgIGlmICghYikgZXJyb3IoJ0FjY2VzcyBwYXRoIG1pc3Npbmcgb3BlbiBicmFja2V0OiAnICsgcCk7XG4gICAgICBpZiAoYiA+IDApIHB1c2goKTtcbiAgICAgIGIgPSAwO1xuICAgICAgaSA9IGogKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChiKSBlcnJvcignQWNjZXNzIHBhdGggbWlzc2luZyBjbG9zaW5nIGJyYWNrZXQ6ICcgKyBwKTtcbiAgaWYgKHEpIGVycm9yKCdBY2Nlc3MgcGF0aCBtaXNzaW5nIGNsb3NpbmcgcXVvdGU6ICcgKyBwKTtcblxuICBpZiAoaiA+IGkpIHtcbiAgICBqKys7XG4gICAgcHVzaCgpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGZpZWxkIChmaWVsZCwgbmFtZSwgb3B0KSB7XG4gIGNvbnN0IHBhdGggPSBzcGxpdEFjY2Vzc1BhdGgoZmllbGQpO1xuICBmaWVsZCA9IHBhdGgubGVuZ3RoID09PSAxID8gcGF0aFswXSA6IGZpZWxkO1xuICByZXR1cm4gYWNjZXNzb3IoKG9wdCAmJiBvcHQuZ2V0IHx8IGdldHRlcikocGF0aCksIFtmaWVsZF0sIG5hbWUgfHwgZmllbGQpO1xufVxuXG5jb25zdCBpZCA9IGZpZWxkKCdpZCcpO1xuY29uc3QgaWRlbnRpdHkgPSBhY2Nlc3NvcihfID0+IF8sIFtdLCAnaWRlbnRpdHknKTtcbmNvbnN0IHplcm8gPSBhY2Nlc3NvcigoKSA9PiAwLCBbXSwgJ3plcm8nKTtcbmNvbnN0IG9uZSA9IGFjY2Vzc29yKCgpID0+IDEsIFtdLCAnb25lJyk7XG5jb25zdCB0cnV0aHkgPSBhY2Nlc3NvcigoKSA9PiB0cnVlLCBbXSwgJ3RydWUnKTtcbmNvbnN0IGZhbHN5ID0gYWNjZXNzb3IoKCkgPT4gZmFsc2UsIFtdLCAnZmFsc2UnKTtcblxuZnVuY3Rpb24gbG9nJDEobWV0aG9kLCBsZXZlbCwgaW5wdXQpIHtcbiAgY29uc3QgYXJncyA9IFtsZXZlbF0uY29uY2F0KFtdLnNsaWNlLmNhbGwoaW5wdXQpKTtcbiAgY29uc29sZVttZXRob2RdLmFwcGx5KGNvbnNvbGUsIGFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbn1cblxuY29uc3QgTm9uZSA9IDA7XG5jb25zdCBFcnJvciQxID0gMTtcbmNvbnN0IFdhcm4gPSAyO1xuY29uc3QgSW5mbyA9IDM7XG5jb25zdCBEZWJ1ZyA9IDQ7XG5mdW5jdGlvbiBsb2dnZXIgKF8sIG1ldGhvZCwgaGFuZGxlciA9IGxvZyQxKSB7XG4gIGxldCBsZXZlbCA9IF8gfHwgTm9uZTtcbiAgcmV0dXJuIHtcbiAgICBsZXZlbChfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBsZXZlbCA9ICtfO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsZXZlbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZXJyb3IoKSB7XG4gICAgICBpZiAobGV2ZWwgPj0gRXJyb3IkMSkgaGFuZGxlcihtZXRob2QgfHwgJ2Vycm9yJywgJ0VSUk9SJywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB3YXJuKCkge1xuICAgICAgaWYgKGxldmVsID49IFdhcm4pIGhhbmRsZXIobWV0aG9kIHx8ICd3YXJuJywgJ1dBUk4nLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGluZm8oKSB7XG4gICAgICBpZiAobGV2ZWwgPj0gSW5mbykgaGFuZGxlcihtZXRob2QgfHwgJ2xvZycsICdJTkZPJywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkZWJ1ZygpIHtcbiAgICAgIGlmIChsZXZlbCA+PSBEZWJ1ZykgaGFuZGxlcihtZXRob2QgfHwgJ2xvZycsICdERUJVRycsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgfTtcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBpc09iamVjdCAoXykge1xuICByZXR1cm4gXyA9PT0gT2JqZWN0KF8pO1xufVxuXG5jb25zdCBpc0xlZ2FsS2V5ID0ga2V5ID0+IGtleSAhPT0gJ19fcHJvdG9fXyc7XG5cbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKC4uLmNvbmZpZ3MpIHtcbiAgcmV0dXJuIGNvbmZpZ3MucmVkdWNlKChvdXQsIHNvdXJjZSkgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKGtleSA9PT0gJ3NpZ25hbHMnKSB7XG4gICAgICAgIC8vIGZvciBzaWduYWxzLCB3ZSBtZXJnZSB0aGUgc2lnbmFscyBhcnJheXNcbiAgICAgICAgLy8gc291cmNlIHNpZ25hbHMgdGFrZSBwcmVjZWRlbmNlIG92ZXJcbiAgICAgICAgLy8gZXhpc3Rpbmcgc2lnbmFscyB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgb3V0LnNpZ25hbHMgPSBtZXJnZU5hbWVkKG91dC5zaWduYWxzLCBzb3VyY2Uuc2lnbmFscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UsIG1lcmdlIG9iamVjdHMgc3ViamVjdCB0byByZWN1cnNpb24gY29uc3RyYWludHNcbiAgICAgICAgLy8gZm9yIGxlZ2VuZCBibG9jaywgcmVjdXJzZSBmb3IgdGhlIGxheW91dCBlbnRyeSBvbmx5XG4gICAgICAgIC8vIGZvciBzdHlsZSBibG9jaywgcmVjdXJzZSBmb3IgYWxsIHByb3BlcnRpZXNcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBubyByZWN1cnNpb246IG9iamVjdHMgb3ZlcndyaXRlLCBubyBtZXJnaW5nXG4gICAgICAgIGNvbnN0IHIgPSBrZXkgPT09ICdsZWdlbmQnID8ge1xuICAgICAgICAgIGxheW91dDogMVxuICAgICAgICB9IDoga2V5ID09PSAnc3R5bGUnID8gdHJ1ZSA6IG51bGw7XG4gICAgICAgIHdyaXRlQ29uZmlnKG91dCwga2V5LCBzb3VyY2Vba2V5XSwgcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gd3JpdGVDb25maWcob3V0cHV0LCBrZXksIHZhbHVlLCByZWN1cnNlKSB7XG4gIGlmICghaXNMZWdhbEtleShrZXkpKSByZXR1cm47XG4gIGxldCBrLCBvO1xuXG4gIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpKSB7XG4gICAgbyA9IGlzT2JqZWN0KG91dHB1dFtrZXldKSA/IG91dHB1dFtrZXldIDogb3V0cHV0W2tleV0gPSB7fTtcblxuICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHJlY3Vyc2UgJiYgKHJlY3Vyc2UgPT09IHRydWUgfHwgcmVjdXJzZVtrXSkpIHtcbiAgICAgICAgd3JpdGVDb25maWcobywgaywgdmFsdWVba10pO1xuICAgICAgfSBlbHNlIGlmIChpc0xlZ2FsS2V5KGspKSB7XG4gICAgICAgIG9ba10gPSB2YWx1ZVtrXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZU5hbWVkKGEsIGIpIHtcbiAgaWYgKGEgPT0gbnVsbCkgcmV0dXJuIGI7XG4gIGNvbnN0IG1hcCA9IHt9LFxuICAgICAgICBvdXQgPSBbXTtcblxuICBmdW5jdGlvbiBhZGQoXykge1xuICAgIGlmICghbWFwW18ubmFtZV0pIHtcbiAgICAgIG1hcFtfLm5hbWVdID0gMTtcbiAgICAgIG91dC5wdXNoKF8pO1xuICAgIH1cbiAgfVxuXG4gIGIuZm9yRWFjaChhZGQpO1xuICBhLmZvckVhY2goYWRkKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gcGVlayAoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xufVxuXG5mdW5jdGlvbiB0b051bWJlciAoXykge1xuICByZXR1cm4gXyA9PSBudWxsIHx8IF8gPT09ICcnID8gbnVsbCA6ICtfO1xufVxuXG5jb25zdCBleHAgPSBzaWduID0+IHggPT4gc2lnbiAqIE1hdGguZXhwKHgpO1xuXG5jb25zdCBsb2cgPSBzaWduID0+IHggPT4gTWF0aC5sb2coc2lnbiAqIHgpO1xuXG5jb25zdCBzeW1sb2cgPSBjID0+IHggPT4gTWF0aC5zaWduKHgpICogTWF0aC5sb2cxcChNYXRoLmFicyh4IC8gYykpO1xuXG5jb25zdCBzeW1leHAgPSBjID0+IHggPT4gTWF0aC5zaWduKHgpICogTWF0aC5leHBtMShNYXRoLmFicyh4KSkgKiBjO1xuXG5jb25zdCBwb3cgPSBleHBvbmVudCA9PiB4ID0+IHggPCAwID8gLU1hdGgucG93KC14LCBleHBvbmVudCkgOiBNYXRoLnBvdyh4LCBleHBvbmVudCk7XG5cbmZ1bmN0aW9uIHBhbihkb21haW4sIGRlbHRhLCBsaWZ0LCBncm91bmQpIHtcbiAgY29uc3QgZDAgPSBsaWZ0KGRvbWFpblswXSksXG4gICAgICAgIGQxID0gbGlmdChwZWVrKGRvbWFpbikpLFxuICAgICAgICBkZCA9IChkMSAtIGQwKSAqIGRlbHRhO1xuICByZXR1cm4gW2dyb3VuZChkMCAtIGRkKSwgZ3JvdW5kKGQxIC0gZGQpXTtcbn1cblxuZnVuY3Rpb24gcGFuTGluZWFyKGRvbWFpbiwgZGVsdGEpIHtcbiAgcmV0dXJuIHBhbihkb21haW4sIGRlbHRhLCB0b051bWJlciwgaWRlbnRpdHkpO1xufVxuZnVuY3Rpb24gcGFuTG9nKGRvbWFpbiwgZGVsdGEpIHtcbiAgdmFyIHNpZ24gPSBNYXRoLnNpZ24oZG9tYWluWzBdKTtcbiAgcmV0dXJuIHBhbihkb21haW4sIGRlbHRhLCBsb2coc2lnbiksIGV4cChzaWduKSk7XG59XG5mdW5jdGlvbiBwYW5Qb3coZG9tYWluLCBkZWx0YSwgZXhwb25lbnQpIHtcbiAgcmV0dXJuIHBhbihkb21haW4sIGRlbHRhLCBwb3coZXhwb25lbnQpLCBwb3coMSAvIGV4cG9uZW50KSk7XG59XG5mdW5jdGlvbiBwYW5TeW1sb2coZG9tYWluLCBkZWx0YSwgY29uc3RhbnQpIHtcbiAgcmV0dXJuIHBhbihkb21haW4sIGRlbHRhLCBzeW1sb2coY29uc3RhbnQpLCBzeW1leHAoY29uc3RhbnQpKTtcbn1cblxuZnVuY3Rpb24gem9vbShkb21haW4sIGFuY2hvciwgc2NhbGUsIGxpZnQsIGdyb3VuZCkge1xuICBjb25zdCBkMCA9IGxpZnQoZG9tYWluWzBdKSxcbiAgICAgICAgZDEgPSBsaWZ0KHBlZWsoZG9tYWluKSksXG4gICAgICAgIGRhID0gYW5jaG9yICE9IG51bGwgPyBsaWZ0KGFuY2hvcikgOiAoZDAgKyBkMSkgLyAyO1xuICByZXR1cm4gW2dyb3VuZChkYSArIChkMCAtIGRhKSAqIHNjYWxlKSwgZ3JvdW5kKGRhICsgKGQxIC0gZGEpICogc2NhbGUpXTtcbn1cblxuZnVuY3Rpb24gem9vbUxpbmVhcihkb21haW4sIGFuY2hvciwgc2NhbGUpIHtcbiAgcmV0dXJuIHpvb20oZG9tYWluLCBhbmNob3IsIHNjYWxlLCB0b051bWJlciwgaWRlbnRpdHkpO1xufVxuZnVuY3Rpb24gem9vbUxvZyhkb21haW4sIGFuY2hvciwgc2NhbGUpIHtcbiAgY29uc3Qgc2lnbiA9IE1hdGguc2lnbihkb21haW5bMF0pO1xuICByZXR1cm4gem9vbShkb21haW4sIGFuY2hvciwgc2NhbGUsIGxvZyhzaWduKSwgZXhwKHNpZ24pKTtcbn1cbmZ1bmN0aW9uIHpvb21Qb3coZG9tYWluLCBhbmNob3IsIHNjYWxlLCBleHBvbmVudCkge1xuICByZXR1cm4gem9vbShkb21haW4sIGFuY2hvciwgc2NhbGUsIHBvdyhleHBvbmVudCksIHBvdygxIC8gZXhwb25lbnQpKTtcbn1cbmZ1bmN0aW9uIHpvb21TeW1sb2coZG9tYWluLCBhbmNob3IsIHNjYWxlLCBjb25zdGFudCkge1xuICByZXR1cm4gem9vbShkb21haW4sIGFuY2hvciwgc2NhbGUsIHN5bWxvZyhjb25zdGFudCksIHN5bWV4cChjb25zdGFudCkpO1xufVxuXG5mdW5jdGlvbiBxdWFydGVyKGRhdGUpIHtcbiAgcmV0dXJuIDEgKyB+fihuZXcgRGF0ZShkYXRlKS5nZXRNb250aCgpIC8gMyk7XG59XG5mdW5jdGlvbiB1dGNxdWFydGVyKGRhdGUpIHtcbiAgcmV0dXJuIDEgKyB+fihuZXcgRGF0ZShkYXRlKS5nZXRVVENNb250aCgpIC8gMyk7XG59XG5cbmZ1bmN0aW9uIGFycmF5IChfKSB7XG4gIHJldHVybiBfICE9IG51bGwgPyBpc0FycmF5KF8pID8gXyA6IFtfXSA6IFtdO1xufVxuXG4vKipcbiAqIFNwYW4tcHJlc2VydmluZyByYW5nZSBjbGFtcC4gSWYgdGhlIHNwYW4gb2YgdGhlIGlucHV0IHJhbmdlIGlzIGxlc3NcbiAqIHRoYW4gKG1heCAtIG1pbikgYW5kIGFuIGVuZHBvaW50IGV4Y2VlZHMgZWl0aGVyIHRoZSBtaW4gb3IgbWF4IHZhbHVlLFxuICogdGhlIHJhbmdlIGlzIHRyYW5zbGF0ZWQgc3VjaCB0aGF0IHRoZSBzcGFuIGlzIHByZXNlcnZlZCBhbmQgb25lXG4gKiBlbmRwb2ludCB0b3VjaGVzIHRoZSBib3VuZGFyeSBvZiB0aGUgbWluL21heCByYW5nZS5cbiAqIElmIHRoZSBzcGFuIGV4Y2VlZHMgKG1heCAtIG1pbiksIHRoZSByYW5nZSBbbWluLCBtYXhdIGlzIHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBjbGFtcFJhbmdlIChyYW5nZSwgbWluLCBtYXgpIHtcbiAgbGV0IGxvID0gcmFuZ2VbMF0sXG4gICAgICBoaSA9IHJhbmdlWzFdLFxuICAgICAgc3BhbjtcblxuICBpZiAoaGkgPCBsbykge1xuICAgIHNwYW4gPSBoaTtcbiAgICBoaSA9IGxvO1xuICAgIGxvID0gc3BhbjtcbiAgfVxuXG4gIHNwYW4gPSBoaSAtIGxvO1xuICByZXR1cm4gc3BhbiA+PSBtYXggLSBtaW4gPyBbbWluLCBtYXhdIDogW2xvID0gTWF0aC5taW4oTWF0aC5tYXgobG8sIG1pbiksIG1heCAtIHNwYW4pLCBsbyArIHNwYW5dO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChfKSB7XG4gIHJldHVybiB0eXBlb2YgXyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuY29uc3QgREVTQ0VORElORyA9ICdkZXNjZW5kaW5nJztcbmZ1bmN0aW9uIGNvbXBhcmUgKGZpZWxkcywgb3JkZXJzLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICBvcmRlcnMgPSBhcnJheShvcmRlcnMpIHx8IFtdO1xuICBjb25zdCBvcmQgPSBbXSxcbiAgICAgICAgZ2V0ID0gW10sXG4gICAgICAgIGZtYXAgPSB7fSxcbiAgICAgICAgZ2VuID0gb3B0LmNvbXBhcmF0b3IgfHwgY29tcGFyYXRvcjtcbiAgYXJyYXkoZmllbGRzKS5mb3JFYWNoKChmLCBpKSA9PiB7XG4gICAgaWYgKGYgPT0gbnVsbCkgcmV0dXJuO1xuICAgIG9yZC5wdXNoKG9yZGVyc1tpXSA9PT0gREVTQ0VORElORyA/IC0xIDogMSk7XG4gICAgZ2V0LnB1c2goZiA9IGlzRnVuY3Rpb24oZikgPyBmIDogZmllbGQoZiwgbnVsbCwgb3B0KSk7XG4gICAgKGFjY2Vzc29yRmllbGRzKGYpIHx8IFtdKS5mb3JFYWNoKF8gPT4gZm1hcFtfXSA9IDEpO1xuICB9KTtcbiAgcmV0dXJuIGdldC5sZW5ndGggPT09IDAgPyBudWxsIDogYWNjZXNzb3IoZ2VuKGdldCwgb3JkKSwgT2JqZWN0LmtleXMoZm1hcCkpO1xufVxuY29uc3QgYXNjZW5kaW5nID0gKHUsIHYpID0+ICh1IDwgdiB8fCB1ID09IG51bGwpICYmIHYgIT0gbnVsbCA/IC0xIDogKHUgPiB2IHx8IHYgPT0gbnVsbCkgJiYgdSAhPSBudWxsID8gMSA6ICh2ID0gdiBpbnN0YW5jZW9mIERhdGUgPyArdiA6IHYsIHUgPSB1IGluc3RhbmNlb2YgRGF0ZSA/ICt1IDogdSkgIT09IHUgJiYgdiA9PT0gdiA/IC0xIDogdiAhPT0gdiAmJiB1ID09PSB1ID8gMSA6IDA7XG5cbmNvbnN0IGNvbXBhcmF0b3IgPSAoZmllbGRzLCBvcmRlcnMpID0+IGZpZWxkcy5sZW5ndGggPT09IDEgPyBjb21wYXJlMShmaWVsZHNbMF0sIG9yZGVyc1swXSkgOiBjb21wYXJlTihmaWVsZHMsIG9yZGVycywgZmllbGRzLmxlbmd0aCk7XG5cbmNvbnN0IGNvbXBhcmUxID0gKGZpZWxkLCBvcmRlcikgPT4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIGFzY2VuZGluZyhmaWVsZChhKSwgZmllbGQoYikpICogb3JkZXI7XG59O1xuXG5jb25zdCBjb21wYXJlTiA9IChmaWVsZHMsIG9yZGVycywgbikgPT4ge1xuICBvcmRlcnMucHVzaCgwKTsgLy8gcGFkIHplcm8gZm9yIGNvbnZlbmllbnQgbG9va3VwXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgbGV0IGYsXG4gICAgICAgIGMgPSAwLFxuICAgICAgICBpID0gLTE7XG5cbiAgICB3aGlsZSAoYyA9PT0gMCAmJiArK2kgPCBuKSB7XG4gICAgICBmID0gZmllbGRzW2ldO1xuICAgICAgYyA9IGFzY2VuZGluZyhmKGEpLCBmKGIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYyAqIG9yZGVyc1tpXTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNvbnN0YW50IChfKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKF8pID8gXyA6ICgpID0+IF87XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlIChkZWxheSwgaGFuZGxlcikge1xuICBsZXQgdGlkO1xuICByZXR1cm4gZSA9PiB7XG4gICAgaWYgKHRpZCkgY2xlYXJUaW1lb3V0KHRpZCk7XG4gICAgdGlkID0gc2V0VGltZW91dCgoKSA9PiAoaGFuZGxlcihlKSwgdGlkID0gbnVsbCksIGRlbGF5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kIChfKSB7XG4gIGZvciAobGV0IHgsIGssIGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB4ID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yIChrIGluIHgpIHtcbiAgICAgIF9ba10gPSB4W2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSB3aXRoIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzLCBpbiB0aGVcbiAqIGZvcm0gW21pbiwgbWF4XS4gSWdub3JlcyBudWxsLCB1bmRlZmluZWQsIGFuZCBOYU4gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBleHRlbnQgKGFycmF5LCBmKSB7XG4gIGxldCBpID0gMCxcbiAgICAgIG4sXG4gICAgICB2LFxuICAgICAgbWluLFxuICAgICAgbWF4O1xuXG4gIGlmIChhcnJheSAmJiAobiA9IGFycmF5Lmxlbmd0aCkpIHtcbiAgICBpZiAoZiA9PSBudWxsKSB7XG4gICAgICAvLyBmaW5kIGZpcnN0IHZhbGlkIHZhbHVlXG4gICAgICBmb3IgKHYgPSBhcnJheVtpXTsgaSA8IG4gJiYgKHYgPT0gbnVsbCB8fCB2ICE9PSB2KTsgdiA9IGFycmF5WysraV0pO1xuXG4gICAgICBtaW4gPSBtYXggPSB2OyAvLyB2aXNpdCBhbGwgb3RoZXIgdmFsdWVzXG5cbiAgICAgIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHYgPSBhcnJheVtpXTsgLy8gc2tpcCBudWxsL3VuZGVmaW5lZDsgTmFOIHdpbGwgZmFpbCBhbGwgY29tcGFyaXNvbnNcblxuICAgICAgICBpZiAodiAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHYgPCBtaW4pIG1pbiA9IHY7XG4gICAgICAgICAgaWYgKHYgPiBtYXgpIG1heCA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmluZCBmaXJzdCB2YWxpZCB2YWx1ZVxuICAgICAgZm9yICh2ID0gZihhcnJheVtpXSk7IGkgPCBuICYmICh2ID09IG51bGwgfHwgdiAhPT0gdik7IHYgPSBmKGFycmF5WysraV0pKTtcblxuICAgICAgbWluID0gbWF4ID0gdjsgLy8gdmlzaXQgYWxsIG90aGVyIHZhbHVlc1xuXG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICB2ID0gZihhcnJheVtpXSk7IC8vIHNraXAgbnVsbC91bmRlZmluZWQ7IE5hTiB3aWxsIGZhaWwgYWxsIGNvbXBhcmlzb25zXG5cbiAgICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh2IDwgbWluKSBtaW4gPSB2O1xuICAgICAgICAgIGlmICh2ID4gbWF4KSBtYXggPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbmZ1bmN0aW9uIGV4dGVudEluZGV4IChhcnJheSwgZikge1xuICBjb25zdCBuID0gYXJyYXkubGVuZ3RoO1xuICBsZXQgaSA9IC0xLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgdSxcbiAgICAgIHY7XG5cbiAgaWYgKGYgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBiID0gYXJyYXlbaV07XG5cbiAgICAgIGlmIChiICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBjID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IG4pIHJldHVybiBbLTEsIC0xXTtcbiAgICB1ID0gdiA9IGk7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYiA9IGFycmF5W2ldO1xuXG4gICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgIHUgPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCBiKSB7XG4gICAgICAgICAgYyA9IGI7XG4gICAgICAgICAgdiA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGIgPSBmKGFycmF5W2ldLCBpLCBhcnJheSk7XG5cbiAgICAgIGlmIChiICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBjID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IG4pIHJldHVybiBbLTEsIC0xXTtcbiAgICB1ID0gdiA9IGk7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYiA9IGYoYXJyYXlbaV0sIGksIGFycmF5KTtcblxuICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgICBhID0gYjtcbiAgICAgICAgICB1ID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgYikge1xuICAgICAgICAgIGMgPSBiO1xuICAgICAgICAgIHYgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFt1LCB2XTtcbn1cblxuY29uc3QgaG9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhcyAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gaG9wLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG59XG5cbmNvbnN0IE5VTEwgPSB7fTtcbmZ1bmN0aW9uIGZhc3RtYXAgKGlucHV0KSB7XG4gIGxldCBvYmogPSB7fSxcbiAgICAgIHRlc3Q7XG5cbiAgZnVuY3Rpb24gaGFzJDEoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhvYmosIGtleSkgJiYgb2JqW2tleV0gIT09IE5VTEw7XG4gIH1cblxuICBjb25zdCBtYXAgPSB7XG4gICAgc2l6ZTogMCxcbiAgICBlbXB0eTogMCxcbiAgICBvYmplY3Q6IG9iaixcbiAgICBoYXM6IGhhcyQxLFxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGhhcyQxKGtleSkgPyBvYmpba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICghaGFzJDEoa2V5KSkge1xuICAgICAgICArK21hcC5zaXplO1xuICAgICAgICBpZiAob2JqW2tleV0gPT09IE5VTEwpIC0tbWFwLmVtcHR5O1xuICAgICAgfVxuXG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgIGlmIChoYXMkMShrZXkpKSB7XG4gICAgICAgIC0tbWFwLnNpemU7XG4gICAgICAgICsrbWFwLmVtcHR5O1xuICAgICAgICBvYmpba2V5XSA9IE5VTEw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhcigpIHtcbiAgICAgIG1hcC5zaXplID0gbWFwLmVtcHR5ID0gMDtcbiAgICAgIG1hcC5vYmplY3QgPSBvYmogPSB7fTtcbiAgICB9LFxuXG4gICAgdGVzdChfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0ZXN0ID0gXztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0ZXN0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjbGVhbigpIHtcbiAgICAgIGNvbnN0IG5leHQgPSB7fTtcbiAgICAgIGxldCBzaXplID0gMDtcblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSBOVUxMICYmICghdGVzdCB8fCAhdGVzdCh2YWx1ZSkpKSB7XG4gICAgICAgICAgbmV4dFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgKytzaXplO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1hcC5zaXplID0gc2l6ZTtcbiAgICAgIG1hcC5lbXB0eSA9IDA7XG4gICAgICBtYXAub2JqZWN0ID0gb2JqID0gbmV4dDtcbiAgICB9XG5cbiAgfTtcbiAgaWYgKGlucHV0KSBPYmplY3Qua2V5cyhpbnB1dCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIG1hcC5zZXQoa2V5LCBpbnB1dFtrZXldKTtcbiAgfSk7XG4gIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIGZsdXNoIChyYW5nZSwgdmFsdWUsIHRocmVzaG9sZCwgbGVmdCwgcmlnaHQsIGNlbnRlcikge1xuICBpZiAoIXRocmVzaG9sZCAmJiB0aHJlc2hvbGQgIT09IDApIHJldHVybiBjZW50ZXI7XG4gIGNvbnN0IHQgPSArdGhyZXNob2xkO1xuICBsZXQgYSA9IHJhbmdlWzBdLFxuICAgICAgYiA9IHBlZWsocmFuZ2UpLFxuICAgICAgbDsgLy8gc3dhcCBlbmRwb2ludHMgaWYgcmFuZ2UgaXMgcmV2ZXJzZWRcblxuICBpZiAoYiA8IGEpIHtcbiAgICBsID0gYTtcbiAgICBhID0gYjtcbiAgICBiID0gbDtcbiAgfSAvLyBjb21wYXJlIHZhbHVlIHRvIGVuZHBvaW50c1xuXG5cbiAgbCA9IE1hdGguYWJzKHZhbHVlIC0gYSk7XG4gIGNvbnN0IHIgPSBNYXRoLmFicyhiIC0gdmFsdWUpOyAvLyBhZGp1c3QgaWYgdmFsdWUgaXMgd2l0aGluIHRocmVzaG9sZCBkaXN0YW5jZSBvZiBlbmRwb2ludFxuXG4gIHJldHVybiBsIDwgciAmJiBsIDw9IHQgPyBsZWZ0IDogciA8PSB0ID8gcmlnaHQgOiBjZW50ZXI7XG59XG5cbmZ1bmN0aW9uIGluaGVyaXRzIChjaGlsZCwgcGFyZW50LCBtZW1iZXJzKSB7XG4gIGNvbnN0IHByb3RvID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnY29uc3RydWN0b3InLCB7XG4gICAgdmFsdWU6IGNoaWxkLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gZXh0ZW5kKHByb3RvLCBtZW1iZXJzKTtcbn1cblxuLyoqXG4gKiBQcmVkaWNhdGUgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGxpZXMgd2l0aGluIHRoZSBzcGFuXG4gKiBvZiB0aGUgZ2l2ZW4gcmFuZ2UuIFRoZSBsZWZ0IGFuZCByaWdodCBmbGFncyBjb250cm9sIHRoZSB1c2VcbiAqIG9mIGluY2x1c2l2ZSAodHJ1ZSkgb3IgZXhjbHVzaXZlIChmYWxzZSkgY29tcGFyaXNvbnMuXG4gKi9cbmZ1bmN0aW9uIGlucmFuZ2UgKHZhbHVlLCByYW5nZSwgbGVmdCwgcmlnaHQpIHtcbiAgbGV0IHIwID0gcmFuZ2VbMF0sXG4gICAgICByMSA9IHJhbmdlW3JhbmdlLmxlbmd0aCAtIDFdLFxuICAgICAgdDtcblxuICBpZiAocjAgPiByMSkge1xuICAgIHQgPSByMDtcbiAgICByMCA9IHIxO1xuICAgIHIxID0gdDtcbiAgfVxuXG4gIGxlZnQgPSBsZWZ0ID09PSB1bmRlZmluZWQgfHwgbGVmdDtcbiAgcmlnaHQgPSByaWdodCA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0O1xuICByZXR1cm4gKGxlZnQgPyByMCA8PSB2YWx1ZSA6IHIwIDwgdmFsdWUpICYmIChyaWdodCA/IHZhbHVlIDw9IHIxIDogdmFsdWUgPCByMSk7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbiAoXykge1xuICByZXR1cm4gdHlwZW9mIF8gPT09ICdib29sZWFuJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlIChfKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoXykgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZnVuY3Rpb24gaXNJdGVyYWJsZSAoXykge1xuICByZXR1cm4gXyAmJiBpc0Z1bmN0aW9uKF9bU3ltYm9sLml0ZXJhdG9yXSk7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyIChfKSB7XG4gIHJldHVybiB0eXBlb2YgXyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwIChfKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoXykgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyAoXykge1xuICByZXR1cm4gdHlwZW9mIF8gPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBrZXkgKGZpZWxkcywgZmxhdCwgb3B0KSB7XG4gIGlmIChmaWVsZHMpIHtcbiAgICBmaWVsZHMgPSBmbGF0ID8gYXJyYXkoZmllbGRzKS5tYXAoZiA9PiBmLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJykpIDogYXJyYXkoZmllbGRzKTtcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGZpZWxkcyAmJiBmaWVsZHMubGVuZ3RoLFxuICAgICAgICBnZW4gPSBvcHQgJiYgb3B0LmdldCB8fCBnZXR0ZXIsXG4gICAgICAgIG1hcCA9IGYgPT4gZ2VuKGZsYXQgPyBbZl0gOiBzcGxpdEFjY2Vzc1BhdGgoZikpO1xuXG4gIGxldCBmbjtcblxuICBpZiAoIWxlbikge1xuICAgIGZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gIH0gZWxzZSBpZiAobGVuID09PSAxKSB7XG4gICAgY29uc3QgZ2V0ID0gbWFwKGZpZWxkc1swXSk7XG5cbiAgICBmbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICByZXR1cm4gJycgKyBnZXQoXyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBnZXQgPSBmaWVsZHMubWFwKG1hcCk7XG5cbiAgICBmbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICBsZXQgcyA9ICcnICsgZ2V0WzBdKF8pLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoKytpIDwgbGVuKSBzICs9ICd8JyArIGdldFtpXShfKTtcblxuICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBhY2Nlc3NvcihmbiwgZmllbGRzLCAna2V5Jyk7XG59XG5cbmZ1bmN0aW9uIGxlcnAgKGFycmF5LCBmcmFjKSB7XG4gIGNvbnN0IGxvID0gYXJyYXlbMF0sXG4gICAgICAgIGhpID0gcGVlayhhcnJheSksXG4gICAgICAgIGYgPSArZnJhYztcbiAgcmV0dXJuICFmID8gbG8gOiBmID09PSAxID8gaGkgOiBsbyArIGYgKiAoaGkgLSBsbyk7XG59XG5cbmNvbnN0IERFRkFVTFRfTUFYX1NJWkUgPSAxMDAwMDsgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9oYXNobHJ1LyAoTUlUIExpY2Vuc2UpXG5cbmZ1bmN0aW9uIGxydUNhY2hlIChtYXhzaXplKSB7XG4gIG1heHNpemUgPSArbWF4c2l6ZSB8fCBERUZBVUxUX01BWF9TSVpFO1xuICBsZXQgY3VyciwgcHJldiwgc2l6ZTtcblxuICBjb25zdCBjbGVhciA9ICgpID0+IHtcbiAgICBjdXJyID0ge307XG4gICAgcHJldiA9IHt9O1xuICAgIHNpemUgPSAwO1xuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKCsrc2l6ZSA+IG1heHNpemUpIHtcbiAgICAgIHByZXYgPSBjdXJyO1xuICAgICAgY3VyciA9IHt9O1xuICAgICAgc2l6ZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJba2V5XSA9IHZhbHVlO1xuICB9O1xuXG4gIGNsZWFyKCk7XG4gIHJldHVybiB7XG4gICAgY2xlYXIsXG4gICAgaGFzOiBrZXkgPT4gaGFzKGN1cnIsIGtleSkgfHwgaGFzKHByZXYsIGtleSksXG4gICAgZ2V0OiBrZXkgPT4gaGFzKGN1cnIsIGtleSkgPyBjdXJyW2tleV0gOiBoYXMocHJldiwga2V5KSA/IHVwZGF0ZShrZXksIHByZXZba2V5XSkgOiB1bmRlZmluZWQsXG4gICAgc2V0OiAoa2V5LCB2YWx1ZSkgPT4gaGFzKGN1cnIsIGtleSkgPyBjdXJyW2tleV0gPSB2YWx1ZSA6IHVwZGF0ZShrZXksIHZhbHVlKVxuICB9O1xufVxuXG5mdW5jdGlvbiBtZXJnZSAoY29tcGFyZSwgYXJyYXkwLCBhcnJheTEsIG91dHB1dCkge1xuICBjb25zdCBuMCA9IGFycmF5MC5sZW5ndGgsXG4gICAgICAgIG4xID0gYXJyYXkxLmxlbmd0aDtcbiAgaWYgKCFuMSkgcmV0dXJuIGFycmF5MDtcbiAgaWYgKCFuMCkgcmV0dXJuIGFycmF5MTtcbiAgY29uc3QgbWVyZ2VkID0gb3V0cHV0IHx8IG5ldyBhcnJheTAuY29uc3RydWN0b3IobjAgKyBuMSk7XG4gIGxldCBpMCA9IDAsXG4gICAgICBpMSA9IDAsXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgaTAgPCBuMCAmJiBpMSA8IG4xOyArK2kpIHtcbiAgICBtZXJnZWRbaV0gPSBjb21wYXJlKGFycmF5MFtpMF0sIGFycmF5MVtpMV0pID4gMCA/IGFycmF5MVtpMSsrXSA6IGFycmF5MFtpMCsrXTtcbiAgfVxuXG4gIGZvciAoOyBpMCA8IG4wOyArK2kwLCArK2kpIHtcbiAgICBtZXJnZWRbaV0gPSBhcnJheTBbaTBdO1xuICB9XG5cbiAgZm9yICg7IGkxIDwgbjE7ICsraTEsICsraSkge1xuICAgIG1lcmdlZFtpXSA9IGFycmF5MVtpMV07XG4gIH1cblxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiByZXBlYXQgKHN0ciwgcmVwcykge1xuICBsZXQgcyA9ICcnO1xuXG4gIHdoaWxlICgtLXJlcHMgPj0gMCkgcyArPSBzdHI7XG5cbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIHBhZCAoc3RyLCBsZW5ndGgsIHBhZGNoYXIsIGFsaWduKSB7XG4gIGNvbnN0IGMgPSBwYWRjaGFyIHx8ICcgJyxcbiAgICAgICAgcyA9IHN0ciArICcnLFxuICAgICAgICBuID0gbGVuZ3RoIC0gcy5sZW5ndGg7XG4gIHJldHVybiBuIDw9IDAgPyBzIDogYWxpZ24gPT09ICdsZWZ0JyA/IHJlcGVhdChjLCBuKSArIHMgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyByZXBlYXQoYywgfn4obiAvIDIpKSArIHMgKyByZXBlYXQoYywgTWF0aC5jZWlsKG4gLyAyKSkgOiBzICsgcmVwZWF0KGMsIG4pO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtZXJpY2FsIHNwYW4gb2YgYW4gYXJyYXk6IHRoZSBkaWZmZXJlbmNlIGJldHdlZW5cbiAqIHRoZSBsYXN0IGFuZCBmaXJzdCB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gc3BhbiAoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5ICYmIHBlZWsoYXJyYXkpIC0gYXJyYXlbMF0gfHwgMDtcbn1cblxuZnVuY3Rpb24gJCh4KSB7XG4gIHJldHVybiBpc0FycmF5KHgpID8gJ1snICsgeC5tYXAoJCkgKyAnXScgOiBpc09iamVjdCh4KSB8fCBpc1N0cmluZyh4KSA/IC8vIE91dHB1dCB2YWxpZCBKU09OIGFuZCBKUyBzb3VyY2Ugc3RyaW5ncy5cbiAgLy8gU2VlIGh0dHA6Ly90aW1lbGVzc3JlcG8uY29tL2pzb24taXNudC1hLWphdmFzY3JpcHQtc3Vic2V0XG4gIEpTT04uc3RyaW5naWZ5KHgpLnJlcGxhY2UoJ1xcdTIwMjgnLCAnXFxcXHUyMDI4JykucmVwbGFjZSgnXFx1MjAyOScsICdcXFxcdTIwMjknKSA6IHg7XG59XG5cbmZ1bmN0aW9uIHRvQm9vbGVhbiAoXykge1xuICByZXR1cm4gXyA9PSBudWxsIHx8IF8gPT09ICcnID8gbnVsbCA6ICFfIHx8IF8gPT09ICdmYWxzZScgfHwgXyA9PT0gJzAnID8gZmFsc2UgOiAhIV87XG59XG5cbmNvbnN0IGRlZmF1bHRQYXJzZXIgPSBfID0+IGlzTnVtYmVyKF8pID8gXyA6IGlzRGF0ZShfKSA/IF8gOiBEYXRlLnBhcnNlKF8pO1xuXG5mdW5jdGlvbiB0b0RhdGUgKF8sIHBhcnNlcikge1xuICBwYXJzZXIgPSBwYXJzZXIgfHwgZGVmYXVsdFBhcnNlcjtcbiAgcmV0dXJuIF8gPT0gbnVsbCB8fCBfID09PSAnJyA/IG51bGwgOiBwYXJzZXIoXyk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nIChfKSB7XG4gIHJldHVybiBfID09IG51bGwgfHwgXyA9PT0gJycgPyBudWxsIDogXyArICcnO1xufVxuXG5mdW5jdGlvbiB0b1NldCAoXykge1xuICBjb25zdCBzID0ge30sXG4gICAgICAgIG4gPSBfLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkgc1tfW2ldXSA9IHRydWU7XG5cbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlIChzdHIsIGxlbmd0aCwgYWxpZ24sIGVsbGlwc2lzKSB7XG4gIGNvbnN0IGUgPSBlbGxpcHNpcyAhPSBudWxsID8gZWxsaXBzaXMgOiAnXFx1MjAyNicsXG4gICAgICAgIHMgPSBzdHIgKyAnJyxcbiAgICAgICAgbiA9IHMubGVuZ3RoLFxuICAgICAgICBsID0gTWF0aC5tYXgoMCwgbGVuZ3RoIC0gZS5sZW5ndGgpO1xuICByZXR1cm4gbiA8PSBsZW5ndGggPyBzIDogYWxpZ24gPT09ICdsZWZ0JyA/IGUgKyBzLnNsaWNlKG4gLSBsKSA6IGFsaWduID09PSAnY2VudGVyJyA/IHMuc2xpY2UoMCwgTWF0aC5jZWlsKGwgLyAyKSkgKyBlICsgcy5zbGljZShuIC0gfn4obCAvIDIpKSA6IHMuc2xpY2UoMCwgbCkgKyBlO1xufVxuXG5mdW5jdGlvbiB2aXNpdEFycmF5IChhcnJheSwgZmlsdGVyLCB2aXNpdG9yKSB7XG4gIGlmIChhcnJheSkge1xuICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgIGNvbnN0IG4gPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHQgPSBmaWx0ZXIoYXJyYXlbaV0pO1xuICAgICAgICBpZiAodCkgdmlzaXRvcih0LCBpLCBhcnJheSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5LmZvckVhY2godmlzaXRvcik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IERlYnVnLCBFcnJvciQxIGFzIEVycm9yLCBJbmZvLCBOb25lLCBXYXJuLCBhY2Nlc3NvciwgYWNjZXNzb3JGaWVsZHMsIGFjY2Vzc29yTmFtZSwgYXJyYXksIGFzY2VuZGluZywgY2xhbXBSYW5nZSwgY29tcGFyZSwgY29uc3RhbnQsIGRlYm91bmNlLCBlcnJvciwgZXh0ZW5kLCBleHRlbnQsIGV4dGVudEluZGV4LCBmYWxzeSwgZmFzdG1hcCwgZmllbGQsIGZsdXNoLCBoYXMgYXMgaGFzT3duUHJvcGVydHksIGlkLCBpZGVudGl0eSwgaW5oZXJpdHMsIGlucmFuZ2UsIGlzQXJyYXksIGlzQm9vbGVhbiwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0l0ZXJhYmxlLCBpc051bWJlciwgaXNPYmplY3QsIGlzUmVnRXhwLCBpc1N0cmluZywga2V5LCBsZXJwLCBsb2dnZXIsIGxydUNhY2hlLCBtZXJnZSwgbWVyZ2VDb25maWcsIG9uZSwgcGFkLCBwYW5MaW5lYXIsIHBhbkxvZywgcGFuUG93LCBwYW5TeW1sb2csIHBlZWssIHF1YXJ0ZXIsIHJlcGVhdCwgc3Bhbiwgc3BsaXRBY2Nlc3NQYXRoLCAkIGFzIHN0cmluZ1ZhbHVlLCB0b0Jvb2xlYW4sIHRvRGF0ZSwgdG9OdW1iZXIsIHRvU2V0LCB0b1N0cmluZywgdHJ1bmNhdGUsIHRydXRoeSwgdXRjcXVhcnRlciwgdmlzaXRBcnJheSwgd3JpdGVDb25maWcsIHplcm8sIHpvb21MaW5lYXIsIHpvb21Mb2csIHpvb21Qb3csIHpvb21TeW1sb2cgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=