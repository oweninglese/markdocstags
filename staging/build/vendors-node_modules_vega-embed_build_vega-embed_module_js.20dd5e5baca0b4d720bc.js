(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_vega-embed_build_vega-embed_module_js"],{

/***/ "./node_modules/fast-json-patch/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/fast-json-patch/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_areEquals": () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__._areEquals),
/* harmony export */   "applyOperation": () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.applyOperation),
/* harmony export */   "applyPatch": () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.applyPatch),
/* harmony export */   "applyReducer": () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.applyReducer),
/* harmony export */   "getValueByPointer": () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.getValueByPointer),
/* harmony export */   "validate": () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.validate),
/* harmony export */   "validator": () => (/* reexport safe */ _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__.validator),
/* harmony export */   "compare": () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.compare),
/* harmony export */   "generate": () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.generate),
/* harmony export */   "observe": () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.observe),
/* harmony export */   "unobserve": () => (/* reexport safe */ _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__.unobserve),
/* harmony export */   "JsonPatchError": () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.PatchError),
/* harmony export */   "deepClone": () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__._deepClone),
/* harmony export */   "escapePathComponent": () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent),
/* harmony export */   "unescapePathComponent": () => (/* reexport safe */ _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module/core.mjs */ "./node_modules/fast-json-patch/module/core.mjs");
/* harmony import */ var _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./module/duplex.mjs */ "./node_modules/fast-json-patch/module/duplex.mjs");
/* harmony import */ var _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./module/helpers.mjs */ "./node_modules/fast-json-patch/module/helpers.mjs");





/**
 * Default export for backwards compat
 */





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Object.assign({}, _module_core_mjs__WEBPACK_IMPORTED_MODULE_0__, _module_duplex_mjs__WEBPACK_IMPORTED_MODULE_1__, {
    JsonPatchError: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.PatchError,
    deepClone: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__._deepClone,
    escapePathComponent: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.escapePathComponent,
    unescapePathComponent: _module_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.unescapePathComponent
}));

/***/ }),

/***/ "./node_modules/fast-json-patch/module/core.mjs":
/*!******************************************************!*\
  !*** ./node_modules/fast-json-patch/module/core.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JsonPatchError": () => (/* binding */ JsonPatchError),
/* harmony export */   "deepClone": () => (/* binding */ deepClone),
/* harmony export */   "getValueByPointer": () => (/* binding */ getValueByPointer),
/* harmony export */   "applyOperation": () => (/* binding */ applyOperation),
/* harmony export */   "applyPatch": () => (/* binding */ applyPatch),
/* harmony export */   "applyReducer": () => (/* binding */ applyReducer),
/* harmony export */   "validator": () => (/* binding */ validator),
/* harmony export */   "validate": () => (/* binding */ validate),
/* harmony export */   "_areEquals": () => (/* binding */ _areEquals)
/* harmony export */ });
/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ "./node_modules/fast-json-patch/module/helpers.mjs");

var JsonPatchError = _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.PatchError;
var deepClone = _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone;
/* We use a Javascript hash to store each
 function. Each hash entry (property) uses
 the operation identifiers specified in rfc6902.
 In this way, we can map each patch operation
 to its dedicated function in efficient way.
 */
/* The operations applicable to an object */
var objOps = {
    add: function (obj, key, document) {
        obj[key] = this.value;
        return { newDocument: document };
    },
    remove: function (obj, key, document) {
        var removed = obj[key];
        delete obj[key];
        return { newDocument: document, removed: removed };
    },
    replace: function (obj, key, document) {
        var removed = obj[key];
        obj[key] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: function (obj, key, document) {
        /* in case move target overwrites an existing value,
        return the removed value, this can be taxing performance-wise,
        and is potentially unneeded */
        var removed = getValueByPointer(document, this.path);
        if (removed) {
            removed = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(removed);
        }
        var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
        applyOperation(document, { op: "add", path: this.path, value: originalValue });
        return { newDocument: document, removed: removed };
    },
    copy: function (obj, key, document) {
        var valueToCopy = getValueByPointer(document, this.from);
        // enforce copy by value so further operations don't affect source (see issue #177)
        applyOperation(document, { op: "add", path: this.path, value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(valueToCopy) });
        return { newDocument: document };
    },
    test: function (obj, key, document) {
        return { newDocument: document, test: _areEquals(obj[key], this.value) };
    },
    _get: function (obj, key, document) {
        this.value = obj[key];
        return { newDocument: document };
    }
};
/* The operations applicable to an array. Many are the same as for the object */
var arrOps = {
    add: function (arr, i, document) {
        if ((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isInteger)(i)) {
            arr.splice(i, 0, this.value);
        }
        else { // array props
            arr[i] = this.value;
        }
        // this may be needed when using '-' in an array
        return { newDocument: document, index: i };
    },
    remove: function (arr, i, document) {
        var removedList = arr.splice(i, 1);
        return { newDocument: document, removed: removedList[0] };
    },
    replace: function (arr, i, document) {
        var removed = arr[i];
        arr[i] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
};
/**
 * Retrieves a value from a JSON document by a JSON pointer.
 * Returns the value.
 *
 * @param document The document to get the value from
 * @param pointer an escaped JSON pointer
 * @return The retrieved value
 */
function getValueByPointer(document, pointer) {
    if (pointer == '') {
        return document;
    }
    var getOriginalDestination = { op: "_get", path: pointer };
    applyOperation(document, getOriginalDestination);
    return getOriginalDestination.value;
}
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the {newDocument, result} of the operation.
 * It modifies the `document` and `operation` objects - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return `{newDocument, result}` after the operation
 */
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
    if (validateOperation === void 0) { validateOperation = false; }
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (index === void 0) { index = 0; }
    if (validateOperation) {
        if (typeof validateOperation == 'function') {
            validateOperation(operation, 0, document, operation.path);
        }
        else {
            validator(operation, 0);
        }
    }
    /* ROOT OPERATIONS */
    if (operation.path === "") {
        var returnValue = { newDocument: document };
        if (operation.op === 'add') {
            returnValue.newDocument = operation.value;
            return returnValue;
        }
        else if (operation.op === 'replace') {
            returnValue.newDocument = operation.value;
            returnValue.removed = document; //document we removed
            return returnValue;
        }
        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root
            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
            if (operation.op === 'move') { // report removed item
                returnValue.removed = document;
            }
            return returnValue;
        }
        else if (operation.op === 'test') {
            returnValue.test = _areEquals(document, operation.value);
            if (returnValue.test === false) {
                throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
            }
            returnValue.newDocument = document;
            return returnValue;
        }
        else if (operation.op === 'remove') { // a remove on root
            returnValue.removed = document;
            returnValue.newDocument = null;
            return returnValue;
        }
        else if (operation.op === '_get') {
            operation.value = document;
            return returnValue;
        }
        else { /* bad operation */
            if (validateOperation) {
                throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
            }
            else {
                return returnValue;
            }
        }
    } /* END ROOT OPERATIONS */
    else {
        if (!mutateDocument) {
            document = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);
        }
        var path = operation.path || "";
        var keys = path.split('/');
        var obj = document;
        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
        var len = keys.length;
        var existingPathFragment = undefined;
        var key = void 0;
        var validateFunction = void 0;
        if (typeof validateOperation == 'function') {
            validateFunction = validateOperation;
        }
        else {
            validateFunction = validator;
        }
        while (true) {
            key = keys[t];
            if (banPrototypeModifications && key == '__proto__') {
                throw new TypeError('JSON-Patch: modifying `__proto__` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
            }
            if (validateOperation) {
                if (existingPathFragment === undefined) {
                    if (obj[key] === undefined) {
                        existingPathFragment = keys.slice(0, t).join('/');
                    }
                    else if (t == len - 1) {
                        existingPathFragment = operation.path;
                    }
                    if (existingPathFragment !== undefined) {
                        validateFunction(operation, 0, document, existingPathFragment);
                    }
                }
            }
            t++;
            if (Array.isArray(obj)) {
                if (key === '-') {
                    key = obj.length;
                }
                else {
                    if (validateOperation && !(0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {
                        throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
                    } // only parse key when it's an integer for `arr.prop` to work
                    else if ((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isInteger)(key)) {
                        key = ~~key;
                    }
                }
                if (t >= len) {
                    if (validateOperation && operation.op === "add" && key > obj.length) {
                        throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
                    }
                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            else {
                if (key && key.indexOf('~') != -1) {
                    key = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.unescapePathComponent)(key);
                }
                if (t >= len) {
                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            obj = obj[key];
        }
    }
}
/**
 * Apply a full JSON Patch array on a JSON document.
 * Returns the {newDocument, result} of the patch.
 * It modifies the `document` object and `patch` - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
 *
 * @param document The document to patch
 * @param patch The patch to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return An array of `{newDocument, result}` after the patch
 */
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (validateOperation) {
        if (!Array.isArray(patch)) {
            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
    }
    if (!mutateDocument) {
        document = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document);
    }
    var results = new Array(patch.length);
    for (var i = 0, length_1 = patch.length; i < length_1; i++) {
        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
        document = results[i].newDocument; // in case root was replaced
    }
    results.newDocument = document;
    return results;
}
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the updated document.
 * Suitable as a reducer.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @return The updated document
 */
function applyReducer(document, operation, index) {
    var operationResult = applyOperation(document, operation);
    if (operationResult.test === false) { // failed test
        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
    }
    return operationResult.newDocument;
}
/**
 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
 * @param {object} operation - operation object (patch)
 * @param {number} index - index of operation in the sequence
 * @param {object} [document] - object where the operation is supposed to be applied
 * @param {string} [existingPathFragment] - comes along with `document`
 */
function validator(operation, index, document, existingPathFragment) {
    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
        throw new JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
    }
    else if (!objOps[operation.op]) {
        throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
    }
    else if (typeof operation.path !== 'string') {
        throw new JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
        // paths that aren't empty string should start with "/"
        throw new JsonPatchError('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
        throw new JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.hasUndefined)(operation.value)) {
        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
    }
    else if (document) {
        if (operation.op == "add") {
            var pathLen = operation.path.split("/").length;
            var existingPathLen = existingPathFragment.split("/").length;
            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
                throw new JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
            }
        }
        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
            if (operation.path !== existingPathFragment) {
                throw new JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
        else if (operation.op === 'move' || operation.op === 'copy') {
            var existingValue = { op: "_get", path: operation.from, value: undefined };
            var error = validate([existingValue], document);
            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
                throw new JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
/**
 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
 * If error is encountered, returns a JsonPatchError object
 * @param sequence
 * @param document
 * @returns {JsonPatchError|undefined}
 */
function validate(sequence, document, externalValidator) {
    try {
        if (!Array.isArray(sequence)) {
            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
        if (document) {
            //clone document and sequence so that we can safely try applying operations
            applyPatch((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(document), (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(sequence), externalValidator || true);
        }
        else {
            externalValidator = externalValidator || validator;
            for (var i = 0; i < sequence.length; i++) {
                externalValidator(sequence[i], i, document, undefined);
            }
        }
    }
    catch (e) {
        if (e instanceof JsonPatchError) {
            return e;
        }
        else {
            throw e;
        }
    }
}
// based on https://github.com/epoberezkin/fast-deep-equal
// MIT License
// Copyright (c) 2017 Evgeny Poberezkin
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
function _areEquals(a, b) {
    if (a === b)
        return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
        if (arrA && arrB) {
            length = a.length;
            if (length != b.length)
                return false;
            for (i = length; i-- !== 0;)
                if (!_areEquals(a[i], b[i]))
                    return false;
            return true;
        }
        if (arrA != arrB)
            return false;
        var keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
            return false;
        for (i = length; i-- !== 0;)
            if (!b.hasOwnProperty(keys[i]))
                return false;
        for (i = length; i-- !== 0;) {
            key = keys[i];
            if (!_areEquals(a[key], b[key]))
                return false;
        }
        return true;
    }
    return a !== a && b !== b;
}
;


/***/ }),

/***/ "./node_modules/fast-json-patch/module/duplex.mjs":
/*!********************************************************!*\
  !*** ./node_modules/fast-json-patch/module/duplex.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unobserve": () => (/* binding */ unobserve),
/* harmony export */   "observe": () => (/* binding */ observe),
/* harmony export */   "generate": () => (/* binding */ generate),
/* harmony export */   "compare": () => (/* binding */ compare)
/* harmony export */ });
/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.mjs */ "./node_modules/fast-json-patch/module/helpers.mjs");
/* harmony import */ var _core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.mjs */ "./node_modules/fast-json-patch/module/core.mjs");
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */


var beforeDict = new WeakMap();
var Mirror = /** @class */ (function () {
    function Mirror(obj) {
        this.observers = new Map();
        this.obj = obj;
    }
    return Mirror;
}());
var ObserverInfo = /** @class */ (function () {
    function ObserverInfo(callback, observer) {
        this.callback = callback;
        this.observer = observer;
    }
    return ObserverInfo;
}());
function getMirror(obj) {
    return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
    return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
    mirror.observers.delete(observer.callback);
}
/**
 * Detach an observer from an object
 */
function unobserve(root, observer) {
    observer.unobserve();
}
/**
 * Observes changes made to an object, which can then be retrieved using generate
 */
function observe(obj, callback) {
    var patches = [];
    var observer;
    var mirror = getMirror(obj);
    if (!mirror) {
        mirror = new Mirror(obj);
        beforeDict.set(obj, mirror);
    }
    else {
        var observerInfo = getObserverFromMirror(mirror, callback);
        observer = observerInfo && observerInfo.observer;
    }
    if (observer) {
        return observer;
    }
    observer = {};
    mirror.value = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj);
    if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function () {
            generate(observer);
        };
        var fastCheck = function () {
            clearTimeout(observer.next);
            observer.next = setTimeout(dirtyCheck);
        };
        if (typeof window !== 'undefined') { //not Node
            window.addEventListener('mouseup', fastCheck);
            window.addEventListener('keyup', fastCheck);
            window.addEventListener('mousedown', fastCheck);
            window.addEventListener('keydown', fastCheck);
            window.addEventListener('change', fastCheck);
        }
    }
    observer.patches = patches;
    observer.object = obj;
    observer.unobserve = function () {
        generate(observer);
        clearTimeout(observer.next);
        removeObserverFromMirror(mirror, observer);
        if (typeof window !== 'undefined') {
            window.removeEventListener('mouseup', fastCheck);
            window.removeEventListener('keyup', fastCheck);
            window.removeEventListener('mousedown', fastCheck);
            window.removeEventListener('keydown', fastCheck);
            window.removeEventListener('change', fastCheck);
        }
    };
    mirror.observers.set(callback, new ObserverInfo(callback, observer));
    return observer;
}
/**
 * Generate an array of patches from an observer
 */
function generate(observer, invertible) {
    if (invertible === void 0) { invertible = false; }
    var mirror = beforeDict.get(observer.object);
    _generate(mirror.value, observer.object, observer.patches, "", invertible);
    if (observer.patches.length) {
        (0,_core_mjs__WEBPACK_IMPORTED_MODULE_1__.applyPatch)(mirror.value, observer.patches);
    }
    var temp = observer.patches;
    if (temp.length > 0) {
        observer.patches = [];
        if (observer.callback) {
            observer.callback(temp);
        }
    }
    return temp;
}
// Dirty check if obj is different from mirror, generate patches and update mirror
function _generate(mirror, obj, patches, path, invertible) {
    if (obj === mirror) {
        return;
    }
    if (typeof obj.toJSON === "function") {
        obj = obj.toJSON();
    }
    var newKeys = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(obj);
    var oldKeys = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._objectKeys)(mirror);
    var changed = false;
    var deleted = false;
    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
    for (var t = oldKeys.length - 1; t >= 0; t--) {
        var key = oldKeys[t];
        var oldVal = mirror[key];
        if ((0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
            var newVal = obj[key];
            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null) {
                _generate(oldVal, newVal, patches, path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), invertible);
            }
            else {
                if (oldVal !== newVal) {
                    changed = true;
                    if (invertible) {
                        patches.push({ op: "test", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal) });
                    }
                    patches.push({ op: "replace", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(newVal) });
                }
            }
        }
        else if (Array.isArray(mirror) === Array.isArray(obj)) {
            if (invertible) {
                patches.push({ op: "test", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(oldVal) });
            }
            patches.push({ op: "remove", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key) });
            deleted = true; // property has been deleted
        }
        else {
            if (invertible) {
                patches.push({ op: "test", path: path, value: mirror });
            }
            patches.push({ op: "replace", path: path, value: obj });
            changed = true;
        }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
        return;
    }
    for (var t = 0; t < newKeys.length; t++) {
        var key = newKeys[t];
        if (!(0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(mirror, key) && obj[key] !== undefined) {
            patches.push({ op: "add", path: path + "/" + (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.escapePathComponent)(key), value: (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deepClone)(obj[key]) });
        }
    }
}
/**
 * Create an array of patches from the differences in two objects
 */
function compare(tree1, tree2, invertible) {
    if (invertible === void 0) { invertible = false; }
    var patches = [];
    _generate(tree1, tree2, patches, '', invertible);
    return patches;
}


/***/ }),

/***/ "./node_modules/fast-json-patch/module/helpers.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/fast-json-patch/module/helpers.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasOwnProperty": () => (/* binding */ hasOwnProperty),
/* harmony export */   "_objectKeys": () => (/* binding */ _objectKeys),
/* harmony export */   "_deepClone": () => (/* binding */ _deepClone),
/* harmony export */   "isInteger": () => (/* binding */ isInteger),
/* harmony export */   "escapePathComponent": () => (/* binding */ escapePathComponent),
/* harmony export */   "unescapePathComponent": () => (/* binding */ unescapePathComponent),
/* harmony export */   "_getPathRecursive": () => (/* binding */ _getPathRecursive),
/* harmony export */   "getPath": () => (/* binding */ getPath),
/* harmony export */   "hasUndefined": () => (/* binding */ hasUndefined),
/* harmony export */   "PatchError": () => (/* binding */ PatchError)
/* harmony export */ });
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
    if (Array.isArray(obj)) {
        var keys = new Array(obj.length);
        for (var k = 0; k < keys.length; k++) {
            keys[k] = "" + k;
        }
        return keys;
    }
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keys = [];
    for (var i in obj) {
        if (hasOwnProperty(obj, i)) {
            keys.push(i);
        }
    }
    return keys;
}
;
/**
* Deeply clone the object.
* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
* @param  {any} obj value to clone
* @return {any} cloned obj
*/
function _deepClone(obj) {
    switch (typeof obj) {
        case "object":
            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
        case "undefined":
            return null; //this is how JSON.stringify behaves for array items
        default:
            return obj; //no need to clone primitives
    }
}
//3x faster than cached /^\d+$/.test(str)
function isInteger(str) {
    var i = 0;
    var len = str.length;
    var charCode;
    while (i < len) {
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
            i++;
            continue;
        }
        return false;
    }
    return true;
}
/**
* Escapes a json pointer path
* @param path The raw pointer
* @return the Escaped path
*/
function escapePathComponent(path) {
    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)
        return path;
    return path.replace(/~/g, '~0').replace(/\//g, '~1');
}
/**
 * Unescapes a json pointer path
 * @param path The escaped pointer
 * @return The unescaped path
 */
function unescapePathComponent(path) {
    return path.replace(/~1/g, '/').replace(/~0/g, '~');
}
function _getPathRecursive(root, obj) {
    var found;
    for (var key in root) {
        if (hasOwnProperty(root, key)) {
            if (root[key] === obj) {
                return escapePathComponent(key) + '/';
            }
            else if (typeof root[key] === 'object') {
                found = _getPathRecursive(root[key], obj);
                if (found != '') {
                    return escapePathComponent(key) + '/' + found;
                }
            }
        }
    }
    return '';
}
function getPath(root, obj) {
    if (root === obj) {
        return '/';
    }
    var path = _getPathRecursive(root, obj);
    if (path === '') {
        throw new Error("Object not found in root");
    }
    return '/' + path;
}
/**
* Recursively checks whether an object has any undefined values inside.
*/
function hasUndefined(obj) {
    if (obj === undefined) {
        return true;
    }
    if (obj) {
        if (Array.isArray(obj)) {
            for (var i = 0, len = obj.length; i < len; i++) {
                if (hasUndefined(obj[i])) {
                    return true;
                }
            }
        }
        else if (typeof obj === "object") {
            var objKeys = _objectKeys(obj);
            var objKeysLength = objKeys.length;
            for (var i = 0; i < objKeysLength; i++) {
                if (hasUndefined(obj[objKeys[i]])) {
                    return true;
                }
            }
        }
    }
    return false;
}
function patchErrorMessageFormatter(message, args) {
    var messageParts = [message];
    for (var key in args) {
        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
        if (typeof value !== 'undefined') {
            messageParts.push(key + ": " + value);
        }
    }
    return messageParts.join('\n');
}
var PatchError = /** @class */ (function (_super) {
    __extends(PatchError, _super);
    function PatchError(message, name, index, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;
        _this.name = name;
        _this.index = index;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });
        return _this;
    }
    return PatchError;
}(Error));



/***/ }),

/***/ "./node_modules/json-stringify-pretty-compact/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/json-stringify-pretty-compact/index.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";


// Note: This regex matches even invalid JSON strings, but since we’re
// working on the output of `JSON.stringify` we know that only valid strings
// are present (unless the user supplied a weird `options.indent` but in
// that case we don’t care since the output would be invalid anyway).
var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;

module.exports = function stringify(passedObj, options) {
  var indent, maxLength, replacer;

  options = options || {};
  indent = JSON.stringify(
    [1],
    undefined,
    options.indent === undefined ? 2 : options.indent
  ).slice(2, -3);
  maxLength =
    indent === ""
      ? Infinity
      : options.maxLength === undefined
      ? 80
      : options.maxLength;
  replacer = options.replacer;

  return (function _stringify(obj, currentIndent, reserved) {
    // prettier-ignore
    var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;

    if (obj && typeof obj.toJSON === "function") {
      obj = obj.toJSON();
    }

    string = JSON.stringify(obj, replacer);

    if (string === undefined) {
      return string;
    }

    length = maxLength - currentIndent.length - reserved;

    if (string.length <= length) {
      prettified = string.replace(
        stringOrChar,
        function (match, stringLiteral) {
          return stringLiteral || match + " ";
        }
      );
      if (prettified.length <= length) {
        return prettified;
      }
    }

    if (replacer != null) {
      obj = JSON.parse(string);
      replacer = undefined;
    }

    if (typeof obj === "object" && obj !== null) {
      nextIndent = currentIndent + indent;
      items = [];
      index = 0;

      if (Array.isArray(obj)) {
        start = "[";
        end = "]";
        length = obj.length;
        for (; index < length; index++) {
          items.push(
            _stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) ||
              "null"
          );
        }
      } else {
        start = "{";
        end = "}";
        keys = Object.keys(obj);
        length = keys.length;
        for (; index < length; index++) {
          key = keys[index];
          keyPart = JSON.stringify(key) + ": ";
          value = _stringify(
            obj[key],
            nextIndent,
            keyPart.length + (index === length - 1 ? 0 : 1)
          );
          if (value !== undefined) {
            items.push(keyPart + value);
          }
        }
      }

      if (items.length > 0) {
        return [start, indent + items.join(",\n" + nextIndent), end].join(
          "\n" + currentIndent
        );
      }
    }

    return string;
  })(passedObj, "", 0);
};


/***/ }),

/***/ "./node_modules/vega-embed/build/vega-embed.module.js":
/*!************************************************************!*\
  !*** ./node_modules/vega-embed/build/vega-embed.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "DEFAULT_ACTIONS": () => (/* binding */ DEFAULT_ACTIONS),
/* harmony export */   "guessMode": () => (/* binding */ guessMode),
/* harmony export */   "vega": () => (/* binding */ vega),
/* harmony export */   "vegaLite": () => (/* binding */ _vegaLite)
/* harmony export */ });
/* harmony import */ var fast_json_patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-json-patch */ "./node_modules/fast-json-patch/index.mjs");
/* harmony import */ var json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! json-stringify-pretty-compact */ "./node_modules/json-stringify-pretty-compact/index.js");
/* harmony import */ var json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var vega__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega */ "webpack/sharing/consume/default/vega/vega");
/* harmony import */ var vega__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(vega__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var vega_lite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-lite */ "webpack/sharing/consume/default/vega-lite/vega-lite");
/* harmony import */ var vega_lite__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(vega_lite__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var vega_schema_url_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-schema-url-parser */ "./node_modules/vega-schema-url-parser/dist/parser.module.js");
/* harmony import */ var vega_themes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vega-themes */ "./node_modules/vega-themes/build/vega-themes.module.js");
/* harmony import */ var vega_tooltip__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vega-tooltip */ "./node_modules/vega-tooltip/build/vega-tooltip.module.js");










function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var Op = Object.prototype;
var hasOwn = Op.hasOwnProperty;
var undefined$1; // More compressible than void 0.

var $Symbol = typeof Symbol === "function" ? Symbol : {};
var iteratorSymbol = $Symbol.iterator || "@@iterator";
var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

function wrap(innerFn, outerFn, self, tryLocsList) {
  // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
  var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
  var generator = Object.create(protoGenerator.prototype);
  var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
  // .throw, and .return methods.

  generator._invoke = makeInvokeMethod(innerFn, self, context);
  return generator;
} // Try/catch helper to minimize deoptimizations. Returns a completion
// record like context.tryEntries[i].completion. This interface could
// have been (and was previously) designed to take a closure to be
// invoked without arguments, but in all the cases we care about we
// already have an existing method we want to call, so there's no need
// to create a new function object. We can even get away with assuming
// the method takes exactly one argument, since that happens to be true
// in every case, so we don't have to touch the arguments object. The
// only additional allocation required is the completion record, which
// has a stable shape and so hopefully should be cheap to allocate.


function tryCatch(fn, obj, arg) {
  try {
    return {
      type: "normal",
      arg: fn.call(obj, arg)
    };
  } catch (err) {
    return {
      type: "throw",
      arg: err
    };
  }
}

var GenStateSuspendedStart = "suspendedStart";
var GenStateSuspendedYield = "suspendedYield";
var GenStateExecuting = "executing";
var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
// breaking out of the dispatch switch statement.

var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
// .constructor.prototype properties for functions that return Generator
// objects. For full spec compliance, you may wish to configure your
// minifier not to mangle the names of these two functions.

function Generator() {}

function GeneratorFunction() {}

function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
// don't natively support it.


var IteratorPrototype = {};

IteratorPrototype[iteratorSymbol] = function () {
  return this;
};

var getProto = Object.getPrototypeOf;
var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
  // This environment has a native %IteratorPrototype%; use it instead
  // of the polyfill.
  IteratorPrototype = NativeIteratorPrototype;
}

var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
GeneratorFunctionPrototype.constructor = GeneratorFunction;
GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
// Iterator interface in terms of a single ._invoke method.

function defineIteratorMethods(prototype) {
  ["next", "throw", "return"].forEach(function (method) {
    prototype[method] = function (arg) {
      return this._invoke(method, arg);
    };
  });
}

function isGeneratorFunction(genFun) {
  var ctor = typeof genFun === "function" && genFun.constructor;
  return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
  // do is to check its .name property.
  (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
}

function mark(genFun) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
  } else {
    genFun.__proto__ = GeneratorFunctionPrototype;

    if (!(toStringTagSymbol in genFun)) {
      genFun[toStringTagSymbol] = "GeneratorFunction";
    }
  }

  genFun.prototype = Object.create(Gp);
  return genFun;
}
// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
// `hasOwn.call(value, "__await")` to determine if the yielded value is
// meant to be awaited.

function awrap(arg) {
  return {
    __await: arg
  };
}

function AsyncIterator(generator, PromiseImpl) {
  function invoke(method, arg, resolve, reject) {
    var record = tryCatch(generator[method], generator, arg);

    if (record.type === "throw") {
      reject(record.arg);
    } else {
      var result = record.arg;
      var value = result.value;

      if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
        return PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        });
      }

      return PromiseImpl.resolve(value).then(function (unwrapped) {
        // When a yielded Promise is resolved, its final value becomes
        // the .value of the Promise<{value,done}> result for the
        // current iteration.
        result.value = unwrapped;
        resolve(result);
      }, function (error) {
        // If a rejected Promise was yielded, throw the rejection back
        // into the async generator function so it can be handled there.
        return invoke("throw", error, resolve, reject);
      });
    }
  }

  var previousPromise;

  function enqueue(method, arg) {
    function callInvokeWithMethodAndArg() {
      return new PromiseImpl(function (resolve, reject) {
        invoke(method, arg, resolve, reject);
      });
    }

    return previousPromise = // If enqueue has been called before, then we want to wait until
    // all previous Promises have been resolved before calling invoke,
    // so that results are always delivered in the correct order. If
    // enqueue has not been called before, then it is important to
    // call invoke immediately, without waiting on a callback to fire,
    // so that the async generator function has the opportunity to do
    // any necessary setup in a predictable way. This predictability
    // is why the Promise constructor synchronously invokes its
    // executor callback, and why async functions synchronously
    // execute code before the first await. Since we implement simple
    // async functions in terms of async generators, it is especially
    // important to get this right, even though it requires care.
    previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
    // invocations of the iterator.
    callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
  } // Define the unified helper method that is used to implement .next,
  // .throw, and .return (see defineIteratorMethods).


  this._invoke = enqueue;
}

defineIteratorMethods(AsyncIterator.prototype);

AsyncIterator.prototype[asyncIteratorSymbol] = function () {
  return this;
}; // Note that simple async functions are implemented on top of
// AsyncIterator objects; they just return a Promise for the value of
// the final result produced by the iterator.


function async(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
  if (PromiseImpl === void 0) PromiseImpl = Promise;
  var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
  return isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
  : iter.next().then(function (result) {
    return result.done ? result.value : iter.next();
  });
}

function makeInvokeMethod(innerFn, self, context) {
  var state = GenStateSuspendedStart;
  return function invoke(method, arg) {
    if (state === GenStateExecuting) {
      throw new Error("Generator is already running");
    }

    if (state === GenStateCompleted) {
      if (method === "throw") {
        throw arg;
      } // Be forgiving, per 25.3.3.3.3 of the spec:
      // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


      return doneResult();
    }

    context.method = method;
    context.arg = arg;

    while (true) {
      var delegate = context.delegate;

      if (delegate) {
        var delegateResult = maybeInvokeDelegate(delegate, context);

        if (delegateResult) {
          if (delegateResult === ContinueSentinel) continue;
          return delegateResult;
        }
      }

      if (context.method === "next") {
        // Setting context._sent for legacy support of Babel's
        // function.sent implementation.
        context.sent = context._sent = context.arg;
      } else if (context.method === "throw") {
        if (state === GenStateSuspendedStart) {
          state = GenStateCompleted;
          throw context.arg;
        }

        context.dispatchException(context.arg);
      } else if (context.method === "return") {
        context.abrupt("return", context.arg);
      }

      state = GenStateExecuting;
      var record = tryCatch(innerFn, self, context);

      if (record.type === "normal") {
        // If an exception is thrown from innerFn, we leave state ===
        // GenStateExecuting and loop back for another invocation.
        state = context.done ? GenStateCompleted : GenStateSuspendedYield;

        if (record.arg === ContinueSentinel) {
          continue;
        }

        return {
          value: record.arg,
          done: context.done
        };
      } else if (record.type === "throw") {
        state = GenStateCompleted; // Dispatch the exception by looping back around to the
        // context.dispatchException(context.arg) call above.

        context.method = "throw";
        context.arg = record.arg;
      }
    }
  };
} // Call delegate.iterator[context.method](context.arg) and handle the
// result, either by returning a { value, done } result from the
// delegate iterator, or by modifying context.method and context.arg,
// setting context.delegate to null, and returning the ContinueSentinel.


function maybeInvokeDelegate(delegate, context) {
  var method = delegate.iterator[context.method];

  if (method === undefined$1) {
    // A .throw or .return when the delegate iterator has no .throw
    // method always terminates the yield* loop.
    context.delegate = null;

    if (context.method === "throw") {
      // Note: ["return"] must be used for ES3 parsing compatibility.
      if (delegate.iterator["return"]) {
        // If the delegate iterator has a return method, give it a
        // chance to clean up.
        context.method = "return";
        context.arg = undefined$1;
        maybeInvokeDelegate(delegate, context);

        if (context.method === "throw") {
          // If maybeInvokeDelegate(context) changed context.method from
          // "return" to "throw", let that override the TypeError below.
          return ContinueSentinel;
        }
      }

      context.method = "throw";
      context.arg = new TypeError("The iterator does not provide a 'throw' method");
    }

    return ContinueSentinel;
  }

  var record = tryCatch(method, delegate.iterator, context.arg);

  if (record.type === "throw") {
    context.method = "throw";
    context.arg = record.arg;
    context.delegate = null;
    return ContinueSentinel;
  }

  var info = record.arg;

  if (!info) {
    context.method = "throw";
    context.arg = new TypeError("iterator result is not an object");
    context.delegate = null;
    return ContinueSentinel;
  }

  if (info.done) {
    // Assign the result of the finished delegate to the temporary
    // variable specified by delegate.resultName (see delegateYield).
    context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

    context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
    // exception, let the outer generator proceed normally. If
    // context.method was "next", forget context.arg since it has been
    // "consumed" by the delegate iterator. If context.method was
    // "return", allow the original .return call to continue in the
    // outer generator.

    if (context.method !== "return") {
      context.method = "next";
      context.arg = undefined$1;
    }
  } else {
    // Re-yield the result returned by the delegate method.
    return info;
  } // The delegate iterator is finished, so forget it and continue with
  // the outer generator.


  context.delegate = null;
  return ContinueSentinel;
} // Define Generator.prototype.{next,throw,return} in terms of the
// unified ._invoke helper method.


defineIteratorMethods(Gp);
Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
// @@iterator function is called on it. Some browsers' implementations of the
// iterator prototype chain incorrectly implement this, causing the Generator
// object to not be returned from this call. This ensures that doesn't happen.
// See https://github.com/facebook/regenerator/issues/274 for more details.

Gp[iteratorSymbol] = function () {
  return this;
};

Gp.toString = function () {
  return "[object Generator]";
};

function pushTryEntry(locs) {
  var entry = {
    tryLoc: locs[0]
  };

  if (1 in locs) {
    entry.catchLoc = locs[1];
  }

  if (2 in locs) {
    entry.finallyLoc = locs[2];
    entry.afterLoc = locs[3];
  }

  this.tryEntries.push(entry);
}

function resetTryEntry(entry) {
  var record = entry.completion || {};
  record.type = "normal";
  delete record.arg;
  entry.completion = record;
}

function Context(tryLocsList) {
  // The root entry object (effectively a try statement without a catch
  // or a finally block) gives us a place to store values thrown from
  // locations where there is no enclosing try statement.
  this.tryEntries = [{
    tryLoc: "root"
  }];
  tryLocsList.forEach(pushTryEntry, this);
  this.reset(true);
}

function keys(object) {
  var keys = [];

  for (var key in object) {
    keys.push(key);
  }

  keys.reverse(); // Rather than returning an object with a next method, we keep
  // things simple and return the next function itself.

  return function next() {
    while (keys.length) {
      var key = keys.pop();

      if (key in object) {
        next.value = key;
        next.done = false;
        return next;
      }
    } // To avoid creating an additional object, we just hang the .value
    // and .done properties off the next function object itself. This
    // also ensures that the minifier will not anonymize the function.


    next.done = true;
    return next;
  };
}

function values(iterable) {
  if (iterable) {
    var iteratorMethod = iterable[iteratorSymbol];

    if (iteratorMethod) {
      return iteratorMethod.call(iterable);
    }

    if (typeof iterable.next === "function") {
      return iterable;
    }

    if (!isNaN(iterable.length)) {
      var i = -1,
          next = function next() {
        while (++i < iterable.length) {
          if (hasOwn.call(iterable, i)) {
            next.value = iterable[i];
            next.done = false;
            return next;
          }
        }

        next.value = undefined$1;
        next.done = true;
        return next;
      };

      return next.next = next;
    }
  } // Return an iterator with no values.


  return {
    next: doneResult
  };
}

function doneResult() {
  return {
    value: undefined$1,
    done: true
  };
}

Context.prototype = {
  constructor: Context,
  reset: function reset(skipTempReset) {
    this.prev = 0;
    this.next = 0; // Resetting context._sent for legacy support of Babel's
    // function.sent implementation.

    this.sent = this._sent = undefined$1;
    this.done = false;
    this.delegate = null;
    this.method = "next";
    this.arg = undefined$1;
    this.tryEntries.forEach(resetTryEntry);

    if (!skipTempReset) {
      for (var name in this) {
        // Not sure about the optimal order of these conditions:
        if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
          this[name] = undefined$1;
        }
      }
    }
  },
  stop: function stop() {
    this.done = true;
    var rootEntry = this.tryEntries[0];
    var rootRecord = rootEntry.completion;

    if (rootRecord.type === "throw") {
      throw rootRecord.arg;
    }

    return this.rval;
  },
  dispatchException: function dispatchException(exception) {
    if (this.done) {
      throw exception;
    }

    var context = this;

    function handle(loc, caught) {
      record.type = "throw";
      record.arg = exception;
      context.next = loc;

      if (caught) {
        // If the dispatched exception was caught by a catch block,
        // then let that catch block handle the exception normally.
        context.method = "next";
        context.arg = undefined$1;
      }

      return !!caught;
    }

    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];
      var record = entry.completion;

      if (entry.tryLoc === "root") {
        // Exception thrown outside of any try block that could handle
        // it, so set the completion value of the entire function to
        // throw the exception.
        return handle("end");
      }

      if (entry.tryLoc <= this.prev) {
        var hasCatch = hasOwn.call(entry, "catchLoc");
        var hasFinally = hasOwn.call(entry, "finallyLoc");

        if (hasCatch && hasFinally) {
          if (this.prev < entry.catchLoc) {
            return handle(entry.catchLoc, true);
          } else if (this.prev < entry.finallyLoc) {
            return handle(entry.finallyLoc);
          }
        } else if (hasCatch) {
          if (this.prev < entry.catchLoc) {
            return handle(entry.catchLoc, true);
          }
        } else if (hasFinally) {
          if (this.prev < entry.finallyLoc) {
            return handle(entry.finallyLoc);
          }
        } else {
          throw new Error("try statement without catch or finally");
        }
      }
    }
  },
  abrupt: function abrupt(type, arg) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];

      if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
        var finallyEntry = entry;
        break;
      }
    }

    if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
      // Ignore the finally entry if control is not jumping to a
      // location outside the try/catch block.
      finallyEntry = null;
    }

    var record = finallyEntry ? finallyEntry.completion : {};
    record.type = type;
    record.arg = arg;

    if (finallyEntry) {
      this.method = "next";
      this.next = finallyEntry.finallyLoc;
      return ContinueSentinel;
    }

    return this.complete(record);
  },
  complete: function complete(record, afterLoc) {
    if (record.type === "throw") {
      throw record.arg;
    }

    if (record.type === "break" || record.type === "continue") {
      this.next = record.arg;
    } else if (record.type === "return") {
      this.rval = this.arg = record.arg;
      this.method = "return";
      this.next = "end";
    } else if (record.type === "normal" && afterLoc) {
      this.next = afterLoc;
    }

    return ContinueSentinel;
  },
  finish: function finish(finallyLoc) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];

      if (entry.finallyLoc === finallyLoc) {
        this.complete(entry.completion, entry.afterLoc);
        resetTryEntry(entry);
        return ContinueSentinel;
      }
    }
  },
  "catch": function _catch(tryLoc) {
    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
      var entry = this.tryEntries[i];

      if (entry.tryLoc === tryLoc) {
        var record = entry.completion;

        if (record.type === "throw") {
          var thrown = record.arg;
          resetTryEntry(entry);
        }

        return thrown;
      }
    } // The context.catch method must only be called with a location
    // argument that corresponds to a known catch block.


    throw new Error("illegal catch attempt");
  },
  delegateYield: function delegateYield(iterable, resultName, nextLoc) {
    this.delegate = {
      iterator: values(iterable),
      resultName: resultName,
      nextLoc: nextLoc
    };

    if (this.method === "next") {
      // Deliberately forget the last sent value so that we don't
      // accidentally pass it on to the delegate.
      this.arg = undefined$1;
    }

    return ContinueSentinel;
  }
}; // Export a default namespace that plays well with Rollup

var _regeneratorRuntime = {
  wrap,
  isGeneratorFunction,
  AsyncIterator,
  mark,
  awrap,
  async,
  keys,
  values
};

/**
 * Open editor url in a new window, and pass a message.
 */
function post (window, url, data) {
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var editor = window.open(url);
  var wait = 10000;
  var step = 250;

  var _URL = new URL(url),
      origin = _URL.origin; // eslint-disable-next-line no-bitwise


  var count = ~~(wait / step);

  function listen(evt) {
    if (evt.source === editor) {
      count = 0;
      window.removeEventListener('message', listen, false);
    }
  }

  window.addEventListener('message', listen, false); // send message
  // periodically resend until ack received or timeout

  function send() {
    if (count <= 0) {
      return;
    }

    editor.postMessage(data, origin);
    setTimeout(send, step);
    count -= 1;
  }

  setTimeout(send, step);
}

// generated with build-style.sh
var embedStyle = ".vega-embed {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box; }\n  .vega-embed.has-actions {\n    padding-right: 38px; }\n  .vega-embed details:not([open]) > :not(summary) {\n    display: none !important; }\n  .vega-embed summary {\n    list-style: none;\n    position: absolute;\n    top: 0;\n    right: 0;\n    padding: 6px;\n    z-index: 1000;\n    background: white;\n    box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);\n    color: #1b1e23;\n    border: 1px solid #aaa;\n    border-radius: 999px;\n    opacity: 0.2;\n    transition: opacity 0.4s ease-in;\n    outline: none;\n    cursor: pointer;\n    line-height: 0px; }\n    .vega-embed summary::-webkit-details-marker {\n      display: none; }\n    .vega-embed summary:active {\n      box-shadow: #aaa 0px 0px 0px 1px inset; }\n    .vega-embed summary svg {\n      width: 14px;\n      height: 14px; }\n  .vega-embed details[open] summary {\n    opacity: 0.7; }\n  .vega-embed:hover summary,\n  .vega-embed:focus summary {\n    opacity: 1 !important;\n    transition: opacity 0.2s ease; }\n  .vega-embed .vega-actions {\n    position: absolute;\n    z-index: 1001;\n    top: 35px;\n    right: -9px;\n    display: flex;\n    flex-direction: column;\n    padding-bottom: 8px;\n    padding-top: 8px;\n    border-radius: 4px;\n    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);\n    border: 1px solid #d9d9d9;\n    background: white;\n    animation-duration: 0.15s;\n    animation-name: scale-in;\n    animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);\n    text-align: left; }\n    .vega-embed .vega-actions a {\n      padding: 8px 16px;\n      font-family: sans-serif;\n      font-size: 14px;\n      font-weight: 600;\n      white-space: nowrap;\n      color: #434a56;\n      text-decoration: none; }\n      .vega-embed .vega-actions a:hover {\n        background-color: #f7f7f9;\n        color: black; }\n    .vega-embed .vega-actions::before, .vega-embed .vega-actions::after {\n      content: \"\";\n      display: inline-block;\n      position: absolute; }\n    .vega-embed .vega-actions::before {\n      left: auto;\n      right: 14px;\n      top: -16px;\n      border: 8px solid #0000;\n      border-bottom-color: #d9d9d9; }\n    .vega-embed .vega-actions::after {\n      left: auto;\n      right: 15px;\n      top: -14px;\n      border: 7px solid #0000;\n      border-bottom-color: #fff; }\n  .vega-embed .chart-wrapper.fit-x {\n    width: 100%; }\n  .vega-embed .chart-wrapper.fit-y {\n    height: 100%; }\n\n.vega-embed-wrapper {\n  max-width: 100%;\n  overflow: auto;\n  padding-right: 14px; }\n\n@keyframes scale-in {\n  from {\n    opacity: 0;\n    transform: scale(0.6); }\n  to {\n    opacity: 1;\n    transform: scale(1); } }\n";

if (!String.prototype.startsWith) {
  // eslint-disable-next-line no-extend-native,func-names
  String.prototype.startsWith = function (search, pos) {
    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
}
function mergeDeep(dest) {
  for (var _len = arguments.length, src = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    src[_key - 1] = arguments[_key];
  }

  for (var _i = 0, _src = src; _i < _src.length; _i++) {
    var s = _src[_i];
    deepMerge_(dest, s);
  }

  return dest;
}

function deepMerge_(dest, src) {
  for (var _i2 = 0, _Object$keys = Object.keys(src); _i2 < _Object$keys.length; _i2++) {
    var property = _Object$keys[_i2];
    (0,vega__WEBPACK_IMPORTED_MODULE_3__.writeConfig)(dest, property, src[property], true);
  }
}

var _w$vl;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var vega = vega__WEBPACK_IMPORTED_MODULE_3__;
var _vegaLite = vega_lite__WEBPACK_IMPORTED_MODULE_4__; // For backwards compatibility with Vega-Lite before v4.
var w = typeof window !== 'undefined' ? window : undefined;

if (_vegaLite === undefined && w !== null && w !== void 0 && (_w$vl = w['vl']) !== null && _w$vl !== void 0 && _w$vl.compile) {
  _vegaLite = w['vl'];
}

var DEFAULT_ACTIONS = {
  export: {
    svg: true,
    png: true
  },
  source: true,
  compiled: true,
  editor: true
};
var I18N = {
  CLICK_TO_VIEW_ACTIONS: 'Click to view actions',
  COMPILED_ACTION: 'View Compiled Vega',
  EDITOR_ACTION: 'Open in Vega Editor',
  PNG_ACTION: 'Save as PNG',
  SOURCE_ACTION: 'View Source',
  SVG_ACTION: 'Save as SVG'
};
var NAMES = {
  vega: 'Vega',
  'vega-lite': 'Vega-Lite'
};
var VERSION = {
  vega: vega.version,
  'vega-lite': _vegaLite ? _vegaLite.version : 'not available'
};
var PREPROCESSOR = {
  vega: vgSpec => vgSpec,
  'vega-lite': (vlSpec, config) => _vegaLite.compile(vlSpec, {
    config: config
  }).spec
};
var SVG_CIRCLES = "\n<svg viewBox=\"0 0 16 16\" fill=\"currentColor\" stroke=\"none\" stroke-width=\"1\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <circle r=\"2\" cy=\"8\" cx=\"2\"></circle>\n  <circle r=\"2\" cy=\"8\" cx=\"8\"></circle>\n  <circle r=\"2\" cy=\"8\" cx=\"14\"></circle>\n</svg>";
var CHART_WRAPPER_CLASS = 'chart-wrapper';

function isTooltipHandler(h) {
  return typeof h === 'function';
}

function viewSource(source, sourceHeader, sourceFooter, mode) {
  var header = "<html><head>".concat(sourceHeader, "</head><body><pre><code class=\"json\">");
  var footer = "</code></pre>".concat(sourceFooter, "</body></html>"); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

  var win = window.open('');
  win.document.write(header + source + footer);
  win.document.title = "".concat(NAMES[mode], " JSON Source");
}
/**
 * Try to guess the type of spec.
 *
 * @param spec Vega or Vega-Lite spec.
 */


function guessMode(spec, providedMode) {
  // Decide mode
  if (spec.$schema) {
    var parsed = (0,vega_schema_url_parser__WEBPACK_IMPORTED_MODULE_5__.default)(spec.$schema);

    if (providedMode && providedMode !== parsed.library) {
      var _NAMES$providedMode;

      console.warn("The given visualization spec is written in ".concat(NAMES[parsed.library], ", but mode argument sets ").concat((_NAMES$providedMode = NAMES[providedMode]) !== null && _NAMES$providedMode !== void 0 ? _NAMES$providedMode : providedMode, "."));
    }

    var mode = parsed.library;

    if (!(0,semver__WEBPACK_IMPORTED_MODULE_2__.satisfies)(VERSION[mode], "^".concat(parsed.version.slice(1)))) {
      console.warn("The input spec uses ".concat(NAMES[mode], " ").concat(parsed.version, ", but the current version of ").concat(NAMES[mode], " is v").concat(VERSION[mode], "."));
    }

    return mode;
  } // try to guess from the provided spec


  if ('mark' in spec || 'encoding' in spec || 'layer' in spec || 'hconcat' in spec || 'vconcat' in spec || 'facet' in spec || 'repeat' in spec) {
    return 'vega-lite';
  }

  if ('marks' in spec || 'signals' in spec || 'scales' in spec || 'axes' in spec) {
    return 'vega';
  }

  return providedMode !== null && providedMode !== void 0 ? providedMode : 'vega';
}

function isLoader(o) {
  return !!(o && 'load' in o);
}

function createLoader(opts) {
  return isLoader(opts) ? opts : vega.loader(opts);
}

function embedOptionsFromUsermeta(parsedSpec) {
  var _ref;

  return (_ref = parsedSpec.usermeta && parsedSpec.usermeta['embedOptions']) !== null && _ref !== void 0 ? _ref : {};
}
/**
 * Embed a Vega visualization component in a web page. This function returns a promise.
 *
 * @param el        DOM element in which to place component (DOM node or CSS selector).
 * @param spec      String : A URL string from which to load the Vega specification.
 *                  Object : The Vega/Vega-Lite specification as a parsed JSON object.
 * @param opts       A JavaScript object containing options for embedding.
 */


function embed(_x, _x2) {
  return _embed2.apply(this, arguments);
}

function _embed2() {
  _embed2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(el, spec) {
    var _parsedOpts$config, _usermetaOpts$config;

    var opts,
        parsedSpec,
        loader,
        usermetaLoader,
        _opts$loader,
        usermetaOpts,
        parsedOpts,
        mergedOpts,
        _args = arguments;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};

            if (!(0,vega__WEBPACK_IMPORTED_MODULE_3__.isString)(spec)) {
              _context.next = 10;
              break;
            }

            loader = createLoader(opts.loader);
            _context.t0 = JSON;
            _context.next = 6;
            return loader.load(spec);

          case 6:
            _context.t1 = _context.sent;
            parsedSpec = _context.t0.parse.call(_context.t0, _context.t1);
            _context.next = 11;
            break;

          case 10:
            parsedSpec = spec;

          case 11:
            usermetaLoader = embedOptionsFromUsermeta(parsedSpec).loader; // either create the loader for the first time or create a new loader if the spec has new loader options

            if (!loader || usermetaLoader) {
              loader = createLoader((_opts$loader = opts.loader) !== null && _opts$loader !== void 0 ? _opts$loader : usermetaLoader);
            }

            _context.next = 15;
            return loadOpts(embedOptionsFromUsermeta(parsedSpec), loader);

          case 15:
            usermetaOpts = _context.sent;
            _context.next = 18;
            return loadOpts(opts, loader);

          case 18:
            parsedOpts = _context.sent;
            mergedOpts = _objectSpread(_objectSpread({}, mergeDeep(parsedOpts, usermetaOpts)), {}, {
              config: (0,vega__WEBPACK_IMPORTED_MODULE_3__.mergeConfig)((_parsedOpts$config = parsedOpts.config) !== null && _parsedOpts$config !== void 0 ? _parsedOpts$config : {}, (_usermetaOpts$config = usermetaOpts.config) !== null && _usermetaOpts$config !== void 0 ? _usermetaOpts$config : {})
            });
            _context.next = 22;
            return _embed(el, parsedSpec, mergedOpts, loader);

          case 22:
            return _context.abrupt("return", _context.sent);

          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _embed2.apply(this, arguments);
}

function loadOpts(_x3, _x4) {
  return _loadOpts.apply(this, arguments);
}

function _loadOpts() {
  _loadOpts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(opt, loader) {
    var _opt$config;

    var config, patch;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(0,vega__WEBPACK_IMPORTED_MODULE_3__.isString)(opt.config)) {
              _context2.next = 8;
              break;
            }

            _context2.t1 = JSON;
            _context2.next = 4;
            return loader.load(opt.config);

          case 4:
            _context2.t2 = _context2.sent;
            _context2.t0 = _context2.t1.parse.call(_context2.t1, _context2.t2);
            _context2.next = 9;
            break;

          case 8:
            _context2.t0 = (_opt$config = opt.config) !== null && _opt$config !== void 0 ? _opt$config : {};

          case 9:
            config = _context2.t0;

            if (!(0,vega__WEBPACK_IMPORTED_MODULE_3__.isString)(opt.patch)) {
              _context2.next = 18;
              break;
            }

            _context2.t4 = JSON;
            _context2.next = 14;
            return loader.load(opt.patch);

          case 14:
            _context2.t5 = _context2.sent;
            _context2.t3 = _context2.t4.parse.call(_context2.t4, _context2.t5);
            _context2.next = 19;
            break;

          case 18:
            _context2.t3 = opt.patch;

          case 19:
            patch = _context2.t3;
            return _context2.abrupt("return", _objectSpread(_objectSpread(_objectSpread({}, opt), patch ? {
              patch
            } : {}), config ? {
              config
            } : {}));

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadOpts.apply(this, arguments);
}

function getRoot(el) {
  var possibleRoot = el.getRootNode ? el.getRootNode() : document;

  if (possibleRoot instanceof ShadowRoot) {
    return {
      root: possibleRoot,
      rootContainer: possibleRoot
    };
  } else {
    var _document$head;

    return {
      root: document,
      rootContainer: (_document$head = document.head) !== null && _document$head !== void 0 ? _document$head : document.body
    };
  }
}

function _embed(_x5, _x6) {
  return _embed3.apply(this, arguments);
}

function _embed3() {
  _embed3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(el, spec) {
    var _opts$config, _opts$actions, _opts$renderer, _opts$logLevel, _opts$downloadFileNam;

    var opts,
        loader,
        config,
        actions,
        i18n,
        renderer,
        logLevel,
        downloadFileName,
        element,
        ID,
        _getRoot,
        root,
        rootContainer,
        style,
        mode,
        vgSpec,
        parsed,
        container,
        chartWrapper,
        patch,
        ast,
        runtime,
        view,
        handler,
        hover,
        _ref2,
        hoverSet,
        updateSet,
        documentClickHandler,
        wrapper,
        details,
        summary,
        ctrl,
        _loop,
        _i,
        _arr,
        viewSourceLink,
        compileLink,
        _opts$editorUrl,
        editorUrl,
        editorLink,
        finalize,
        _args4 = arguments;

    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            finalize = function _finalize() {
              if (documentClickHandler) {
                document.removeEventListener('click', documentClickHandler);
              }

              view.finalize();
            };

            opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
            loader = _args4.length > 3 ? _args4[3] : undefined;
            config = opts.theme ? (0,vega__WEBPACK_IMPORTED_MODULE_3__.mergeConfig)(vega_themes__WEBPACK_IMPORTED_MODULE_6__[opts.theme], (_opts$config = opts.config) !== null && _opts$config !== void 0 ? _opts$config : {}) : opts.config;
            actions = (0,vega__WEBPACK_IMPORTED_MODULE_3__.isBoolean)(opts.actions) ? opts.actions : mergeDeep({}, DEFAULT_ACTIONS, (_opts$actions = opts.actions) !== null && _opts$actions !== void 0 ? _opts$actions : {});
            i18n = _objectSpread(_objectSpread({}, I18N), opts.i18n);
            renderer = (_opts$renderer = opts.renderer) !== null && _opts$renderer !== void 0 ? _opts$renderer : 'canvas';
            logLevel = (_opts$logLevel = opts.logLevel) !== null && _opts$logLevel !== void 0 ? _opts$logLevel : vega.Warn;
            downloadFileName = (_opts$downloadFileNam = opts.downloadFileName) !== null && _opts$downloadFileNam !== void 0 ? _opts$downloadFileNam : 'visualization';
            element = typeof el === 'string' ? document.querySelector(el) : el;

            if (element) {
              _context4.next = 12;
              break;
            }

            throw new Error("".concat(el, " does not exist"));

          case 12:
            if (opts.defaultStyle !== false) {
              // Add a default stylesheet to the head of the document.
              ID = 'vega-embed-style';
              _getRoot = getRoot(element), root = _getRoot.root, rootContainer = _getRoot.rootContainer;

              if (!root.getElementById(ID)) {
                style = document.createElement('style');
                style.id = ID;
                style.innerText = opts.defaultStyle === undefined || opts.defaultStyle === true ? (embedStyle ).toString() : opts.defaultStyle;
                rootContainer.appendChild(style);
              }
            }

            mode = guessMode(spec, opts.mode);
            vgSpec = PREPROCESSOR[mode](spec, config);

            if (mode === 'vega-lite') {
              if (vgSpec.$schema) {
                parsed = (0,vega_schema_url_parser__WEBPACK_IMPORTED_MODULE_5__.default)(vgSpec.$schema);

                if (!(0,semver__WEBPACK_IMPORTED_MODULE_2__.satisfies)(VERSION.vega, "^".concat(parsed.version.slice(1)))) {
                  console.warn("The compiled spec uses Vega ".concat(parsed.version, ", but current version is v").concat(VERSION.vega, "."));
                }
              }
            }

            element.classList.add('vega-embed');

            if (actions) {
              element.classList.add('has-actions');
            }

            element.innerHTML = ''; // clear container

            container = element;

            if (actions) {
              chartWrapper = document.createElement('div');
              chartWrapper.classList.add(CHART_WRAPPER_CLASS);
              element.appendChild(chartWrapper);
              container = chartWrapper;
            }

            patch = opts.patch;

            if (patch) {
              if (patch instanceof Function) {
                vgSpec = patch(vgSpec);
              } else {
                vgSpec = (0,fast_json_patch__WEBPACK_IMPORTED_MODULE_0__.applyPatch)(vgSpec, patch, true, false).newDocument;
              }
            } // Set locale. Note that this is a global setting.


            if (opts.formatLocale) {
              vega.formatLocale(opts.formatLocale);
            }

            if (opts.timeFormatLocale) {
              vega.timeFormatLocale(opts.timeFormatLocale);
            }

            ast = opts.ast; // Do not apply the config to Vega when we have already applied it to Vega-Lite.
            // This call may throw an Error if parsing fails.

            runtime = vega.parse(vgSpec, mode === 'vega-lite' ? {} : config, {
              ast
            });
            view = new (opts.viewClass || vega.View)(runtime, _objectSpread({
              loader,
              logLevel,
              renderer
            }, ast ? {
              expr: vega.expressionInterpreter
            } : {}));
            view.addSignalListener('autosize', (_, autosize) => {
              var type = autosize.type;

              if (type == 'fit-x') {
                container.classList.add('fit-x');
                container.classList.remove('fit-y');
              } else if (type == 'fit-y') {
                container.classList.remove('fit-x');
                container.classList.add('fit-y');
              } else if (type == 'fit') {
                container.classList.add('fit-x', 'fit-y');
              } else {
                container.classList.remove('fit-x', 'fit-y');
              }
            });

            if (opts.tooltip !== false) {
              if (isTooltipHandler(opts.tooltip)) {
                handler = opts.tooltip;
              } else {
                // user provided boolean true or tooltip options
                handler = new vega_tooltip__WEBPACK_IMPORTED_MODULE_7__.Handler(opts.tooltip === true ? {} : opts.tooltip).call;
              }

              view.tooltip(handler);
            }

            hover = opts.hover;

            if (hover === undefined) {
              hover = mode === 'vega';
            }

            if (hover) {
              _ref2 = typeof hover === 'boolean' ? {} : hover, hoverSet = _ref2.hoverSet, updateSet = _ref2.updateSet;
              view.hover(hoverSet, updateSet);
            }

            if (opts) {
              if (opts.width != null) {
                view.width(opts.width);
              }

              if (opts.height != null) {
                view.height(opts.height);
              }

              if (opts.padding != null) {
                view.padding(opts.padding);
              }
            }

            _context4.next = 36;
            return view.initialize(container, opts.bind).runAsync();

          case 36:
            if (actions !== false) {
              wrapper = element;

              if (opts.defaultStyle !== false) {
                details = document.createElement('details');
                details.title = i18n.CLICK_TO_VIEW_ACTIONS;
                element.append(details);
                wrapper = details;
                summary = document.createElement('summary');
                summary.innerHTML = SVG_CIRCLES;
                details.append(summary);

                documentClickHandler = ev => {
                  if (!details.contains(ev.target)) {
                    details.removeAttribute('open');
                  }
                };

                document.addEventListener('click', documentClickHandler);
              }

              ctrl = document.createElement('div');
              wrapper.append(ctrl);
              ctrl.classList.add('vega-actions'); // add 'Export' action

              if (actions === true || actions.export !== false) {
                _loop = function _loop() {
                  var ext = _arr[_i];

                  if (actions === true || actions.export === true || actions.export[ext]) {
                    var i18nExportAction = i18n["".concat(ext.toUpperCase(), "_ACTION")];
                    var exportLink = document.createElement('a');
                    exportLink.text = i18nExportAction;
                    exportLink.href = '#';
                    exportLink.target = '_blank';
                    exportLink.download = "".concat(downloadFileName, ".").concat(ext); // add link on mousedown so that it's correct when the click happens

                    exportLink.addEventListener('mousedown', /*#__PURE__*/function () {
                      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(e) {
                        var url;
                        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                e.preventDefault();
                                _context3.next = 3;
                                return view.toImageURL(ext, opts.scaleFactor);

                              case 3:
                                url = _context3.sent;
                                this.href = url;

                              case 5:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _callee3, this);
                      }));

                      return function (_x7) {
                        return _ref3.apply(this, arguments);
                      };
                    }());
                    ctrl.append(exportLink);
                  }
                };

                for (_i = 0, _arr = ['svg', 'png']; _i < _arr.length; _i++) {
                  _loop();
                }
              } // add 'View Source' action


              if (actions === true || actions.source !== false) {
                viewSourceLink = document.createElement('a');
                viewSourceLink.text = i18n.SOURCE_ACTION;
                viewSourceLink.href = '#';
                viewSourceLink.addEventListener('click', function (e) {
                  var _opts$sourceHeader, _opts$sourceFooter;

                  viewSource(json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1___default()(spec), (_opts$sourceHeader = opts.sourceHeader) !== null && _opts$sourceHeader !== void 0 ? _opts$sourceHeader : '', (_opts$sourceFooter = opts.sourceFooter) !== null && _opts$sourceFooter !== void 0 ? _opts$sourceFooter : '', mode);
                  e.preventDefault();
                });
                ctrl.append(viewSourceLink);
              } // add 'View Compiled' action


              if (mode === 'vega-lite' && (actions === true || actions.compiled !== false)) {
                compileLink = document.createElement('a');
                compileLink.text = i18n.COMPILED_ACTION;
                compileLink.href = '#';
                compileLink.addEventListener('click', function (e) {
                  var _opts$sourceHeader2, _opts$sourceFooter2;

                  viewSource(json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1___default()(vgSpec), (_opts$sourceHeader2 = opts.sourceHeader) !== null && _opts$sourceHeader2 !== void 0 ? _opts$sourceHeader2 : '', (_opts$sourceFooter2 = opts.sourceFooter) !== null && _opts$sourceFooter2 !== void 0 ? _opts$sourceFooter2 : '', 'vega');
                  e.preventDefault();
                });
                ctrl.append(compileLink);
              } // add 'Open in Vega Editor' action


              if (actions === true || actions.editor !== false) {
                editorUrl = (_opts$editorUrl = opts.editorUrl) !== null && _opts$editorUrl !== void 0 ? _opts$editorUrl : 'https://vega.github.io/editor/';
                editorLink = document.createElement('a');
                editorLink.text = i18n.EDITOR_ACTION;
                editorLink.href = '#';
                editorLink.addEventListener('click', function (e) {
                  post(window, editorUrl, {
                    config: config,
                    mode,
                    renderer,
                    spec: json_stringify_pretty_compact__WEBPACK_IMPORTED_MODULE_1___default()(spec)
                  });
                  e.preventDefault();
                });
                ctrl.append(editorLink);
              }
            }

            return _context4.abrupt("return", {
              view,
              spec,
              vgSpec,
              finalize
            });

          case 38:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _embed3.apply(this, arguments);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (embed);

//# sourceMappingURL=vega-embed.module.js.map


/***/ }),

/***/ "./node_modules/vega-schema-url-parser/dist/parser.module.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vega-schema-url-parser/dist/parser.module.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function e(e){const[n,r]=/schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e).slice(1,3);return{library:n,version:r}}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (e);
//# sourceMappingURL=parser.module.js.map


/***/ }),

/***/ "./node_modules/vega-themes/build/vega-themes.module.js":
/*!**************************************************************!*\
  !*** ./node_modules/vega-themes/build/vega-themes.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dark": () => (/* binding */ darkTheme),
/* harmony export */   "excel": () => (/* binding */ excelTheme),
/* harmony export */   "fivethirtyeight": () => (/* binding */ fiveThirtyEightTheme),
/* harmony export */   "ggplot2": () => (/* binding */ ggplot2Theme),
/* harmony export */   "googlecharts": () => (/* binding */ googlechartsTheme),
/* harmony export */   "latimes": () => (/* binding */ latimesTheme),
/* harmony export */   "quartz": () => (/* binding */ quartzTheme),
/* harmony export */   "urbaninstitute": () => (/* binding */ urbanInstituteTheme),
/* harmony export */   "version": () => (/* binding */ version$1),
/* harmony export */   "vox": () => (/* binding */ voxTheme)
/* harmony export */ });
var name = "vega-themes";
var version = "2.10.0";
var description = "Themes for stylized Vega and Vega-Lite visualizations.";
var keywords = [
	"vega",
	"vega-lite",
	"themes",
	"style"
];
var license = "BSD-3-Clause";
var author = {
	name: "UW Interactive Data Lab",
	url: "https://idl.cs.washington.edu"
};
var contributors = [
	{
		name: "Emily Gu",
		url: "https://github.com/emilygu"
	},
	{
		name: "Arvind Satyanarayan",
		url: "http://arvindsatya.com"
	},
	{
		name: "Jeffrey Heer",
		url: "https://idl.cs.washington.edu"
	},
	{
		name: "Dominik Moritz",
		url: "https://www.domoritz.de"
	}
];
var main = "build/vega-themes.js";
var module = "build/vega-themes.module.js";
var unpkg = "build/vega-themes.min.js";
var jsdelivr = "build/vega-themes.min.js";
var types = "build/vega-themes.module.d.ts";
var repository = {
	type: "git",
	url: "https://github.com/vega/vega-themes.git"
};
var files = [
	"src",
	"build"
];
var scripts = {
	prebuild: "yarn clean",
	build: "rollup -c",
	clean: "rimraf build && rimraf examples/build",
	"copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
	"copy:build": "rsync -r build/* examples/build",
	"deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
	prepublishOnly: "yarn clean && yarn build",
	preversion: "yarn lint",
	serve: "browser-sync start -s -f build examples --serveStatic examples",
	start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
	prepare: "beemo create-config",
	eslintbase: "beemo eslint .",
	format: "yarn eslintbase --fix",
	lint: "yarn eslintbase"
};
var devDependencies = {
	"@rollup/plugin-json": "^4.1.0",
	"@rollup/plugin-node-resolve": "^11.2.0",
	"@wessberg/rollup-plugin-ts": "^1.3.8",
	"browser-sync": "^2.26.14",
	concurrently: "^6.0.0",
	"gh-pages": "^3.1.0",
	rollup: "^2.39.1",
	"rollup-plugin-bundle-size": "^1.0.3",
	"rollup-plugin-terser": "^7.0.2",
	typescript: "^4.2.2",
	vega: "^5.19.1",
	"vega-lite": "^5.0.0",
	"vega-lite-dev-config": "^0.16.1"
};
var peerDependencies = {
	vega: "*",
	"vega-lite": "*"
};
var pkg = {
	name: name,
	version: version,
	description: description,
	keywords: keywords,
	license: license,
	author: author,
	contributors: contributors,
	main: main,
	module: module,
	unpkg: unpkg,
	jsdelivr: jsdelivr,
	types: types,
	repository: repository,
	files: files,
	scripts: scripts,
	devDependencies: devDependencies,
	peerDependencies: peerDependencies
};

const lightColor = '#fff';
const medColor = '#888';
const darkTheme = {
    background: '#333',
    title: {
        color: lightColor,
        subtitleColor: lightColor
    },
    style: {
        'guide-label': {
            fill: lightColor,
        },
        'guide-title': {
            fill: lightColor,
        },
    },
    axis: {
        domainColor: lightColor,
        gridColor: medColor,
        tickColor: lightColor,
    },
};

const markColor = '#4572a7';
const excelTheme = {
    background: '#fff',
    arc: { fill: markColor },
    area: { fill: markColor },
    line: { stroke: markColor, strokeWidth: 2 },
    path: { stroke: markColor },
    rect: { fill: markColor },
    shape: { stroke: markColor },
    symbol: { fill: markColor, strokeWidth: 1.5, size: 50 },
    axis: {
        bandPosition: 0.5,
        grid: true,
        gridColor: '#000000',
        gridOpacity: 1,
        gridWidth: 0.5,
        labelPadding: 10,
        tickSize: 5,
        tickWidth: 0.5,
    },
    axisBand: {
        grid: false,
        tickExtra: true,
    },
    legend: {
        labelBaseline: 'middle',
        labelFontSize: 11,
        symbolSize: 50,
        symbolType: 'square',
    },
    range: {
        category: [
            '#4572a7',
            '#aa4643',
            '#8aa453',
            '#71598e',
            '#4598ae',
            '#d98445',
            '#94aace',
            '#d09393',
            '#b9cc98',
            '#a99cbc',
        ],
    },
};

const markColor$1 = '#30a2da';
const axisColor = '#cbcbcb';
const guideLabelColor = '#999';
const guideTitleColor = '#333';
const backgroundColor = '#f0f0f0';
const blackTitle = '#333';
const fiveThirtyEightTheme = {
    arc: { fill: markColor$1 },
    area: { fill: markColor$1 },
    axis: {
        domainColor: axisColor,
        grid: true,
        gridColor: axisColor,
        gridWidth: 1,
        labelColor: guideLabelColor,
        labelFontSize: 10,
        titleColor: guideTitleColor,
        tickColor: axisColor,
        tickSize: 10,
        titleFontSize: 14,
        titlePadding: 10,
        labelPadding: 4,
    },
    axisBand: {
        grid: false,
    },
    background: backgroundColor,
    group: {
        fill: backgroundColor,
    },
    legend: {
        labelColor: blackTitle,
        labelFontSize: 11,
        padding: 1,
        symbolSize: 30,
        symbolType: 'square',
        titleColor: blackTitle,
        titleFontSize: 14,
        titlePadding: 10,
    },
    line: {
        stroke: markColor$1,
        strokeWidth: 2,
    },
    path: { stroke: markColor$1, strokeWidth: 0.5 },
    rect: { fill: markColor$1 },
    range: {
        category: [
            '#30a2da',
            '#fc4f30',
            '#e5ae38',
            '#6d904f',
            '#8b8b8b',
            '#b96db8',
            '#ff9e27',
            '#56cc60',
            '#52d2ca',
            '#52689e',
            '#545454',
            '#9fe4f8',
        ],
        diverging: ['#cc0020', '#e77866', '#f6e7e1', '#d6e8ed', '#91bfd9', '#1d78b5'],
        heatmap: ['#d6e8ed', '#cee0e5', '#91bfd9', '#549cc6', '#1d78b5'],
    },
    point: {
        filled: true,
        shape: 'circle',
    },
    shape: { stroke: markColor$1 },
    bar: {
        binSpacing: 2,
        fill: markColor$1,
        stroke: null,
    },
    title: {
        anchor: 'start',
        fontSize: 24,
        fontWeight: 600,
        offset: 20,
    },
};

const markColor$2 = '#000';
const ggplot2Theme = {
    group: {
        fill: '#e5e5e5',
    },
    arc: { fill: markColor$2 },
    area: { fill: markColor$2 },
    line: { stroke: markColor$2 },
    path: { stroke: markColor$2 },
    rect: { fill: markColor$2 },
    shape: { stroke: markColor$2 },
    symbol: { fill: markColor$2, size: 40 },
    axis: {
        domain: false,
        grid: true,
        gridColor: '#FFFFFF',
        gridOpacity: 1,
        labelColor: '#7F7F7F',
        labelPadding: 4,
        tickColor: '#7F7F7F',
        tickSize: 5.67,
        titleFontSize: 16,
        titleFontWeight: 'normal',
    },
    legend: {
        labelBaseline: 'middle',
        labelFontSize: 11,
        symbolSize: 40,
    },
    range: {
        category: [
            '#000000',
            '#7F7F7F',
            '#1A1A1A',
            '#999999',
            '#333333',
            '#B0B0B0',
            '#4D4D4D',
            '#C9C9C9',
            '#666666',
            '#DCDCDC',
        ],
    },
};

const headlineFontSize = 22;
const headlineFontWeight = 'normal';
const labelFont = 'Benton Gothic, sans-serif';
const labelFontSize = 11.5;
const labelFontWeight = 'normal';
const markColor$3 = '#82c6df';
// const markHighlight = '#006d8f';
// const markDemocrat = '#5789b8';
// const markRepublican = '#d94f54';
const titleFont = 'Benton Gothic Bold, sans-serif';
const titleFontWeight = 'normal';
const titleFontSize = 13;
const colorSchemes = {
    'category-6': ['#ec8431', '#829eb1', '#c89d29', '#3580b1', '#adc839', '#ab7fb4'],
    'fire-7': ['#fbf2c7', '#f9e39c', '#f8d36e', '#f4bb6a', '#e68a4f', '#d15a40', '#ab4232'],
    'fireandice-6': ['#e68a4f', '#f4bb6a', '#f9e39c', '#dadfe2', '#a6b7c6', '#849eae'],
    'ice-7': ['#edefee', '#dadfe2', '#c4ccd2', '#a6b7c6', '#849eae', '#607785', '#47525d'],
};
const latimesTheme = {
    background: '#ffffff',
    title: {
        anchor: 'start',
        color: '#000000',
        font: titleFont,
        fontSize: headlineFontSize,
        fontWeight: headlineFontWeight,
    },
    arc: { fill: markColor$3 },
    area: { fill: markColor$3 },
    line: { stroke: markColor$3, strokeWidth: 2 },
    path: { stroke: markColor$3 },
    rect: { fill: markColor$3 },
    shape: { stroke: markColor$3 },
    symbol: { fill: markColor$3, size: 30 },
    axis: {
        labelFont,
        labelFontSize,
        labelFontWeight,
        titleFont,
        titleFontSize,
        titleFontWeight,
    },
    axisX: {
        labelAngle: 0,
        labelPadding: 4,
        tickSize: 3,
    },
    axisY: {
        labelBaseline: 'middle',
        maxExtent: 45,
        minExtent: 45,
        tickSize: 2,
        titleAlign: 'left',
        titleAngle: 0,
        titleX: -45,
        titleY: -11,
    },
    legend: {
        labelFont,
        labelFontSize,
        symbolType: 'square',
        titleFont,
        titleFontSize,
        titleFontWeight,
    },
    range: {
        category: colorSchemes['category-6'],
        diverging: colorSchemes['fireandice-6'],
        heatmap: colorSchemes['fire-7'],
        ordinal: colorSchemes['fire-7'],
        ramp: colorSchemes['fire-7'],
    },
};

const markColor$4 = '#ab5787';
const axisColor$1 = '#979797';
const quartzTheme = {
    background: '#f9f9f9',
    arc: { fill: markColor$4 },
    area: { fill: markColor$4 },
    line: { stroke: markColor$4 },
    path: { stroke: markColor$4 },
    rect: { fill: markColor$4 },
    shape: { stroke: markColor$4 },
    symbol: { fill: markColor$4, size: 30 },
    axis: {
        domainColor: axisColor$1,
        domainWidth: 0.5,
        gridWidth: 0.2,
        labelColor: axisColor$1,
        tickColor: axisColor$1,
        tickWidth: 0.2,
        titleColor: axisColor$1,
    },
    axisBand: {
        grid: false,
    },
    axisX: {
        grid: true,
        tickSize: 10,
    },
    axisY: {
        domain: false,
        grid: true,
        tickSize: 0,
    },
    legend: {
        labelFontSize: 11,
        padding: 1,
        symbolSize: 30,
        symbolType: 'square',
    },
    range: {
        category: [
            '#ab5787',
            '#51b2e5',
            '#703c5c',
            '#168dd9',
            '#d190b6',
            '#00609f',
            '#d365ba',
            '#154866',
            '#666666',
            '#c4c4c4',
        ],
    },
};

const markColor$5 = '#3e5c69';
const voxTheme = {
    background: '#fff',
    arc: { fill: markColor$5 },
    area: { fill: markColor$5 },
    line: { stroke: markColor$5 },
    path: { stroke: markColor$5 },
    rect: { fill: markColor$5 },
    shape: { stroke: markColor$5 },
    symbol: { fill: markColor$5 },
    axis: {
        domainWidth: 0.5,
        grid: true,
        labelPadding: 2,
        tickSize: 5,
        tickWidth: 0.5,
        titleFontWeight: 'normal',
    },
    axisBand: {
        grid: false,
    },
    axisX: {
        gridWidth: 0.2,
    },
    axisY: {
        gridDash: [3],
        gridWidth: 0.4,
    },
    legend: {
        labelFontSize: 11,
        padding: 1,
        symbolType: 'square',
    },
    range: {
        category: ['#3e5c69', '#6793a6', '#182429', '#0570b0', '#3690c0', '#74a9cf', '#a6bddb', '#e2ddf2'],
    },
};

const markColor$6 = '#1696d2';
const axisColor$2 = '#000000';
const backgroundColor$1 = '#FFFFFF';
const font = 'Lato';
const labelFont$1 = 'Lato';
const sourceFont = 'Lato';
const gridColor = '#DEDDDD';
const titleFontSize$1 = 18;
const colorSchemes$1 = {
    'main-colors': ['#1696d2', '#d2d2d2', '#000000', '#fdbf11', '#ec008b', '#55b748', '#5c5859', '#db2b27'],
    'shades-blue': ['#CFE8F3', '#A2D4EC', '#73BFE2', '#46ABDB', '#1696D2', '#12719E', '#0A4C6A', '#062635'],
    'shades-gray': ['#F5F5F5', '#ECECEC', '#E3E3E3', '#DCDBDB', '#D2D2D2', '#9D9D9D', '#696969', '#353535'],
    'shades-yellow': ['#FFF2CF', '#FCE39E', '#FDD870', '#FCCB41', '#FDBF11', '#E88E2D', '#CA5800', '#843215'],
    'shades-magenta': ['#F5CBDF', '#EB99C2', '#E46AA7', '#E54096', '#EC008B', '#AF1F6B', '#761548', '#351123'],
    'shades-green': ['#DCEDD9', '#BCDEB4', '#98CF90', '#78C26D', '#55B748', '#408941', '#2C5C2D', '#1A2E19'],
    'shades-black': ['#D5D5D4', '#ADABAC', '#848081', '#5C5859', '#332D2F', '#262223', '#1A1717', '#0E0C0D'],
    'shades-red': ['#F8D5D4', '#F1AAA9', '#E9807D', '#E25552', '#DB2B27', '#A4201D', '#6E1614', '#370B0A'],
    'one-group': ['#1696d2', '#000000'],
    'two-groups-cat-1': ['#1696d2', '#000000'],
    'two-groups-cat-2': ['#1696d2', '#fdbf11'],
    'two-groups-cat-3': ['#1696d2', '#db2b27'],
    'two-groups-seq': ['#a2d4ec', '#1696d2'],
    'three-groups-cat': ['#1696d2', '#fdbf11', '#000000'],
    'three-groups-seq': ['#a2d4ec', '#1696d2', '#0a4c6a'],
    'four-groups-cat-1': ['#000000', '#d2d2d2', '#fdbf11', '#1696d2'],
    'four-groups-cat-2': ['#1696d2', '#ec0008b', '#fdbf11', '#5c5859'],
    'four-groups-seq': ['#cfe8f3', '#73bf42', '#1696d2', '#0a4c6a'],
    'five-groups-cat-1': ['#1696d2', '#fdbf11', '#d2d2d2', '#ec008b', '#000000'],
    'five-groups-cat-2': ['#1696d2', '#0a4c6a', '#d2d2d2', '#fdbf11', '#332d2f'],
    'five-groups-seq': ['#cfe8f3', '#73bf42', '#1696d2', '#0a4c6a', '#000000'],
    'six-groups-cat-1': ['#1696d2', '#ec008b', '#fdbf11', '#000000', '#d2d2d2', '#55b748'],
    'six-groups-cat-2': ['#1696d2', '#d2d2d2', '#ec008b', '#fdbf11', '#332d2f', '#0a4c6a'],
    'six-groups-seq': ['#cfe8f3', '#a2d4ec', '#73bfe2', '#46abdb', '#1696d2', '#12719e'],
    'diverging-colors': ['#ca5800', '#fdbf11', '#fdd870', '#fff2cf', '#cfe8f3', '#73bfe2', '#1696d2', '#0a4c6a'],
};
const urbanInstituteTheme = {
    background: backgroundColor$1,
    title: {
        anchor: 'start',
        fontSize: titleFontSize$1,
        font: font,
    },
    axisX: {
        domain: true,
        domainColor: axisColor$2,
        domainWidth: 1,
        grid: false,
        labelFontSize: 12,
        labelFont: labelFont$1,
        labelAngle: 0,
        tickColor: axisColor$2,
        tickSize: 5,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font,
    },
    axisY: {
        domain: false,
        domainWidth: 1,
        grid: true,
        gridColor: gridColor,
        gridWidth: 1,
        labelFontSize: 12,
        labelFont: labelFont$1,
        labelPadding: 8,
        ticks: false,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font,
        titleAngle: 0,
        titleY: -10,
        titleX: 18,
    },
    legend: {
        labelFontSize: 12,
        labelFont: labelFont$1,
        symbolSize: 100,
        titleFontSize: 12,
        titlePadding: 10,
        titleFont: font,
        orient: 'right',
        offset: 10,
    },
    view: {
        stroke: 'transparent',
    },
    range: {
        category: colorSchemes$1['six-groups-cat-1'],
        diverging: colorSchemes$1['diverging-colors'],
        heatmap: colorSchemes$1['diverging-colors'],
        ordinal: colorSchemes$1['six-groups-seq'],
        ramp: colorSchemes$1['shades-blue'],
    },
    area: {
        fill: markColor$6,
    },
    rect: {
        fill: markColor$6,
    },
    line: {
        color: markColor$6,
        stroke: markColor$6,
        strokeWidth: 5,
    },
    trail: {
        color: markColor$6,
        stroke: markColor$6,
        strokeWidth: 0,
        size: 1,
    },
    path: {
        stroke: markColor$6,
        strokeWidth: 0.5,
    },
    point: {
        filled: true,
    },
    text: {
        font: sourceFont,
        color: markColor$6,
        fontSize: 11,
        align: 'center',
        fontWeight: 400,
        size: 11,
    },
    style: {
        bar: {
            fill: markColor$6,
            stroke: null,
        },
    },
    arc: { fill: markColor$6 },
    shape: { stroke: markColor$6 },
    symbol: { fill: markColor$6, size: 30 },
};

/**
 * Copyright 2020 Google LLC.
 *
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file or at
 * https://developers.google.com/open-source/licenses/bsd
 */
const markColor$7 = '#3366CC';
const gridColor$1 = '#ccc';
const defaultFont = 'Arial, sans-serif';
const googlechartsTheme = {
    arc: { fill: markColor$7 },
    area: { fill: markColor$7 },
    path: { stroke: markColor$7 },
    rect: { fill: markColor$7 },
    shape: { stroke: markColor$7 },
    symbol: { stroke: markColor$7 },
    circle: { fill: markColor$7 },
    background: '#fff',
    padding: {
        top: 10,
        right: 10,
        bottom: 10,
        left: 10,
    },
    style: {
        'guide-label': {
            font: defaultFont,
            fontSize: 12,
        },
        'guide-title': {
            font: defaultFont,
            fontSize: 12,
        },
        'group-title': {
            font: defaultFont,
            fontSize: 12,
        },
    },
    title: {
        font: defaultFont,
        fontSize: 14,
        fontWeight: 'bold',
        dy: -3,
        anchor: 'start',
    },
    axis: {
        gridColor: gridColor$1,
        tickColor: gridColor$1,
        domain: false,
        grid: true,
    },
    range: {
        category: [
            '#4285F4',
            '#DB4437',
            '#F4B400',
            '#0F9D58',
            '#AB47BC',
            '#00ACC1',
            '#FF7043',
            '#9E9D24',
            '#5C6BC0',
            '#F06292',
            '#00796B',
            '#C2185B',
        ],
        heatmap: ['#c6dafc', '#5e97f6', '#2a56c6'],
    },
};

const version$1 = pkg.version;




/***/ }),

/***/ "./node_modules/vega-tooltip/build/vega-tooltip.module.js":
/*!****************************************************************!*\
  !*** ./node_modules/vega-tooltip/build/vega-tooltip.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "DEFAULT_OPTIONS": () => (/* binding */ DEFAULT_OPTIONS),
/* harmony export */   "Handler": () => (/* binding */ Handler),
/* harmony export */   "calculatePosition": () => (/* binding */ calculatePosition),
/* harmony export */   "createDefaultStyle": () => (/* binding */ createDefaultStyle),
/* harmony export */   "escapeHTML": () => (/* binding */ escapeHTML),
/* harmony export */   "formatValue": () => (/* binding */ formatValue),
/* harmony export */   "replacer": () => (/* binding */ replacer),
/* harmony export */   "stringify": () => (/* binding */ stringify),
/* harmony export */   "version": () => (/* binding */ version$1)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");


var name = "vega-tooltip";
var version = "0.25.1";
var description = "A tooltip plugin for Vega-Lite and Vega visualizations.";
var keywords = [
	"vega-lite",
	"vega",
	"tooltip"
];
var repository = {
	type: "git",
	url: "https://github.com/vega/vega-tooltip.git"
};
var author = {
	name: "UW Interactive Data Lab",
	url: "https://idl.cs.washington.edu"
};
var collaborators = [
	"Dominik Moritz",
	"Sira Horradarn",
	"Zening Qu",
	"Kanit Wongsuphasawat",
	"Yuri Astrakhan",
	"Jeffrey Heer"
];
var license = "BSD-3-Clause";
var bugs = {
	url: "https://github.com/vega/vega-tooltip/issues"
};
var homepage = "https://github.com/vega/vega-tooltip#readme";
var main = "build/vega-tooltip.js";
var module = "build/vega-tooltip.module.js";
var unpkg = "build/vega-tooltip.min.js";
var jsdelivr = "build/vega-tooltip.min.js";
var types = "build/vega-tooltip.module.d.ts";
var files = [
	"src",
	"build",
	"types"
];
var scripts = {
	prebuild: "yarn clean && yarn build:style",
	build: "rollup -c",
	"build:style": "./build-style.sh",
	clean: "rimraf build && rimraf src/style.ts",
	"copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
	"copy:build": "rsync -r build/* examples/build",
	"deploy:gh": "yarn build && yarn copy:build && gh-pages -d examples && yarn clean",
	prepublishOnly: "yarn clean && yarn build",
	preversion: "yarn lint && yarn test",
	serve: "browser-sync start -s -f build examples --serveStatic examples",
	start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
	pretest: "yarn build:style",
	test: "beemo jest",
	"test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand",
	prepare: "beemo create-config && yarn copy:data",
	prettierbase: "beemo prettier '*.{css,scss,html}'",
	eslintbase: "beemo eslint .",
	format: "yarn eslintbase --fix && yarn prettierbase --write",
	lint: "yarn eslintbase && yarn prettierbase --check"
};
var devDependencies = {
	"@rollup/plugin-json": "^4.1.0",
	"@rollup/plugin-node-resolve": "^11.2.0",
	"@wessberg/rollup-plugin-ts": "^1.3.8",
	"browser-sync": "^2.26.14",
	concurrently: "^6.0.0",
	"gh-pages": "^3.1.0",
	"node-sass": "^5.0.0",
	path: "^0.12.7",
	rollup: "^2.39.1",
	"rollup-plugin-bundle-size": "^1.0.3",
	"rollup-plugin-terser": "^7.0.2",
	typescript: "~4.2.2",
	"vega-datasets": "^2.2.0",
	"vega-lite-dev-config": "^0.16.1",
	"vega-typings": "^0.19.2"
};
var dependencies = {
	"vega-util": "^1.16.0"
};
var pkg = {
	name: name,
	version: version,
	description: description,
	keywords: keywords,
	repository: repository,
	author: author,
	collaborators: collaborators,
	license: license,
	bugs: bugs,
	homepage: homepage,
	main: main,
	module: module,
	unpkg: unpkg,
	jsdelivr: jsdelivr,
	types: types,
	files: files,
	scripts: scripts,
	devDependencies: devDependencies,
	dependencies: dependencies
};

// generated with build-style.sh
var defaultStyle = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black; }
  #vg-tooltip-element.visible {
    visibility: visible; }
  #vg-tooltip-element h2 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 13px; }
  #vg-tooltip-element img {
    max-width: 200px;
    max-height: 200px; }
  #vg-tooltip-element table {
    border-spacing: 0; }
    #vg-tooltip-element table tr {
      border: none; }
      #vg-tooltip-element table tr td {
        overflow: hidden;
        text-overflow: ellipsis;
        padding-top: 2px;
        padding-bottom: 2px; }
        #vg-tooltip-element table tr td.key {
          color: #808080;
          max-width: 150px;
          text-align: right;
          padding-right: 4px; }
        #vg-tooltip-element table tr td.value {
          display: block;
          max-width: 300px;
          max-height: 7em;
          text-align: left; }
  #vg-tooltip-element.dark-theme {
    background-color: rgba(32, 32, 32, 0.9);
    border: 1px solid #f5f5f5;
    color: white; }
    #vg-tooltip-element.dark-theme td.key {
      color: #bfbfbf; }
`;

const EL_ID = 'vg-tooltip-element';
const DEFAULT_OPTIONS = {
    /**
     * X offset.
     */
    offsetX: 10,
    /**
     * Y offset.
     */
    offsetY: 10,
    /**
     * ID of the tooltip element.
     */
    id: EL_ID,
    /**
     * ID of the tooltip CSS style.
     */
    styleId: 'vega-tooltip-style',
    /**
     * The name of the theme. You can use the CSS class called [THEME]-theme to style the tooltips.
     *
     * There are two predefined themes: "light" (default) and "dark".
     */
    theme: 'light',
    /**
     * Do not use the default styles provided by Vega Tooltip. If you enable this option, you need to use your own styles. It is not necessary to disable the default style when using a custom theme.
     */
    disableDefaultStyle: false,
    /**
     * HTML sanitizer function that removes dangerous HTML to prevent XSS.
     *
     * This should be a function from string to string. You may replace it with a formatter such as a markdown formatter.
     */
    sanitize: escapeHTML,
    /**
     * The maximum recursion depth when printing objects in the tooltip.
     */
    maxDepth: 2,
};
/**
 * Escape special HTML characters.
 *
 * @param value A value to convert to string and HTML-escape.
 */
function escapeHTML(value) {
    return String(value).replace(/&/g, '&amp;').replace(/</g, '&lt;');
}
function createDefaultStyle(id) {
    // Just in case this id comes from a user, ensure these is no security issues
    if (!/^[A-Za-z]+[-:.\w]*$/.test(id)) {
        throw new Error('Invalid HTML ID');
    }
    return defaultStyle.toString().replace(EL_ID, id);
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * Format the value to be shown in the tooltip.
 *
 * @param value The value to show in the tooltip.
 * @param valueToHtml Function to convert a single cell value to an HTML string
 */
function formatValue(value, valueToHtml, maxDepth) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
        return `[${value.map((v) => valueToHtml((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(v) ? v : stringify(v, maxDepth))).join(', ')}]`;
    }
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {
        let content = '';
        const _a = value, { title, image } = _a, rest = __rest(_a, ["title", "image"]);
        if (title) {
            content += `<h2>${valueToHtml(title)}</h2>`;
        }
        if (image) {
            content += `<img src="${valueToHtml(image)}">`;
        }
        const keys = Object.keys(rest);
        if (keys.length > 0) {
            content += '<table>';
            for (const key of keys) {
                let val = rest[key];
                // ignore undefined properties
                if (val === undefined) {
                    continue;
                }
                if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(val)) {
                    val = stringify(val, maxDepth);
                }
                content += `<tr><td class="key">${valueToHtml(key)}:</td><td class="value">${valueToHtml(val)}</td></tr>`;
            }
            content += `</table>`;
        }
        return content || '{}'; // show empty object if there are no properties
    }
    return valueToHtml(value);
}
function replacer(maxDepth) {
    const stack = [];
    return function (key, value) {
        if (typeof value !== 'object' || value === null) {
            return value;
        }
        const pos = stack.indexOf(this) + 1;
        stack.length = pos;
        if (stack.length > maxDepth) {
            return '[Object]';
        }
        if (stack.indexOf(value) >= 0) {
            return '[Circular]';
        }
        stack.push(value);
        return value;
    };
}
/**
 * Stringify any JS object to valid JSON
 */
function stringify(obj, maxDepth) {
    return JSON.stringify(obj, replacer(maxDepth));
}

/**
 * Position the tooltip
 *
 * @param event The mouse event.
 * @param tooltipBox
 * @param offsetX Horizontal offset.
 * @param offsetY Vertical offset.
 */
function calculatePosition(event, tooltipBox, offsetX, offsetY) {
    let x = event.clientX + offsetX;
    if (x + tooltipBox.width > window.innerWidth) {
        x = +event.clientX - offsetX - tooltipBox.width;
    }
    let y = event.clientY + offsetY;
    if (y + tooltipBox.height > window.innerHeight) {
        y = +event.clientY - offsetY - tooltipBox.height;
    }
    return { x, y };
}

/**
 * The tooltip handler class.
 */
class Handler {
    /**
     * Create the tooltip handler and initialize the element and style.
     *
     * @param options Tooltip Options
     */
    constructor(options) {
        this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        const elementId = this.options.id;
        this.el = null;
        // bind this to call
        this.call = this.tooltipHandler.bind(this);
        // prepend a default stylesheet for tooltips to the head
        if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
            const style = document.createElement('style');
            style.setAttribute('id', this.options.styleId);
            style.innerHTML = createDefaultStyle(elementId);
            const head = document.head;
            if (head.childNodes.length > 0) {
                head.insertBefore(style, head.childNodes[0]);
            }
            else {
                head.appendChild(style);
            }
        }
    }
    /**
     * The tooltip handler function.
     */
    tooltipHandler(handler, event, item, value) {
        // console.log(handler, event, item, value);
        // append a div element that we use as a tooltip unless it already exists
        this.el = document.getElementById(this.options.id);
        if (!this.el) {
            this.el = document.createElement('div');
            this.el.setAttribute('id', this.options.id);
            this.el.classList.add('vg-tooltip');
            document.body.appendChild(this.el);
        }
        const tooltipContainer = document.fullscreenElement != null ? document.fullscreenElement : document.body;
        tooltipContainer.appendChild(this.el);
        // hide tooltip for null, undefined, or empty string values
        if (value == null || value === '') {
            this.el.classList.remove('visible', `${this.options.theme}-theme`);
            return;
        }
        // set the tooltip content
        this.el.innerHTML = formatValue(value, this.options.sanitize, this.options.maxDepth);
        // make the tooltip visible
        this.el.classList.add('visible', `${this.options.theme}-theme`);
        const { x, y } = calculatePosition(event, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
        this.el.setAttribute('style', `top: ${y}px; left: ${x}px`);
    }
}

const version$1 = pkg.version;
/**
 * Create a tooltip handler and register it with the provided view.
 *
 * @param view The Vega view.
 * @param opt Tooltip options.
 */
function index (view, opt) {
    const handler = new Handler(opt);
    view.tooltip(handler.call).run();
    return handler;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL2luZGV4Lm1qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL21vZHVsZS9jb3JlLm1qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXBhdGNoL21vZHVsZS9kdXBsZXgubWpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9mYXN0LWpzb24tcGF0Y2gvbW9kdWxlL2hlbHBlcnMubWpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qc29uLXN0cmluZ2lmeS1wcmV0dHktY29tcGFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1lbWJlZC9idWlsZC92ZWdhLWVtYmVkLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1zY2hlbWEtdXJsLXBhcnNlci9kaXN0L3BhcnNlci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtdGhlbWVzL2J1aWxkL3ZlZ2EtdGhlbWVzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS10b29sdGlwL2J1aWxkL3ZlZ2EtdG9vbHRpcC5tb2R1bGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QixXQUFXLG9CQUFvQjtBQUMvQixXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLG9CQUFvQjtBQUMvQixZQUFZLHNCQUFzQjtBQUNsQyxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbUJBQW1CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQW1CO0FBQy9ELGVBQWUsT0FBTztBQUN0Qiw4Q0FBOEMsRUFBRSxHQUFHLFNBQVMsRUFBRTtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxLQUFLLEVBQUM7QUFDMEgiLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdmVnYS1lbWJlZF9idWlsZF92ZWdhLWVtYmVkX21vZHVsZV9qcy4yMGRkNWU1YmFjYTBiNGQ3MjBiYy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vbW9kdWxlL2NvcmUubWpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9tb2R1bGUvZHVwbGV4Lm1qcyc7XHJcbmV4cG9ydCB7XHJcbiAgICBQYXRjaEVycm9yIGFzIEpzb25QYXRjaEVycm9yLFxyXG4gICAgX2RlZXBDbG9uZSBhcyBkZWVwQ2xvbmUsXHJcbiAgICBlc2NhcGVQYXRoQ29tcG9uZW50LFxyXG4gICAgdW5lc2NhcGVQYXRoQ29tcG9uZW50XHJcbn0gZnJvbSAnLi9tb2R1bGUvaGVscGVycy5tanMnO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IGV4cG9ydCBmb3IgYmFja3dhcmRzIGNvbXBhdFxyXG4gKi9cclxuXHJcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSAnLi9tb2R1bGUvY29yZS5tanMnO1xyXG5pbXBvcnQgKiBhcyBkdXBsZXggZnJvbSAnLi9tb2R1bGUvZHVwbGV4Lm1qcyc7XHJcbmltcG9ydCB7XHJcbiAgICBQYXRjaEVycm9yIGFzIEpzb25QYXRjaEVycm9yLFxyXG4gICAgX2RlZXBDbG9uZSBhcyBkZWVwQ2xvbmUsXHJcbiAgICBlc2NhcGVQYXRoQ29tcG9uZW50LFxyXG4gICAgdW5lc2NhcGVQYXRoQ29tcG9uZW50XHJcbn0gZnJvbSAnLi9tb2R1bGUvaGVscGVycy5tanMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmFzc2lnbih7fSwgY29yZSwgZHVwbGV4LCB7XHJcbiAgICBKc29uUGF0Y2hFcnJvcixcclxuICAgIGRlZXBDbG9uZSxcclxuICAgIGVzY2FwZVBhdGhDb21wb25lbnQsXHJcbiAgICB1bmVzY2FwZVBhdGhDb21wb25lbnRcclxufSk7IiwiaW1wb3J0IHsgUGF0Y2hFcnJvciwgX2RlZXBDbG9uZSwgaXNJbnRlZ2VyLCB1bmVzY2FwZVBhdGhDb21wb25lbnQsIGhhc1VuZGVmaW5lZCB9IGZyb20gJy4vaGVscGVycy5tanMnO1xuZXhwb3J0IHZhciBKc29uUGF0Y2hFcnJvciA9IFBhdGNoRXJyb3I7XG5leHBvcnQgdmFyIGRlZXBDbG9uZSA9IF9kZWVwQ2xvbmU7XG4vKiBXZSB1c2UgYSBKYXZhc2NyaXB0IGhhc2ggdG8gc3RvcmUgZWFjaFxuIGZ1bmN0aW9uLiBFYWNoIGhhc2ggZW50cnkgKHByb3BlcnR5KSB1c2VzXG4gdGhlIG9wZXJhdGlvbiBpZGVudGlmaWVycyBzcGVjaWZpZWQgaW4gcmZjNjkwMi5cbiBJbiB0aGlzIHdheSwgd2UgY2FuIG1hcCBlYWNoIHBhdGNoIG9wZXJhdGlvblxuIHRvIGl0cyBkZWRpY2F0ZWQgZnVuY3Rpb24gaW4gZWZmaWNpZW50IHdheS5cbiAqL1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBvYmplY3QgKi9cbnZhciBvYmpPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIG1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgLyogaW4gY2FzZSBtb3ZlIHRhcmdldCBvdmVyd3JpdGVzIGFuIGV4aXN0aW5nIHZhbHVlLFxuICAgICAgICByZXR1cm4gdGhlIHJlbW92ZWQgdmFsdWUsIHRoaXMgY2FuIGJlIHRheGluZyBwZXJmb3JtYW5jZS13aXNlLFxuICAgICAgICBhbmQgaXMgcG90ZW50aWFsbHkgdW5uZWVkZWQgKi9cbiAgICAgICAgdmFyIHJlbW92ZWQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5wYXRoKTtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSBfZGVlcENsb25lKHJlbW92ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHsgb3A6IFwicmVtb3ZlXCIsIHBhdGg6IHRoaXMuZnJvbSB9KS5yZW1vdmVkO1xuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgeyBvcDogXCJhZGRcIiwgcGF0aDogdGhpcy5wYXRoLCB2YWx1ZTogb3JpZ2luYWxWYWx1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkIH07XG4gICAgfSxcbiAgICBjb3B5OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciB2YWx1ZVRvQ29weSA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLmZyb20pO1xuICAgICAgICAvLyBlbmZvcmNlIGNvcHkgYnkgdmFsdWUgc28gZnVydGhlciBvcGVyYXRpb25zIGRvbid0IGFmZmVjdCBzb3VyY2UgKHNlZSBpc3N1ZSAjMTc3KVxuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgeyBvcDogXCJhZGRcIiwgcGF0aDogdGhpcy5wYXRoLCB2YWx1ZTogX2RlZXBDbG9uZSh2YWx1ZVRvQ29weSkgfSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG4gICAgdGVzdDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHRlc3Q6IF9hcmVFcXVhbHMob2JqW2tleV0sIHRoaXMudmFsdWUpIH07XG4gICAgfSxcbiAgICBfZ2V0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfVxufTtcbi8qIFRoZSBvcGVyYXRpb25zIGFwcGxpY2FibGUgdG8gYW4gYXJyYXkuIE1hbnkgYXJlIHRoZSBzYW1lIGFzIGZvciB0aGUgb2JqZWN0ICovXG52YXIgYXJyT3BzID0ge1xuICAgIGFkZDogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKGlzSW50ZWdlcihpKSkge1xuICAgICAgICAgICAgYXJyLnNwbGljZShpLCAwLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gYXJyYXkgcHJvcHNcbiAgICAgICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBtYXkgYmUgbmVlZGVkIHdoZW4gdXNpbmcgJy0nIGluIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgaW5kZXg6IGkgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWRMaXN0ID0gYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkTGlzdFswXSB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBhcnJbaV07XG4gICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogb2JqT3BzLm1vdmUsXG4gICAgY29weTogb2JqT3BzLmNvcHksXG4gICAgdGVzdDogb2JqT3BzLnRlc3QsXG4gICAgX2dldDogb2JqT3BzLl9nZXRcbn07XG4vKipcbiAqIFJldHJpZXZlcyBhIHZhbHVlIGZyb20gYSBKU09OIGRvY3VtZW50IGJ5IGEgSlNPTiBwb2ludGVyLlxuICogUmV0dXJucyB0aGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBnZXQgdGhlIHZhbHVlIGZyb21cbiAqIEBwYXJhbSBwb2ludGVyIGFuIGVzY2FwZWQgSlNPTiBwb2ludGVyXG4gKiBAcmV0dXJuIFRoZSByZXRyaWV2ZWQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBwb2ludGVyKSB7XG4gICAgaWYgKHBvaW50ZXIgPT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICB2YXIgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbiA9IHsgb3A6IFwiX2dldFwiLCBwYXRoOiBwb2ludGVyIH07XG4gICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGdldE9yaWdpbmFsRGVzdGluYXRpb24pO1xuICAgIHJldHVybiBnZXRPcmlnaW5hbERlc3RpbmF0aW9uLnZhbHVlO1xufVxuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIG9wZXJhdGlvbi5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIGFuZCBgb3BlcmF0aW9uYCBvYmplY3RzIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cbiAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGF2b2lkIHRvdWNoaW5nIHlvdXIgdmFsdWVzLCBjbG9uZSB0aGVtOlxuICogYGpzb25wYXRjaC5hcHBseU9wZXJhdGlvbihkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUob3BlcmF0aW9uKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIG9wZXJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbiwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50LCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zLCBpbmRleCkge1xuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiA9PT0gdm9pZCAwKSB7IHZhbGlkYXRlT3BlcmF0aW9uID0gZmFsc2U7IH1cbiAgICBpZiAobXV0YXRlRG9jdW1lbnQgPT09IHZvaWQgMCkgeyBtdXRhdGVEb2N1bWVudCA9IHRydWU7IH1cbiAgICBpZiAoYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9PT0gdm9pZCAwKSB7IGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPSB0cnVlOyB9XG4gICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAwOyB9XG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uLCAwLCBkb2N1bWVudCwgb3BlcmF0aW9uLnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdG9yKG9wZXJhdGlvbiwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogUk9PVCBPUEVSQVRJT05TICovXG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoID09PSBcIlwiKSB7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG9wZXJhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7IC8vZG9jdW1lbnQgd2UgcmVtb3ZlZFxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ21vdmUnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ2NvcHknKSB7IC8vIGl0J3MgYSBtb3ZlIG9yIGNvcHkgdG8gcm9vdFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgb3BlcmF0aW9uLmZyb20pOyAvLyBnZXQgdGhlIHZhbHVlIGJ5IGpzb24tcG9pbnRlciBpbiBgZnJvbWAgZmllbGRcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJykgeyAvLyByZXBvcnQgcmVtb3ZlZCBpdGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3Rlc3QnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS50ZXN0ID0gX2FyZUVxdWFscyhkb2N1bWVudCwgb3BlcmF0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdyZW1vdmUnKSB7IC8vIGEgcmVtb3ZlIG9uIHJvb3RcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdfZ2V0Jykge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8qIGJhZCBvcGVyYXRpb24gKi9cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBvcGAgcHJvcGVydHkgaXMgbm90IG9uZSBvZiBvcGVyYXRpb25zIGRlZmluZWQgaW4gUkZDLTY5MDInLCAnT1BFUkFUSU9OX09QX0lOVkFMSUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IC8qIEVORCBST09UIE9QRVJBVElPTlMgKi9cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFtdXRhdGVEb2N1bWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQgPSBfZGVlcENsb25lKGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IG9wZXJhdGlvbi5wYXRoIHx8IFwiXCI7XG4gICAgICAgIHZhciBrZXlzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQ7XG4gICAgICAgIHZhciB0ID0gMTsgLy9za2lwIGVtcHR5IGVsZW1lbnQgLSBodHRwOi8vanNwZXJmLmNvbS90by1zaGlmdC1vci1ub3QtdG8tc2hpZnRcbiAgICAgICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICB2YXIgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICAgIHZhciB2YWxpZGF0ZUZ1bmN0aW9uID0gdm9pZCAwO1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0ZU9wZXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbdF07XG4gICAgICAgICAgICBpZiAoYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyAmJiBrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKU09OLVBhdGNoOiBtb2RpZnlpbmcgYF9fcHJvdG9fX2AgcHJvcCBpcyBiYW5uZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGlmIHRoaXMgd2FzIG9uIHB1cnBvc2UsIHBsZWFzZSBzZXQgYGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnNgIGZsYWcgZmFsc2UgYW5kIHBhc3MgaXQgdG8gdGhpcyBmdW5jdGlvbi4gTW9yZSBpbmZvIGluIGZhc3QtanNvbi1wYXRjaCBSRUFETUUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1BhdGhGcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IGtleXMuc2xpY2UoMCwgdCkuam9pbignLycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9iai5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgIWlzSW50ZWdlcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJFeHBlY3RlZCBhbiB1bnNpZ25lZCBiYXNlLTEwIGludGVnZXIgdmFsdWUsIG1ha2luZyB0aGUgbmV3IHJlZmVyZW5jZWQgdmFsdWUgdGhlIGFycmF5IGVsZW1lbnQgd2l0aCB0aGUgemVyby1iYXNlZCBpbmRleFwiLCBcIk9QRVJBVElPTl9QQVRIX0lMTEVHQUxfQVJSQVlfSU5ERVhcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIG9ubHkgcGFyc2Uga2V5IHdoZW4gaXQncyBhbiBpbnRlZ2VyIGZvciBgYXJyLnByb3BgIHRvIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNJbnRlZ2VyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IH5+a2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgb3BlcmF0aW9uLm9wID09PSBcImFkZFwiICYmIGtleSA+IG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRoZSBzcGVjaWZpZWQgaW5kZXggTVVTVCBOT1QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XCIsIFwiT1BFUkFUSU9OX1ZBTFVFX09VVF9PRl9CT1VORFNcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGFyck9wc1tvcGVyYXRpb24ub3BdLmNhbGwob3BlcmF0aW9uLCBvYmosIGtleSwgZG9jdW1lbnQpOyAvLyBBcHBseSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICYmIGtleS5pbmRleE9mKCd+JykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdW5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgJ1RFU1RfT1BFUkFUSU9OX0ZBSUxFRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFwcGx5IGEgZnVsbCBKU09OIFBhdGNoIGFycmF5IG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgcGF0Y2guXG4gKiBJdCBtb2RpZmllcyB0aGUgYGRvY3VtZW50YCBvYmplY3QgYW5kIGBwYXRjaGAgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5UGF0Y2goZG9jdW1lbnQsIGpzb25wYXRjaC5fZGVlcENsb25lKHBhdGNoKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBwYXRjaCBUaGUgcGF0Y2ggdG8gYXBwbHlcbiAqIEBwYXJhbSB2YWxpZGF0ZU9wZXJhdGlvbiBgZmFsc2VgIGlzIHdpdGhvdXQgdmFsaWRhdGlvbiwgYHRydWVgIHRvIHVzZSBkZWZhdWx0IGpzb25wYXRjaCdzIHZhbGlkYXRpb24sIG9yIHlvdSBjYW4gcGFzcyBhIGB2YWxpZGF0ZU9wZXJhdGlvbmAgY2FsbGJhY2sgdG8gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXG4gKiBAcGFyYW0gYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyBXaGV0aGVyIHRvIGJhbiBtb2RpZmljYXRpb25zIHRvIGBfX3Byb3RvX19gLCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIGB7bmV3RG9jdW1lbnQsIHJlc3VsdH1gIGFmdGVyIHRoZSBwYXRjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXRjaChkb2N1bWVudCwgcGF0Y2gsIHZhbGlkYXRlT3BlcmF0aW9uLCBtdXRhdGVEb2N1bWVudCwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucykge1xuICAgIGlmIChtdXRhdGVEb2N1bWVudCA9PT0gdm9pZCAwKSB7IG11dGF0ZURvY3VtZW50ID0gdHJ1ZTsgfVxuICAgIGlmIChiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID09PSB2b2lkIDApIHsgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9IHRydWU7IH1cbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKCdQYXRjaCBzZXF1ZW5jZSBtdXN0IGJlIGFuIGFycmF5JywgJ1NFUVVFTkNFX05PVF9BTl9BUlJBWScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbXV0YXRlRG9jdW1lbnQpIHtcbiAgICAgICAgZG9jdW1lbnQgPSBfZGVlcENsb25lKGRvY3VtZW50KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkocGF0Y2gubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBwYXRjaC5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgaSsrKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gcGFzcyBtdXRhdGVEb2N1bWVudCBhcmd1bWVudCBiZWNhdXNlIGlmIGl0IHdhcyB0cnVlLCB3ZSBhbHJlYWR5IGRlZXAgY2xvbmVkIHRoZSBvYmplY3QsIHdlJ2xsIGp1c3QgcGFzcyBgdHJ1ZWBcbiAgICAgICAgcmVzdWx0c1tpXSA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBwYXRjaFtpXSwgdmFsaWRhdGVPcGVyYXRpb24sIHRydWUsIGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMsIGkpO1xuICAgICAgICBkb2N1bWVudCA9IHJlc3VsdHNbaV0ubmV3RG9jdW1lbnQ7IC8vIGluIGNhc2Ugcm9vdCB3YXMgcmVwbGFjZWRcbiAgICB9XG4gICAgcmVzdWx0cy5uZXdEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHJldHVybiByZXN1bHRzO1xufVxuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB1cGRhdGVkIGRvY3VtZW50LlxuICogU3VpdGFibGUgYXMgYSByZWR1Y2VyLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHJldHVybiBUaGUgdXBkYXRlZCBkb2N1bWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlSZWR1Y2VyKGRvY3VtZW50LCBvcGVyYXRpb24sIGluZGV4KSB7XG4gICAgdmFyIG9wZXJhdGlvblJlc3VsdCA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBvcGVyYXRpb24pO1xuICAgIGlmIChvcGVyYXRpb25SZXN1bHQudGVzdCA9PT0gZmFsc2UpIHsgLy8gZmFpbGVkIHRlc3RcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsICdURVNUX09QRVJBVElPTl9GQUlMRUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25SZXN1bHQubmV3RG9jdW1lbnQ7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvbiAtIG9wZXJhdGlvbiBvYmplY3QgKHBhdGNoKVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4aXN0aW5nUGF0aEZyYWdtZW50XSAtIGNvbWVzIGFsb25nIHdpdGggYGRvY3VtZW50YFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdG9yKG9wZXJhdGlvbiwgaW5kZXgsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCkge1xuICAgIGlmICh0eXBlb2Ygb3BlcmF0aW9uICE9PSAnb2JqZWN0JyB8fCBvcGVyYXRpb24gPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShvcGVyYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGlzIG5vdCBhbiBvYmplY3QnLCAnT1BFUkFUSU9OX05PVF9BTl9PQkpFQ1QnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvYmpPcHNbb3BlcmF0aW9uLm9wXSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyJywgJ09QRVJBVElPTl9PUF9JTlZBTElEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3BlcmF0aW9uLnBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBpcyBub3QgYSBzdHJpbmcnLCAnT1BFUkFUSU9OX1BBVEhfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnBhdGguaW5kZXhPZignLycpICE9PSAwICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gcGF0aHMgdGhhdCBhcmVuJ3QgZW1wdHkgc3RyaW5nIHNob3VsZCBzdGFydCB3aXRoIFwiL1wiXG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBtdXN0IHN0YXJ0IHdpdGggXCIvXCInLCAnT1BFUkFUSU9OX1BBVEhfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gJ21vdmUnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ2NvcHknKSAmJiB0eXBlb2Ygb3BlcmF0aW9uLmZyb20gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fRlJPTV9SRVFVSVJFRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcgfHwgb3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAndGVzdCcpICYmIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGB2YWx1ZWAgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgKGFwcGxpY2FibGUgaW4gYGFkZGAsIGByZXBsYWNlYCBhbmQgYHRlc3RgIG9wZXJhdGlvbnMpJywgJ09QRVJBVElPTl9WQUxVRV9SRVFVSVJFRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcgfHwgb3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAndGVzdCcpICYmIGhhc1VuZGVmaW5lZChvcGVyYXRpb24udmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGB2YWx1ZWAgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgKGFwcGxpY2FibGUgaW4gYGFkZGAsIGByZXBsYWNlYCBhbmQgYHRlc3RgIG9wZXJhdGlvbnMpJywgJ09QRVJBVElPTl9WQUxVRV9DQU5OT1RfQ09OVEFJTl9VTkRFRklORUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT0gXCJhZGRcIikge1xuICAgICAgICAgICAgdmFyIHBhdGhMZW4gPSBvcGVyYXRpb24ucGF0aC5zcGxpdChcIi9cIikubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nUGF0aExlbiA9IGV4aXN0aW5nUGF0aEZyYWdtZW50LnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocGF0aExlbiAhPT0gZXhpc3RpbmdQYXRoTGVuICsgMSAmJiBwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIGFuIGBhZGRgIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoJywgJ09QRVJBVElPTl9QQVRIX0NBTk5PVF9BREQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAncmVtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdfZ2V0Jykge1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5wYXRoICE9PSBleGlzdGluZ1BhdGhGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBhdCBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCcsICdPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0geyBvcDogXCJfZ2V0XCIsIHBhdGg6IG9wZXJhdGlvbi5mcm9tLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShbZXhpc3RpbmdWYWx1ZV0sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSAnT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBmcm9tIGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0JywgJ09QRVJBVElPTl9GUk9NX1VOUkVTT0xWQUJMRScsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgc2VxdWVuY2Ugb2Ygb3BlcmF0aW9ucy4gSWYgYGRvY3VtZW50YCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHRoZSBzZXF1ZW5jZSBpcyBhZGRpdGlvbmFsbHkgdmFsaWRhdGVkIGFnYWluc3QgdGhlIG9iamVjdCBkb2N1bWVudC5cbiAqIElmIGVycm9yIGlzIGVuY291bnRlcmVkLCByZXR1cm5zIGEgSnNvblBhdGNoRXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0gc2VxdWVuY2VcbiAqIEBwYXJhbSBkb2N1bWVudFxuICogQHJldHVybnMge0pzb25QYXRjaEVycm9yfHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHNlcXVlbmNlLCBkb2N1bWVudCwgZXh0ZXJuYWxWYWxpZGF0b3IpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoJ1BhdGNoIHNlcXVlbmNlIG11c3QgYmUgYW4gYXJyYXknLCAnU0VRVUVOQ0VfTk9UX0FOX0FSUkFZJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICAvL2Nsb25lIGRvY3VtZW50IGFuZCBzZXF1ZW5jZSBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgdHJ5IGFwcGx5aW5nIG9wZXJhdGlvbnNcbiAgICAgICAgICAgIGFwcGx5UGF0Y2goX2RlZXBDbG9uZShkb2N1bWVudCksIF9kZWVwQ2xvbmUoc2VxdWVuY2UpLCBleHRlcm5hbFZhbGlkYXRvciB8fCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4dGVybmFsVmFsaWRhdG9yID0gZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdmFsaWRhdG9yO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsVmFsaWRhdG9yKHNlcXVlbmNlW2ldLCBpLCBkb2N1bWVudCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEpzb25QYXRjaEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZXBvYmVyZXpraW4vZmFzdC1kZWVwLWVxdWFsXG4vLyBNSVQgTGljZW5zZVxuLy8gQ29weXJpZ2h0IChjKSAyMDE3IEV2Z2VueSBQb2JlcmV6a2luXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4vLyBTT0ZUV0FSRS5cbmV4cG9ydCBmdW5jdGlvbiBfYXJlRXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgYXJyQSA9IEFycmF5LmlzQXJyYXkoYSksIGFyckIgPSBBcnJheS5pc0FycmF5KGIpLCBpLCBsZW5ndGgsIGtleTtcbiAgICAgICAgaWYgKGFyckEgJiYgYXJyQikge1xuICAgICAgICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgICAgICAgICBpZiAoIV9hcmVFcXVhbHMoYVtpXSwgYltpXSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJBICE9IGFyckIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgICAgIGlmICghYi5oYXNPd25Qcm9wZXJ0eShrZXlzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghX2FyZUVxdWFscyhhW2tleV0sIGJba2V5XSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuO1xuIiwiLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3RhcmNvdW50ZXItSmFjay9KU09OLVBhdGNoXG4gKiAoYykgMjAxNyBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgX2RlZXBDbG9uZSwgX29iamVjdEtleXMsIGVzY2FwZVBhdGhDb21wb25lbnQsIGhhc093blByb3BlcnR5IH0gZnJvbSAnLi9oZWxwZXJzLm1qcyc7XG5pbXBvcnQgeyBhcHBseVBhdGNoIH0gZnJvbSAnLi9jb3JlLm1qcyc7XG52YXIgYmVmb3JlRGljdCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTWlycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1pcnJvcihvYmopIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gTWlycm9yO1xufSgpKTtcbnZhciBPYnNlcnZlckluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZXJJbmZvKGNhbGxiYWNrLCBvYnNlcnZlcikge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB9XG4gICAgcmV0dXJuIE9ic2VydmVySW5mbztcbn0oKSk7XG5mdW5jdGlvbiBnZXRNaXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIGJlZm9yZURpY3QuZ2V0KG9iaik7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBtaXJyb3Iub2JzZXJ2ZXJzLmdldChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBvYnNlcnZlcikge1xuICAgIG1pcnJvci5vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyLmNhbGxiYWNrKTtcbn1cbi8qKlxuICogRGV0YWNoIGFuIG9ic2VydmVyIGZyb20gYW4gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bm9ic2VydmUocm9vdCwgb2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcbn1cbi8qKlxuICogT2JzZXJ2ZXMgY2hhbmdlcyBtYWRlIHRvIGFuIG9iamVjdCwgd2hpY2ggY2FuIHRoZW4gYmUgcmV0cmlldmVkIHVzaW5nIGdlbmVyYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlKG9iaiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xuICAgIHZhciBvYnNlcnZlcjtcbiAgICB2YXIgbWlycm9yID0gZ2V0TWlycm9yKG9iaik7XG4gICAgaWYgKCFtaXJyb3IpIHtcbiAgICAgICAgbWlycm9yID0gbmV3IE1pcnJvcihvYmopO1xuICAgICAgICBiZWZvcmVEaWN0LnNldChvYmosIG1pcnJvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgb2JzZXJ2ZXJJbmZvID0gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spO1xuICAgICAgICBvYnNlcnZlciA9IG9ic2VydmVySW5mbyAmJiBvYnNlcnZlckluZm8ub2JzZXJ2ZXI7XG4gICAgfVxuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIG9ic2VydmVyID0ge307XG4gICAgbWlycm9yLnZhbHVlID0gX2RlZXBDbG9uZShvYmopO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBvYnNlcnZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBvYnNlcnZlci5uZXh0ID0gbnVsbDtcbiAgICAgICAgdmFyIGRpcnR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnZW5lcmF0ZShvYnNlcnZlcik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmYXN0Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gc2V0VGltZW91dChkaXJ0eUNoZWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IC8vbm90IE5vZGVcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmYXN0Q2hlY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmVyLnBhdGNoZXMgPSBwYXRjaGVzO1xuICAgIG9ic2VydmVyLm9iamVjdCA9IG9iajtcbiAgICBvYnNlcnZlci51bm9ic2VydmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KG9ic2VydmVyLm5leHQpO1xuICAgICAgICByZW1vdmVPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBvYnNlcnZlcik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG1pcnJvci5vYnNlcnZlcnMuc2V0KGNhbGxiYWNrLCBuZXcgT2JzZXJ2ZXJJbmZvKGNhbGxiYWNrLCBvYnNlcnZlcikpO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbi8qKlxuICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIGFuIG9ic2VydmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZShvYnNlcnZlciwgaW52ZXJ0aWJsZSkge1xuICAgIGlmIChpbnZlcnRpYmxlID09PSB2b2lkIDApIHsgaW52ZXJ0aWJsZSA9IGZhbHNlOyB9XG4gICAgdmFyIG1pcnJvciA9IGJlZm9yZURpY3QuZ2V0KG9ic2VydmVyLm9iamVjdCk7XG4gICAgX2dlbmVyYXRlKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIub2JqZWN0LCBvYnNlcnZlci5wYXRjaGVzLCBcIlwiLCBpbnZlcnRpYmxlKTtcbiAgICBpZiAob2JzZXJ2ZXIucGF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgYXBwbHlQYXRjaChtaXJyb3IudmFsdWUsIG9ic2VydmVyLnBhdGNoZXMpO1xuICAgIH1cbiAgICB2YXIgdGVtcCA9IG9ic2VydmVyLnBhdGNoZXM7XG4gICAgaWYgKHRlbXAubGVuZ3RoID4gMCkge1xuICAgICAgICBvYnNlcnZlci5wYXRjaGVzID0gW107XG4gICAgICAgIGlmIChvYnNlcnZlci5jYWxsYmFjaykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sodGVtcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlbXA7XG59XG4vLyBEaXJ0eSBjaGVjayBpZiBvYmogaXMgZGlmZmVyZW50IGZyb20gbWlycm9yLCBnZW5lcmF0ZSBwYXRjaGVzIGFuZCB1cGRhdGUgbWlycm9yXG5mdW5jdGlvbiBfZ2VuZXJhdGUobWlycm9yLCBvYmosIHBhdGNoZXMsIHBhdGgsIGludmVydGlibGUpIHtcbiAgICBpZiAob2JqID09PSBtaXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuICAgIHZhciBuZXdLZXlzID0gX29iamVjdEtleXMob2JqKTtcbiAgICB2YXIgb2xkS2V5cyA9IF9vYmplY3RLZXlzKG1pcnJvcik7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgZGVsZXRlZCA9IGZhbHNlO1xuICAgIC8vaWYgZXZlciBcIm1vdmVcIiBvcGVyYXRpb24gaXMgaW1wbGVtZW50ZWQgaGVyZSwgbWFrZSBzdXJlIHRoaXMgdGVzdCBydW5zIE9LOiBcInNob3VsZCBub3QgZ2VuZXJhdGUgdGhlIHNhbWUgcGF0Y2ggdHdpY2UgKG1vdmUpXCJcbiAgICBmb3IgKHZhciB0ID0gb2xkS2V5cy5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2xkS2V5c1t0XTtcbiAgICAgICAgdmFyIG9sZFZhbCA9IG1pcnJvcltrZXldO1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBrZXkpICYmICEob2JqW2tleV0gPT09IHVuZGVmaW5lZCAmJiBvbGRWYWwgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KG9iaikgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWwgPT0gXCJvYmplY3RcIiAmJiBvbGRWYWwgIT0gbnVsbCAmJiB0eXBlb2YgbmV3VmFsID09IFwib2JqZWN0XCIgJiYgbmV3VmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfZ2VuZXJhdGUob2xkVmFsLCBuZXdWYWwsIHBhdGNoZXMsIHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgaW52ZXJ0aWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsICE9PSBuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJ0ZXN0XCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgdmFsdWU6IF9kZWVwQ2xvbmUob2xkVmFsKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgdmFsdWU6IF9kZWVwQ2xvbmUobmV3VmFsKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtaXJyb3IpID09PSBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIHZhbHVlOiBfZGVlcENsb25lKG9sZFZhbCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZW1vdmVcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgZXNjYXBlUGF0aENvbXBvbmVudChrZXkpIH0pO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7IC8vIHByb3BlcnR5IGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoOiBwYXRoLCB2YWx1ZTogbWlycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVwbGFjZVwiLCBwYXRoOiBwYXRoLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkZWxldGVkICYmIG5ld0tleXMubGVuZ3RoID09IG9sZEtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBuZXdLZXlzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBuZXdLZXlzW3RdO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KG1pcnJvciwga2V5KSAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJhZGRcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCB2YWx1ZTogX2RlZXBDbG9uZShvYmpba2V5XSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBvZiBwYXRjaGVzIGZyb20gdGhlIGRpZmZlcmVuY2VzIGluIHR3byBvYmplY3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKHRyZWUxLCB0cmVlMiwgaW52ZXJ0aWJsZSkge1xuICAgIGlmIChpbnZlcnRpYmxlID09PSB2b2lkIDApIHsgaW52ZXJ0aWJsZSA9IGZhbHNlOyB9XG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgICBfZ2VuZXJhdGUodHJlZTEsIHRyZWUyLCBwYXRjaGVzLCAnJywgaW52ZXJ0aWJsZSk7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG59XG4iLCIvKiFcclxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxyXG4gKiAoYykgMjAxNyBKb2FjaGltIFdlc3RlclxyXG4gKiBNSVQgbGljZW5zZVxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBrZXkpIHtcclxuICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIF9vYmplY3RLZXlzKG9iaikge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgIHZhciBrZXlzID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwga2V5cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBrZXlzW2tdID0gXCJcIiArIGs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfVxyXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XHJcbiAgICB9XHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBpKSkge1xyXG4gICAgICAgICAgICBrZXlzLnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGtleXM7XHJcbn1cclxuO1xyXG4vKipcclxuKiBEZWVwbHkgY2xvbmUgdGhlIG9iamVjdC5cclxuKiBodHRwczovL2pzcGVyZi5jb20vZGVlcC1jb3B5LXZzLWpzb24tc3RyaW5naWZ5LWpzb24tcGFyc2UvMjUgKHJlY3Vyc2l2ZURlZXBDb3B5KVxyXG4qIEBwYXJhbSAge2FueX0gb2JqIHZhbHVlIHRvIGNsb25lXHJcbiogQHJldHVybiB7YW55fSBjbG9uZWQgb2JqXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBfZGVlcENsb25lKG9iaikge1xyXG4gICAgc3dpdGNoICh0eXBlb2Ygb2JqKSB7XHJcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTsgLy9GYXN0ZXIgdGhhbiBFUzUgY2xvbmUgLSBodHRwOi8vanNwZXJmLmNvbS9kZWVwLWNsb25pbmctb2Ytb2JqZWN0cy81XHJcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy90aGlzIGlzIGhvdyBKU09OLnN0cmluZ2lmeSBiZWhhdmVzIGZvciBhcnJheSBpdGVtc1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7IC8vbm8gbmVlZCB0byBjbG9uZSBwcmltaXRpdmVzXHJcbiAgICB9XHJcbn1cclxuLy8zeCBmYXN0ZXIgdGhhbiBjYWNoZWQgL15cXGQrJC8udGVzdChzdHIpXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIoc3RyKSB7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgIHZhciBjaGFyQ29kZTtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiogRXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXHJcbiogQHBhcmFtIHBhdGggVGhlIHJhdyBwb2ludGVyXHJcbiogQHJldHVybiB0aGUgRXNjYXBlZCBwYXRoXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVQYXRoQ29tcG9uZW50KHBhdGgpIHtcclxuICAgIGlmIChwYXRoLmluZGV4T2YoJy8nKSA9PT0gLTEgJiYgcGF0aC5pbmRleE9mKCd+JykgPT09IC0xKVxyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XHJcbn1cclxuLyoqXHJcbiAqIFVuZXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXHJcbiAqIEBwYXJhbSBwYXRoIFRoZSBlc2NhcGVkIHBvaW50ZXJcclxuICogQHJldHVybiBUaGUgdW5lc2NhcGVkIHBhdGhcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xyXG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopIHtcclxuICAgIHZhciBmb3VuZDtcclxuICAgIGZvciAodmFyIGtleSBpbiByb290KSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHJvb3QsIGtleSkpIHtcclxuICAgICAgICAgICAgaWYgKHJvb3Rba2V5XSA9PT0gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgJy8nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByb290W2tleV0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3Rba2V5XSwgb2JqKTtcclxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCAhPSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyAnLycgKyBmb3VuZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAnJztcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aChyb290LCBvYmopIHtcclxuICAgIGlmIChyb290ID09PSBvYmopIHtcclxuICAgICAgICByZXR1cm4gJy8nO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhdGggPSBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopO1xyXG4gICAgaWYgKHBhdGggPT09ICcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IG5vdCBmb3VuZCBpbiByb290XCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcvJyArIHBhdGg7XHJcbn1cclxuLyoqXHJcbiogUmVjdXJzaXZlbHkgY2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhbnkgdW5kZWZpbmVkIHZhbHVlcyBpbnNpZGUuXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNVbmRlZmluZWQob2JqKSB7XHJcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChvYmopIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgdmFyIG9iaktleXMgPSBfb2JqZWN0S2V5cyhvYmopO1xyXG4gICAgICAgICAgICB2YXIgb2JqS2V5c0xlbmd0aCA9IG9iaktleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1VuZGVmaW5lZChvYmpbb2JqS2V5c1tpXV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwgYXJncykge1xyXG4gICAgdmFyIG1lc3NhZ2VQYXJ0cyA9IFttZXNzYWdlXTtcclxuICAgIGZvciAodmFyIGtleSBpbiBhcmdzKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdHlwZW9mIGFyZ3Nba2V5XSA9PT0gJ29iamVjdCcgPyBKU09OLnN0cmluZ2lmeShhcmdzW2tleV0sIG51bGwsIDIpIDogYXJnc1trZXldOyAvLyBwcmV0dHkgcHJpbnRcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChrZXkgKyBcIjogXCIgKyB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lc3NhZ2VQYXJ0cy5qb2luKCdcXG4nKTtcclxufVxyXG52YXIgUGF0Y2hFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQYXRjaEVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGF0Y2hFcnJvcihtZXNzYWdlLCBuYW1lLCBpbmRleCwgb3BlcmF0aW9uLCB0cmVlKSB7XHJcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIHsgbmFtZTogbmFtZSwgaW5kZXg6IGluZGV4LCBvcGVyYXRpb246IG9wZXJhdGlvbiwgdHJlZTogdHJlZSB9KSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIF90aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcclxuICAgICAgICBfdGhpcy50cmVlID0gdHJlZTtcclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTsgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW4sIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDgzNDIzNTlcclxuICAgICAgICBfdGhpcy5tZXNzYWdlID0gcGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwgeyBuYW1lOiBuYW1lLCBpbmRleDogaW5kZXgsIG9wZXJhdGlvbjogb3BlcmF0aW9uLCB0cmVlOiB0cmVlIH0pO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBQYXRjaEVycm9yO1xyXG59KEVycm9yKSk7XHJcbmV4cG9ydCB7IFBhdGNoRXJyb3IgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIE5vdGU6IFRoaXMgcmVnZXggbWF0Y2hlcyBldmVuIGludmFsaWQgSlNPTiBzdHJpbmdzLCBidXQgc2luY2Ugd2XigJlyZVxuLy8gd29ya2luZyBvbiB0aGUgb3V0cHV0IG9mIGBKU09OLnN0cmluZ2lmeWAgd2Uga25vdyB0aGF0IG9ubHkgdmFsaWQgc3RyaW5nc1xuLy8gYXJlIHByZXNlbnQgKHVubGVzcyB0aGUgdXNlciBzdXBwbGllZCBhIHdlaXJkIGBvcHRpb25zLmluZGVudGAgYnV0IGluXG4vLyB0aGF0IGNhc2Ugd2UgZG9u4oCZdCBjYXJlIHNpbmNlIHRoZSBvdXRwdXQgd291bGQgYmUgaW52YWxpZCBhbnl3YXkpLlxudmFyIHN0cmluZ09yQ2hhciA9IC8oXCIoPzpbXlxcXFxcIl18XFxcXC4pKlwiKXxbOixdL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KHBhc3NlZE9iaiwgb3B0aW9ucykge1xuICB2YXIgaW5kZW50LCBtYXhMZW5ndGgsIHJlcGxhY2VyO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpbmRlbnQgPSBKU09OLnN0cmluZ2lmeShcbiAgICBbMV0sXG4gICAgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnMuaW5kZW50ID09PSB1bmRlZmluZWQgPyAyIDogb3B0aW9ucy5pbmRlbnRcbiAgKS5zbGljZSgyLCAtMyk7XG4gIG1heExlbmd0aCA9XG4gICAgaW5kZW50ID09PSBcIlwiXG4gICAgICA/IEluZmluaXR5XG4gICAgICA6IG9wdGlvbnMubWF4TGVuZ3RoID09PSB1bmRlZmluZWRcbiAgICAgID8gODBcbiAgICAgIDogb3B0aW9ucy5tYXhMZW5ndGg7XG4gIHJlcGxhY2VyID0gb3B0aW9ucy5yZXBsYWNlcjtcblxuICByZXR1cm4gKGZ1bmN0aW9uIF9zdHJpbmdpZnkob2JqLCBjdXJyZW50SW5kZW50LCByZXNlcnZlZCkge1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHZhciBlbmQsIGluZGV4LCBpdGVtcywga2V5LCBrZXlQYXJ0LCBrZXlzLCBsZW5ndGgsIG5leHRJbmRlbnQsIHByZXR0aWZpZWQsIHN0YXJ0LCBzdHJpbmcsIHZhbHVlO1xuXG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuXG4gICAgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlcik7XG5cbiAgICBpZiAoc3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgbGVuZ3RoID0gbWF4TGVuZ3RoIC0gY3VycmVudEluZGVudC5sZW5ndGggLSByZXNlcnZlZDtcblxuICAgIGlmIChzdHJpbmcubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgcHJldHRpZmllZCA9IHN0cmluZy5yZXBsYWNlKFxuICAgICAgICBzdHJpbmdPckNoYXIsXG4gICAgICAgIGZ1bmN0aW9uIChtYXRjaCwgc3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdMaXRlcmFsIHx8IG1hdGNoICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAocHJldHRpZmllZC5sZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwcmV0dGlmaWVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXBsYWNlciAhPSBudWxsKSB7XG4gICAgICBvYmogPSBKU09OLnBhcnNlKHN0cmluZyk7XG4gICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgIG5leHRJbmRlbnQgPSBjdXJyZW50SW5kZW50ICsgaW5kZW50O1xuICAgICAgaXRlbXMgPSBbXTtcbiAgICAgIGluZGV4ID0gMDtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBzdGFydCA9IFwiW1wiO1xuICAgICAgICBlbmQgPSBcIl1cIjtcbiAgICAgICAgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChcbiAgICAgICAgICAgIF9zdHJpbmdpZnkob2JqW2luZGV4XSwgbmV4dEluZGVudCwgaW5kZXggPT09IGxlbmd0aCAtIDEgPyAwIDogMSkgfHxcbiAgICAgICAgICAgICAgXCJudWxsXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IFwie1wiO1xuICAgICAgICBlbmQgPSBcIn1cIjtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgICBrZXlQYXJ0ID0gSlNPTi5zdHJpbmdpZnkoa2V5KSArIFwiOiBcIjtcbiAgICAgICAgICB2YWx1ZSA9IF9zdHJpbmdpZnkoXG4gICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgIG5leHRJbmRlbnQsXG4gICAgICAgICAgICBrZXlQYXJ0Lmxlbmd0aCArIChpbmRleCA9PT0gbGVuZ3RoIC0gMSA/IDAgOiAxKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goa2V5UGFydCArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIFtzdGFydCwgaW5kZW50ICsgaXRlbXMuam9pbihcIixcXG5cIiArIG5leHRJbmRlbnQpLCBlbmRdLmpvaW4oXG4gICAgICAgICAgXCJcXG5cIiArIGN1cnJlbnRJbmRlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9KShwYXNzZWRPYmosIFwiXCIsIDApO1xufTtcbiIsImltcG9ydCB7IGFwcGx5UGF0Y2ggfSBmcm9tICdmYXN0LWpzb24tcGF0Y2gnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICdqc29uLXN0cmluZ2lmeS1wcmV0dHktY29tcGFjdCc7XG5pbXBvcnQgeyBzYXRpc2ZpZXMgfSBmcm9tICdzZW12ZXInO1xuaW1wb3J0ICogYXMgdmVnYUltcG9ydCBmcm9tICd2ZWdhJztcbmltcG9ydCB7IHdyaXRlQ29uZmlnLCBtZXJnZUNvbmZpZywgaXNTdHJpbmcsIGlzQm9vbGVhbiB9IGZyb20gJ3ZlZ2EnO1xuaW1wb3J0ICogYXMgdmVnYUxpdGVJbXBvcnQgZnJvbSAndmVnYS1saXRlJztcbmltcG9ydCBzY2hlbWFQYXJzZXIgZnJvbSAndmVnYS1zY2hlbWEtdXJsLXBhcnNlcic7XG5pbXBvcnQgKiBhcyB0aGVtZXMgZnJvbSAndmVnYS10aGVtZXMnO1xuaW1wb3J0IHsgSGFuZGxlciB9IGZyb20gJ3ZlZ2EtdG9vbHRpcCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xudmFyIHVuZGVmaW5lZCQxOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cblxudmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbnZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG52YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xudmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cblxuICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gIHJldHVybiBnZW5lcmF0b3I7XG59IC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4vLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbi8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2Vcbi8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbi8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbi8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4vLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbi8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbi8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cblxuXG5mdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgIGFyZzogZm4uY2FsbChvYmosIGFyZylcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgYXJnOiBlcnJcbiAgICB9O1xuICB9XG59XG5cbnZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xudmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG52YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xudmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjsgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuXG52YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbi8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbi8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG5cbmZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbmZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4vLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuXG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG5JdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuXG5pZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xufVxuXG52YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG5HZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiOyAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cblxuZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihnZW5GdW4pIHtcbiAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gY3RvciA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWFyayhnZW5GdW4pIHtcbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgfSBlbHNlIHtcbiAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG5cbiAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgIH1cbiAgfVxuXG4gIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgcmV0dXJuIGdlbkZ1bjtcbn1cbi8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4vLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4vLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuXG5mdW5jdGlvbiBhd3JhcChhcmcpIHtcbiAgcmV0dXJuIHtcbiAgICBfX2F3YWl0OiBhcmdcbiAgfTtcbn1cblxuZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcblxuICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gIH0gLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG5cblxuICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xufVxuXG5kZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG5Bc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4vLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2Zcbi8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuXG5cbmZ1bmN0aW9uIGFzeW5jKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7XG4gIHJldHVybiBpc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcbiAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IGFyZztcbiAgICAgIH0gLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcblxuXG4gICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgIH1cblxuICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG5cbiAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDsgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbi8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbi8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG5cblxuZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuXG4gIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCQxKSB7XG4gICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gIGlmICghaW5mbykge1xuICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTsgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuXG4gICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYzsgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG5cbiAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgcmV0dXJuIGluZm87XG4gIH0gLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cblxuXG4gIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbn0gLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbi8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cblxuXG5kZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjsgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbi8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4vLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cblxuR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbn07XG5cbmZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gIHZhciBlbnRyeSA9IHtcbiAgICB0cnlMb2M6IGxvY3NbMF1cbiAgfTtcblxuICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICB9XG5cbiAgaWYgKDIgaW4gbG9jcykge1xuICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgfVxuXG4gIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICBkZWxldGUgcmVjb3JkLmFyZztcbiAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbn1cblxuZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgdHJ5TG9jOiBcInJvb3RcIlxuICB9XTtcbiAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICB0aGlzLnJlc2V0KHRydWUpO1xufVxuXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuXG4gIGtleXMucmV2ZXJzZSgpOyAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuXG4gIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG5cbiAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cbiAgICB9IC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG5cblxuICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICBpZiAoaXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG5cbiAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgIH1cblxuICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgIH1cbiAgfSAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG5cblxuICByZXR1cm4ge1xuICAgIG5leHQ6IGRvbmVSZXN1bHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkJDEsXG4gICAgZG9uZTogdHJ1ZVxuICB9O1xufVxuXG5Db250ZXh0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IENvbnRleHQsXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7XG4gICAgdGhpcy5wcmV2ID0gMDtcbiAgICB0aGlzLm5leHQgPSAwOyAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG5cbiAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkJDE7XG4gICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZCQxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ydmFsO1xuICB9LFxuICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7XG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fCB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgfVxuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHwgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgIH1cblxuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9LFxuICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICB9XG4gICAgfSAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG5cblxuICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgfSxcbiAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZCQxO1xuICAgIH1cblxuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG59OyAvLyBFeHBvcnQgYSBkZWZhdWx0IG5hbWVzcGFjZSB0aGF0IHBsYXlzIHdlbGwgd2l0aCBSb2xsdXBcblxudmFyIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSB7XG4gIHdyYXAsXG4gIGlzR2VuZXJhdG9yRnVuY3Rpb24sXG4gIEFzeW5jSXRlcmF0b3IsXG4gIG1hcmssXG4gIGF3cmFwLFxuICBhc3luYyxcbiAga2V5cyxcbiAgdmFsdWVzXG59O1xuXG4vKipcbiAqIE9wZW4gZWRpdG9yIHVybCBpbiBhIG5ldyB3aW5kb3csIGFuZCBwYXNzIGEgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gcG9zdCAod2luZG93LCB1cmwsIGRhdGEpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgdmFyIGVkaXRvciA9IHdpbmRvdy5vcGVuKHVybCk7XG4gIHZhciB3YWl0ID0gMTAwMDA7XG4gIHZhciBzdGVwID0gMjUwO1xuXG4gIHZhciBfVVJMID0gbmV3IFVSTCh1cmwpLFxuICAgICAgb3JpZ2luID0gX1VSTC5vcmlnaW47IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG5cblxuICB2YXIgY291bnQgPSB+fih3YWl0IC8gc3RlcCk7XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGV2dCkge1xuICAgIGlmIChldnQuc291cmNlID09PSBlZGl0b3IpIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW4sIGZhbHNlKTsgLy8gc2VuZCBtZXNzYWdlXG4gIC8vIHBlcmlvZGljYWxseSByZXNlbmQgdW50aWwgYWNrIHJlY2VpdmVkIG9yIHRpbWVvdXRcblxuICBmdW5jdGlvbiBzZW5kKCkge1xuICAgIGlmIChjb3VudCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWRpdG9yLnBvc3RNZXNzYWdlKGRhdGEsIG9yaWdpbik7XG4gICAgc2V0VGltZW91dChzZW5kLCBzdGVwKTtcbiAgICBjb3VudCAtPSAxO1xuICB9XG5cbiAgc2V0VGltZW91dChzZW5kLCBzdGVwKTtcbn1cblxuLy8gZ2VuZXJhdGVkIHdpdGggYnVpbGQtc3R5bGUuc2hcbnZhciBlbWJlZFN0eWxlID0gXCIudmVnYS1lbWJlZCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuICAudmVnYS1lbWJlZC5oYXMtYWN0aW9ucyB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDM4cHg7IH1cXG4gIC52ZWdhLWVtYmVkIGRldGFpbHM6bm90KFtvcGVuXSkgPiA6bm90KHN1bW1hcnkpIHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9XFxuICAudmVnYS1lbWJlZCBzdW1tYXJ5IHtcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBwYWRkaW5nOiA2cHg7XFxuICAgIHotaW5kZXg6IDEwMDA7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgICBib3gtc2hhZG93OiAxcHggMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMSk7XFxuICAgIGNvbG9yOiAjMWIxZTIzO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjYWFhO1xcbiAgICBib3JkZXItcmFkaXVzOiA5OTlweDtcXG4gICAgb3BhY2l0eTogMC4yO1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuNHMgZWFzZS1pbjtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBsaW5lLWhlaWdodDogMHB4OyB9XFxuICAgIC52ZWdhLWVtYmVkIHN1bW1hcnk6Oi13ZWJraXQtZGV0YWlscy1tYXJrZXIge1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgLnZlZ2EtZW1iZWQgc3VtbWFyeTphY3RpdmUge1xcbiAgICAgIGJveC1zaGFkb3c6ICNhYWEgMHB4IDBweCAwcHggMXB4IGluc2V0OyB9XFxuICAgIC52ZWdhLWVtYmVkIHN1bW1hcnkgc3ZnIHtcXG4gICAgICB3aWR0aDogMTRweDtcXG4gICAgICBoZWlnaHQ6IDE0cHg7IH1cXG4gIC52ZWdhLWVtYmVkIGRldGFpbHNbb3Blbl0gc3VtbWFyeSB7XFxuICAgIG9wYWNpdHk6IDAuNzsgfVxcbiAgLnZlZ2EtZW1iZWQ6aG92ZXIgc3VtbWFyeSxcXG4gIC52ZWdhLWVtYmVkOmZvY3VzIHN1bW1hcnkge1xcbiAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBlYXNlOyB9XFxuICAudmVnYS1lbWJlZCAudmVnYS1hY3Rpb25zIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiAxMDAxO1xcbiAgICB0b3A6IDM1cHg7XFxuICAgIHJpZ2h0OiAtOXB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xcbiAgICBwYWRkaW5nLXRvcDogOHB4O1xcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDhweCAwIHJnYmEoMCwgMCwgMCwgMC4yKTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2Q5ZDlkOTtcXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XFxuICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMC4xNXM7XFxuICAgIGFuaW1hdGlvbi1uYW1lOiBzY2FsZS1pbjtcXG4gICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMiwgMCwgMC4xMywgMS41KTtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDsgfVxcbiAgICAudmVnYS1lbWJlZCAudmVnYS1hY3Rpb25zIGEge1xcbiAgICAgIHBhZGRpbmc6IDhweCAxNnB4O1xcbiAgICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICAgICAgY29sb3I6ICM0MzRhNTY7XFxuICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuICAgICAgLnZlZ2EtZW1iZWQgLnZlZ2EtYWN0aW9ucyBhOmhvdmVyIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmN2Y3Zjk7XFxuICAgICAgICBjb2xvcjogYmxhY2s7IH1cXG4gICAgLnZlZ2EtZW1iZWQgLnZlZ2EtYWN0aW9uczo6YmVmb3JlLCAudmVnYS1lbWJlZCAudmVnYS1hY3Rpb25zOjphZnRlciB7XFxuICAgICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsgfVxcbiAgICAudmVnYS1lbWJlZCAudmVnYS1hY3Rpb25zOjpiZWZvcmUge1xcbiAgICAgIGxlZnQ6IGF1dG87XFxuICAgICAgcmlnaHQ6IDE0cHg7XFxuICAgICAgdG9wOiAtMTZweDtcXG4gICAgICBib3JkZXI6IDhweCBzb2xpZCAjMDAwMDtcXG4gICAgICBib3JkZXItYm90dG9tLWNvbG9yOiAjZDlkOWQ5OyB9XFxuICAgIC52ZWdhLWVtYmVkIC52ZWdhLWFjdGlvbnM6OmFmdGVyIHtcXG4gICAgICBsZWZ0OiBhdXRvO1xcbiAgICAgIHJpZ2h0OiAxNXB4O1xcbiAgICAgIHRvcDogLTE0cHg7XFxuICAgICAgYm9yZGVyOiA3cHggc29saWQgIzAwMDA7XFxuICAgICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI2ZmZjsgfVxcbiAgLnZlZ2EtZW1iZWQgLmNoYXJ0LXdyYXBwZXIuZml0LXgge1xcbiAgICB3aWR0aDogMTAwJTsgfVxcbiAgLnZlZ2EtZW1iZWQgLmNoYXJ0LXdyYXBwZXIuZml0LXkge1xcbiAgICBoZWlnaHQ6IDEwMCU7IH1cXG5cXG4udmVnYS1lbWJlZC13cmFwcGVyIHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgcGFkZGluZy1yaWdodDogMTRweDsgfVxcblxcbkBrZXlmcmFtZXMgc2NhbGUtaW4ge1xcbiAgZnJvbSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMC42KTsgfVxcbiAgdG8ge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpOyB9IH1cXG5cIjtcblxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUsZnVuYy1uYW1lc1xuICBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoc2VhcmNoLCBwb3MpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZURlZXAoZGVzdCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3JjID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzcmNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwLCBfc3JjID0gc3JjOyBfaSA8IF9zcmMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIHMgPSBfc3JjW19pXTtcbiAgICBkZWVwTWVyZ2VfKGRlc3QsIHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59XG5cbmZ1bmN0aW9uIGRlZXBNZXJnZV8oZGVzdCwgc3JjKSB7XG4gIGZvciAodmFyIF9pMiA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7IF9pMiA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gX09iamVjdCRrZXlzW19pMl07XG4gICAgd3JpdGVDb25maWcoZGVzdCwgcHJvcGVydHksIHNyY1twcm9wZXJ0eV0sIHRydWUpO1xuICB9XG59XG5cbnZhciBfdyR2bDtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIHZlZ2EgPSB2ZWdhSW1wb3J0O1xudmFyIF92ZWdhTGl0ZSA9IHZlZ2FMaXRlSW1wb3J0OyAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBWZWdhLUxpdGUgYmVmb3JlIHY0LlxudmFyIHcgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcblxuaWYgKF92ZWdhTGl0ZSA9PT0gdW5kZWZpbmVkICYmIHcgIT09IG51bGwgJiYgdyAhPT0gdm9pZCAwICYmIChfdyR2bCA9IHdbJ3ZsJ10pICE9PSBudWxsICYmIF93JHZsICE9PSB2b2lkIDAgJiYgX3ckdmwuY29tcGlsZSkge1xuICBfdmVnYUxpdGUgPSB3Wyd2bCddO1xufVxuXG52YXIgREVGQVVMVF9BQ1RJT05TID0ge1xuICBleHBvcnQ6IHtcbiAgICBzdmc6IHRydWUsXG4gICAgcG5nOiB0cnVlXG4gIH0sXG4gIHNvdXJjZTogdHJ1ZSxcbiAgY29tcGlsZWQ6IHRydWUsXG4gIGVkaXRvcjogdHJ1ZVxufTtcbnZhciBJMThOID0ge1xuICBDTElDS19UT19WSUVXX0FDVElPTlM6ICdDbGljayB0byB2aWV3IGFjdGlvbnMnLFxuICBDT01QSUxFRF9BQ1RJT046ICdWaWV3IENvbXBpbGVkIFZlZ2EnLFxuICBFRElUT1JfQUNUSU9OOiAnT3BlbiBpbiBWZWdhIEVkaXRvcicsXG4gIFBOR19BQ1RJT046ICdTYXZlIGFzIFBORycsXG4gIFNPVVJDRV9BQ1RJT046ICdWaWV3IFNvdXJjZScsXG4gIFNWR19BQ1RJT046ICdTYXZlIGFzIFNWRydcbn07XG52YXIgTkFNRVMgPSB7XG4gIHZlZ2E6ICdWZWdhJyxcbiAgJ3ZlZ2EtbGl0ZSc6ICdWZWdhLUxpdGUnXG59O1xudmFyIFZFUlNJT04gPSB7XG4gIHZlZ2E6IHZlZ2EudmVyc2lvbixcbiAgJ3ZlZ2EtbGl0ZSc6IF92ZWdhTGl0ZSA/IF92ZWdhTGl0ZS52ZXJzaW9uIDogJ25vdCBhdmFpbGFibGUnXG59O1xudmFyIFBSRVBST0NFU1NPUiA9IHtcbiAgdmVnYTogdmdTcGVjID0+IHZnU3BlYyxcbiAgJ3ZlZ2EtbGl0ZSc6ICh2bFNwZWMsIGNvbmZpZykgPT4gX3ZlZ2FMaXRlLmNvbXBpbGUodmxTcGVjLCB7XG4gICAgY29uZmlnOiBjb25maWdcbiAgfSkuc3BlY1xufTtcbnZhciBTVkdfQ0lSQ0xFUyA9IFwiXFxuPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMTYgMTZcXFwiIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgc3Ryb2tlPVxcXCJub25lXFxcIiBzdHJva2Utd2lkdGg9XFxcIjFcXFwiIHN0cm9rZS1saW5lY2FwPVxcXCJyb3VuZFxcXCIgc3Ryb2tlLWxpbmVqb2luPVxcXCJyb3VuZFxcXCI+XFxuICA8Y2lyY2xlIHI9XFxcIjJcXFwiIGN5PVxcXCI4XFxcIiBjeD1cXFwiMlxcXCI+PC9jaXJjbGU+XFxuICA8Y2lyY2xlIHI9XFxcIjJcXFwiIGN5PVxcXCI4XFxcIiBjeD1cXFwiOFxcXCI+PC9jaXJjbGU+XFxuICA8Y2lyY2xlIHI9XFxcIjJcXFwiIGN5PVxcXCI4XFxcIiBjeD1cXFwiMTRcXFwiPjwvY2lyY2xlPlxcbjwvc3ZnPlwiO1xudmFyIENIQVJUX1dSQVBQRVJfQ0xBU1MgPSAnY2hhcnQtd3JhcHBlcic7XG5cbmZ1bmN0aW9uIGlzVG9vbHRpcEhhbmRsZXIoaCkge1xuICByZXR1cm4gdHlwZW9mIGggPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIHZpZXdTb3VyY2Uoc291cmNlLCBzb3VyY2VIZWFkZXIsIHNvdXJjZUZvb3RlciwgbW9kZSkge1xuICB2YXIgaGVhZGVyID0gXCI8aHRtbD48aGVhZD5cIi5jb25jYXQoc291cmNlSGVhZGVyLCBcIjwvaGVhZD48Ym9keT48cHJlPjxjb2RlIGNsYXNzPVxcXCJqc29uXFxcIj5cIik7XG4gIHZhciBmb290ZXIgPSBcIjwvY29kZT48L3ByZT5cIi5jb25jYXQoc291cmNlRm9vdGVyLCBcIjwvYm9keT48L2h0bWw+XCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuXG4gIHZhciB3aW4gPSB3aW5kb3cub3BlbignJyk7XG4gIHdpbi5kb2N1bWVudC53cml0ZShoZWFkZXIgKyBzb3VyY2UgKyBmb290ZXIpO1xuICB3aW4uZG9jdW1lbnQudGl0bGUgPSBcIlwiLmNvbmNhdChOQU1FU1ttb2RlXSwgXCIgSlNPTiBTb3VyY2VcIik7XG59XG4vKipcbiAqIFRyeSB0byBndWVzcyB0aGUgdHlwZSBvZiBzcGVjLlxuICpcbiAqIEBwYXJhbSBzcGVjIFZlZ2Egb3IgVmVnYS1MaXRlIHNwZWMuXG4gKi9cblxuXG5mdW5jdGlvbiBndWVzc01vZGUoc3BlYywgcHJvdmlkZWRNb2RlKSB7XG4gIC8vIERlY2lkZSBtb2RlXG4gIGlmIChzcGVjLiRzY2hlbWEpIHtcbiAgICB2YXIgcGFyc2VkID0gc2NoZW1hUGFyc2VyKHNwZWMuJHNjaGVtYSk7XG5cbiAgICBpZiAocHJvdmlkZWRNb2RlICYmIHByb3ZpZGVkTW9kZSAhPT0gcGFyc2VkLmxpYnJhcnkpIHtcbiAgICAgIHZhciBfTkFNRVMkcHJvdmlkZWRNb2RlO1xuXG4gICAgICBjb25zb2xlLndhcm4oXCJUaGUgZ2l2ZW4gdmlzdWFsaXphdGlvbiBzcGVjIGlzIHdyaXR0ZW4gaW4gXCIuY29uY2F0KE5BTUVTW3BhcnNlZC5saWJyYXJ5XSwgXCIsIGJ1dCBtb2RlIGFyZ3VtZW50IHNldHMgXCIpLmNvbmNhdCgoX05BTUVTJHByb3ZpZGVkTW9kZSA9IE5BTUVTW3Byb3ZpZGVkTW9kZV0pICE9PSBudWxsICYmIF9OQU1FUyRwcm92aWRlZE1vZGUgIT09IHZvaWQgMCA/IF9OQU1FUyRwcm92aWRlZE1vZGUgOiBwcm92aWRlZE1vZGUsIFwiLlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSBwYXJzZWQubGlicmFyeTtcblxuICAgIGlmICghc2F0aXNmaWVzKFZFUlNJT05bbW9kZV0sIFwiXlwiLmNvbmNhdChwYXJzZWQudmVyc2lvbi5zbGljZSgxKSkpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUaGUgaW5wdXQgc3BlYyB1c2VzIFwiLmNvbmNhdChOQU1FU1ttb2RlXSwgXCIgXCIpLmNvbmNhdChwYXJzZWQudmVyc2lvbiwgXCIsIGJ1dCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFwiKS5jb25jYXQoTkFNRVNbbW9kZV0sIFwiIGlzIHZcIikuY29uY2F0KFZFUlNJT05bbW9kZV0sIFwiLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGU7XG4gIH0gLy8gdHJ5IHRvIGd1ZXNzIGZyb20gdGhlIHByb3ZpZGVkIHNwZWNcblxuXG4gIGlmICgnbWFyaycgaW4gc3BlYyB8fCAnZW5jb2RpbmcnIGluIHNwZWMgfHwgJ2xheWVyJyBpbiBzcGVjIHx8ICdoY29uY2F0JyBpbiBzcGVjIHx8ICd2Y29uY2F0JyBpbiBzcGVjIHx8ICdmYWNldCcgaW4gc3BlYyB8fCAncmVwZWF0JyBpbiBzcGVjKSB7XG4gICAgcmV0dXJuICd2ZWdhLWxpdGUnO1xuICB9XG5cbiAgaWYgKCdtYXJrcycgaW4gc3BlYyB8fCAnc2lnbmFscycgaW4gc3BlYyB8fCAnc2NhbGVzJyBpbiBzcGVjIHx8ICdheGVzJyBpbiBzcGVjKSB7XG4gICAgcmV0dXJuICd2ZWdhJztcbiAgfVxuXG4gIHJldHVybiBwcm92aWRlZE1vZGUgIT09IG51bGwgJiYgcHJvdmlkZWRNb2RlICE9PSB2b2lkIDAgPyBwcm92aWRlZE1vZGUgOiAndmVnYSc7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGVyKG8pIHtcbiAgcmV0dXJuICEhKG8gJiYgJ2xvYWQnIGluIG8pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2FkZXIob3B0cykge1xuICByZXR1cm4gaXNMb2FkZXIob3B0cykgPyBvcHRzIDogdmVnYS5sb2FkZXIob3B0cyk7XG59XG5cbmZ1bmN0aW9uIGVtYmVkT3B0aW9uc0Zyb21Vc2VybWV0YShwYXJzZWRTcGVjKSB7XG4gIHZhciBfcmVmO1xuXG4gIHJldHVybiAoX3JlZiA9IHBhcnNlZFNwZWMudXNlcm1ldGEgJiYgcGFyc2VkU3BlYy51c2VybWV0YVsnZW1iZWRPcHRpb25zJ10pICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiB7fTtcbn1cbi8qKlxuICogRW1iZWQgYSBWZWdhIHZpc3VhbGl6YXRpb24gY29tcG9uZW50IGluIGEgd2ViIHBhZ2UuIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UuXG4gKlxuICogQHBhcmFtIGVsICAgICAgICBET00gZWxlbWVudCBpbiB3aGljaCB0byBwbGFjZSBjb21wb25lbnQgKERPTSBub2RlIG9yIENTUyBzZWxlY3RvcikuXG4gKiBAcGFyYW0gc3BlYyAgICAgIFN0cmluZyA6IEEgVVJMIHN0cmluZyBmcm9tIHdoaWNoIHRvIGxvYWQgdGhlIFZlZ2Egc3BlY2lmaWNhdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgT2JqZWN0IDogVGhlIFZlZ2EvVmVnYS1MaXRlIHNwZWNpZmljYXRpb24gYXMgYSBwYXJzZWQgSlNPTiBvYmplY3QuXG4gKiBAcGFyYW0gb3B0cyAgICAgICBBIEphdmFTY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgZW1iZWRkaW5nLlxuICovXG5cblxuZnVuY3Rpb24gZW1iZWQoX3gsIF94Mikge1xuICByZXR1cm4gX2VtYmVkMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZW1iZWQyKCkge1xuICBfZW1iZWQyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShlbCwgc3BlYykge1xuICAgIHZhciBfcGFyc2VkT3B0cyRjb25maWcsIF91c2VybWV0YU9wdHMkY29uZmlnO1xuXG4gICAgdmFyIG9wdHMsXG4gICAgICAgIHBhcnNlZFNwZWMsXG4gICAgICAgIGxvYWRlcixcbiAgICAgICAgdXNlcm1ldGFMb2FkZXIsXG4gICAgICAgIF9vcHRzJGxvYWRlcixcbiAgICAgICAgdXNlcm1ldGFPcHRzLFxuICAgICAgICBwYXJzZWRPcHRzLFxuICAgICAgICBtZXJnZWRPcHRzLFxuICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBvcHRzID0gX2FyZ3MubGVuZ3RoID4gMiAmJiBfYXJnc1syXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMl0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhzcGVjKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2FkZXIgPSBjcmVhdGVMb2FkZXIob3B0cy5sb2FkZXIpO1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBKU09OO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyLmxvYWQoc3BlYyk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBwYXJzZWRTcGVjID0gX2NvbnRleHQudDAucGFyc2UuY2FsbChfY29udGV4dC50MCwgX2NvbnRleHQudDEpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcGFyc2VkU3BlYyA9IHNwZWM7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgdXNlcm1ldGFMb2FkZXIgPSBlbWJlZE9wdGlvbnNGcm9tVXNlcm1ldGEocGFyc2VkU3BlYykubG9hZGVyOyAvLyBlaXRoZXIgY3JlYXRlIHRoZSBsb2FkZXIgZm9yIHRoZSBmaXJzdCB0aW1lIG9yIGNyZWF0ZSBhIG5ldyBsb2FkZXIgaWYgdGhlIHNwZWMgaGFzIG5ldyBsb2FkZXIgb3B0aW9uc1xuXG4gICAgICAgICAgICBpZiAoIWxvYWRlciB8fCB1c2VybWV0YUxvYWRlcikge1xuICAgICAgICAgICAgICBsb2FkZXIgPSBjcmVhdGVMb2FkZXIoKF9vcHRzJGxvYWRlciA9IG9wdHMubG9hZGVyKSAhPT0gbnVsbCAmJiBfb3B0cyRsb2FkZXIgIT09IHZvaWQgMCA/IF9vcHRzJGxvYWRlciA6IHVzZXJtZXRhTG9hZGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRPcHRzKGVtYmVkT3B0aW9uc0Zyb21Vc2VybWV0YShwYXJzZWRTcGVjKSwgbG9hZGVyKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICB1c2VybWV0YU9wdHMgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE4O1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRPcHRzKG9wdHMsIGxvYWRlcik7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgcGFyc2VkT3B0cyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBtZXJnZWRPcHRzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtZXJnZURlZXAocGFyc2VkT3B0cywgdXNlcm1ldGFPcHRzKSksIHt9LCB7XG4gICAgICAgICAgICAgIGNvbmZpZzogbWVyZ2VDb25maWcoKF9wYXJzZWRPcHRzJGNvbmZpZyA9IHBhcnNlZE9wdHMuY29uZmlnKSAhPT0gbnVsbCAmJiBfcGFyc2VkT3B0cyRjb25maWcgIT09IHZvaWQgMCA/IF9wYXJzZWRPcHRzJGNvbmZpZyA6IHt9LCAoX3VzZXJtZXRhT3B0cyRjb25maWcgPSB1c2VybWV0YU9wdHMuY29uZmlnKSAhPT0gbnVsbCAmJiBfdXNlcm1ldGFPcHRzJGNvbmZpZyAhPT0gdm9pZCAwID8gX3VzZXJtZXRhT3B0cyRjb25maWcgOiB7fSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIyO1xuICAgICAgICAgICAgcmV0dXJuIF9lbWJlZChlbCwgcGFyc2VkU3BlYywgbWVyZ2VkT3B0cywgbG9hZGVyKTtcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9lbWJlZDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbG9hZE9wdHMoX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9sb2FkT3B0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbG9hZE9wdHMoKSB7XG4gIF9sb2FkT3B0cyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKG9wdCwgbG9hZGVyKSB7XG4gICAgdmFyIF9vcHQkY29uZmlnO1xuXG4gICAgdmFyIGNvbmZpZywgcGF0Y2g7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdC5jb25maWcpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi50MSA9IEpTT047XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyLmxvYWQob3B0LmNvbmZpZyk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfY29udGV4dDIudDIgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0Mi50MS5wYXJzZS5jYWxsKF9jb250ZXh0Mi50MSwgX2NvbnRleHQyLnQyKTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gKF9vcHQkY29uZmlnID0gb3B0LmNvbmZpZykgIT09IG51bGwgJiYgX29wdCRjb25maWcgIT09IHZvaWQgMCA/IF9vcHQkY29uZmlnIDoge307XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjb25maWcgPSBfY29udGV4dDIudDA7XG5cbiAgICAgICAgICAgIGlmICghaXNTdHJpbmcob3B0LnBhdGNoKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLnQ0ID0gSlNPTjtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTQ7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyLmxvYWQob3B0LnBhdGNoKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBfY29udGV4dDIudDUgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MyA9IF9jb250ZXh0Mi50NC5wYXJzZS5jYWxsKF9jb250ZXh0Mi50NCwgX2NvbnRleHQyLnQ1KTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBfY29udGV4dDIudDMgPSBvcHQucGF0Y2g7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgcGF0Y2ggPSBfY29udGV4dDIudDM7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0KSwgcGF0Y2ggPyB7XG4gICAgICAgICAgICAgIHBhdGNoXG4gICAgICAgICAgICB9IDoge30pLCBjb25maWcgPyB7XG4gICAgICAgICAgICAgIGNvbmZpZ1xuICAgICAgICAgICAgfSA6IHt9KSk7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfbG9hZE9wdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdChlbCkge1xuICB2YXIgcG9zc2libGVSb290ID0gZWwuZ2V0Um9vdE5vZGUgPyBlbC5nZXRSb290Tm9kZSgpIDogZG9jdW1lbnQ7XG5cbiAgaWYgKHBvc3NpYmxlUm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDogcG9zc2libGVSb290LFxuICAgICAgcm9vdENvbnRhaW5lcjogcG9zc2libGVSb290XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2RvY3VtZW50JGhlYWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDogZG9jdW1lbnQsXG4gICAgICByb290Q29udGFpbmVyOiAoX2RvY3VtZW50JGhlYWQgPSBkb2N1bWVudC5oZWFkKSAhPT0gbnVsbCAmJiBfZG9jdW1lbnQkaGVhZCAhPT0gdm9pZCAwID8gX2RvY3VtZW50JGhlYWQgOiBkb2N1bWVudC5ib2R5XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW1iZWQoX3g1LCBfeDYpIHtcbiAgcmV0dXJuIF9lbWJlZDMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2VtYmVkMygpIHtcbiAgX2VtYmVkMyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGVsLCBzcGVjKSB7XG4gICAgdmFyIF9vcHRzJGNvbmZpZywgX29wdHMkYWN0aW9ucywgX29wdHMkcmVuZGVyZXIsIF9vcHRzJGxvZ0xldmVsLCBfb3B0cyRkb3dubG9hZEZpbGVOYW07XG5cbiAgICB2YXIgb3B0cyxcbiAgICAgICAgbG9hZGVyLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGFjdGlvbnMsXG4gICAgICAgIGkxOG4sXG4gICAgICAgIHJlbmRlcmVyLFxuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgZG93bmxvYWRGaWxlTmFtZSxcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgSUQsXG4gICAgICAgIF9nZXRSb290LFxuICAgICAgICByb290LFxuICAgICAgICByb290Q29udGFpbmVyLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdmdTcGVjLFxuICAgICAgICBwYXJzZWQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgY2hhcnRXcmFwcGVyLFxuICAgICAgICBwYXRjaCxcbiAgICAgICAgYXN0LFxuICAgICAgICBydW50aW1lLFxuICAgICAgICB2aWV3LFxuICAgICAgICBoYW5kbGVyLFxuICAgICAgICBob3ZlcixcbiAgICAgICAgX3JlZjIsXG4gICAgICAgIGhvdmVyU2V0LFxuICAgICAgICB1cGRhdGVTZXQsXG4gICAgICAgIGRvY3VtZW50Q2xpY2tIYW5kbGVyLFxuICAgICAgICB3cmFwcGVyLFxuICAgICAgICBkZXRhaWxzLFxuICAgICAgICBzdW1tYXJ5LFxuICAgICAgICBjdHJsLFxuICAgICAgICBfbG9vcCxcbiAgICAgICAgX2ksXG4gICAgICAgIF9hcnIsXG4gICAgICAgIHZpZXdTb3VyY2VMaW5rLFxuICAgICAgICBjb21waWxlTGluayxcbiAgICAgICAgX29wdHMkZWRpdG9yVXJsLFxuICAgICAgICBlZGl0b3JVcmwsXG4gICAgICAgIGVkaXRvckxpbmssXG4gICAgICAgIGZpbmFsaXplLFxuICAgICAgICBfYXJnczQgPSBhcmd1bWVudHM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGZpbmFsaXplID0gZnVuY3Rpb24gX2ZpbmFsaXplKCkge1xuICAgICAgICAgICAgICBpZiAoZG9jdW1lbnRDbGlja0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGRvY3VtZW50Q2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZpZXcuZmluYWxpemUoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wdHMgPSBfYXJnczQubGVuZ3RoID4gMiAmJiBfYXJnczRbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzNFsyXSA6IHt9O1xuICAgICAgICAgICAgbG9hZGVyID0gX2FyZ3M0Lmxlbmd0aCA+IDMgPyBfYXJnczRbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25maWcgPSBvcHRzLnRoZW1lID8gbWVyZ2VDb25maWcodGhlbWVzW29wdHMudGhlbWVdLCAoX29wdHMkY29uZmlnID0gb3B0cy5jb25maWcpICE9PSBudWxsICYmIF9vcHRzJGNvbmZpZyAhPT0gdm9pZCAwID8gX29wdHMkY29uZmlnIDoge30pIDogb3B0cy5jb25maWc7XG4gICAgICAgICAgICBhY3Rpb25zID0gaXNCb29sZWFuKG9wdHMuYWN0aW9ucykgPyBvcHRzLmFjdGlvbnMgOiBtZXJnZURlZXAoe30sIERFRkFVTFRfQUNUSU9OUywgKF9vcHRzJGFjdGlvbnMgPSBvcHRzLmFjdGlvbnMpICE9PSBudWxsICYmIF9vcHRzJGFjdGlvbnMgIT09IHZvaWQgMCA/IF9vcHRzJGFjdGlvbnMgOiB7fSk7XG4gICAgICAgICAgICBpMThuID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBJMThOKSwgb3B0cy5pMThuKTtcbiAgICAgICAgICAgIHJlbmRlcmVyID0gKF9vcHRzJHJlbmRlcmVyID0gb3B0cy5yZW5kZXJlcikgIT09IG51bGwgJiYgX29wdHMkcmVuZGVyZXIgIT09IHZvaWQgMCA/IF9vcHRzJHJlbmRlcmVyIDogJ2NhbnZhcyc7XG4gICAgICAgICAgICBsb2dMZXZlbCA9IChfb3B0cyRsb2dMZXZlbCA9IG9wdHMubG9nTGV2ZWwpICE9PSBudWxsICYmIF9vcHRzJGxvZ0xldmVsICE9PSB2b2lkIDAgPyBfb3B0cyRsb2dMZXZlbCA6IHZlZ2EuV2FybjtcbiAgICAgICAgICAgIGRvd25sb2FkRmlsZU5hbWUgPSAoX29wdHMkZG93bmxvYWRGaWxlTmFtID0gb3B0cy5kb3dubG9hZEZpbGVOYW1lKSAhPT0gbnVsbCAmJiBfb3B0cyRkb3dubG9hZEZpbGVOYW0gIT09IHZvaWQgMCA/IF9vcHRzJGRvd25sb2FkRmlsZU5hbSA6ICd2aXN1YWxpemF0aW9uJztcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgOiBlbDtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChlbCwgXCIgZG9lcyBub3QgZXhpc3RcIikpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGlmIChvcHRzLmRlZmF1bHRTdHlsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgLy8gQWRkIGEgZGVmYXVsdCBzdHlsZXNoZWV0IHRvIHRoZSBoZWFkIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgSUQgPSAndmVnYS1lbWJlZC1zdHlsZSc7XG4gICAgICAgICAgICAgIF9nZXRSb290ID0gZ2V0Um9vdChlbGVtZW50KSwgcm9vdCA9IF9nZXRSb290LnJvb3QsIHJvb3RDb250YWluZXIgPSBfZ2V0Um9vdC5yb290Q29udGFpbmVyO1xuXG4gICAgICAgICAgICAgIGlmICghcm9vdC5nZXRFbGVtZW50QnlJZChJRCkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgc3R5bGUuaWQgPSBJRDtcbiAgICAgICAgICAgICAgICBzdHlsZS5pbm5lclRleHQgPSBvcHRzLmRlZmF1bHRTdHlsZSA9PT0gdW5kZWZpbmVkIHx8IG9wdHMuZGVmYXVsdFN0eWxlID09PSB0cnVlID8gKGVtYmVkU3R5bGUgKS50b1N0cmluZygpIDogb3B0cy5kZWZhdWx0U3R5bGU7XG4gICAgICAgICAgICAgICAgcm9vdENvbnRhaW5lci5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW9kZSA9IGd1ZXNzTW9kZShzcGVjLCBvcHRzLm1vZGUpO1xuICAgICAgICAgICAgdmdTcGVjID0gUFJFUFJPQ0VTU09SW21vZGVdKHNwZWMsIGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChtb2RlID09PSAndmVnYS1saXRlJykge1xuICAgICAgICAgICAgICBpZiAodmdTcGVjLiRzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBzY2hlbWFQYXJzZXIodmdTcGVjLiRzY2hlbWEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzYXRpc2ZpZXMoVkVSU0lPTi52ZWdhLCBcIl5cIi5jb25jYXQocGFyc2VkLnZlcnNpb24uc2xpY2UoMSkpKSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGNvbXBpbGVkIHNwZWMgdXNlcyBWZWdhIFwiLmNvbmNhdChwYXJzZWQudmVyc2lvbiwgXCIsIGJ1dCBjdXJyZW50IHZlcnNpb24gaXMgdlwiKS5jb25jYXQoVkVSU0lPTi52ZWdhLCBcIi5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3ZlZ2EtZW1iZWQnKTtcblxuICAgICAgICAgICAgaWYgKGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdoYXMtYWN0aW9ucycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICcnOyAvLyBjbGVhciBjb250YWluZXJcblxuICAgICAgICAgICAgY29udGFpbmVyID0gZWxlbWVudDtcblxuICAgICAgICAgICAgaWYgKGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgY2hhcnRXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgIGNoYXJ0V3JhcHBlci5jbGFzc0xpc3QuYWRkKENIQVJUX1dSQVBQRVJfQ0xBU1MpO1xuICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNoYXJ0V3JhcHBlcik7XG4gICAgICAgICAgICAgIGNvbnRhaW5lciA9IGNoYXJ0V3JhcHBlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF0Y2ggPSBvcHRzLnBhdGNoO1xuXG4gICAgICAgICAgICBpZiAocGF0Y2gpIHtcbiAgICAgICAgICAgICAgaWYgKHBhdGNoIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2Z1NwZWMgPSBwYXRjaCh2Z1NwZWMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZnU3BlYyA9IGFwcGx5UGF0Y2godmdTcGVjLCBwYXRjaCwgdHJ1ZSwgZmFsc2UpLm5ld0RvY3VtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFNldCBsb2NhbGUuIE5vdGUgdGhhdCB0aGlzIGlzIGEgZ2xvYmFsIHNldHRpbmcuXG5cblxuICAgICAgICAgICAgaWYgKG9wdHMuZm9ybWF0TG9jYWxlKSB7XG4gICAgICAgICAgICAgIHZlZ2EuZm9ybWF0TG9jYWxlKG9wdHMuZm9ybWF0TG9jYWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdHMudGltZUZvcm1hdExvY2FsZSkge1xuICAgICAgICAgICAgICB2ZWdhLnRpbWVGb3JtYXRMb2NhbGUob3B0cy50aW1lRm9ybWF0TG9jYWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXN0ID0gb3B0cy5hc3Q7IC8vIERvIG5vdCBhcHBseSB0aGUgY29uZmlnIHRvIFZlZ2Egd2hlbiB3ZSBoYXZlIGFscmVhZHkgYXBwbGllZCBpdCB0byBWZWdhLUxpdGUuXG4gICAgICAgICAgICAvLyBUaGlzIGNhbGwgbWF5IHRocm93IGFuIEVycm9yIGlmIHBhcnNpbmcgZmFpbHMuXG5cbiAgICAgICAgICAgIHJ1bnRpbWUgPSB2ZWdhLnBhcnNlKHZnU3BlYywgbW9kZSA9PT0gJ3ZlZ2EtbGl0ZScgPyB7fSA6IGNvbmZpZywge1xuICAgICAgICAgICAgICBhc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmlldyA9IG5ldyAob3B0cy52aWV3Q2xhc3MgfHwgdmVnYS5WaWV3KShydW50aW1lLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgICAgbG9hZGVyLFxuICAgICAgICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgICAgICAgcmVuZGVyZXJcbiAgICAgICAgICAgIH0sIGFzdCA/IHtcbiAgICAgICAgICAgICAgZXhwcjogdmVnYS5leHByZXNzaW9uSW50ZXJwcmV0ZXJcbiAgICAgICAgICAgIH0gOiB7fSkpO1xuICAgICAgICAgICAgdmlldy5hZGRTaWduYWxMaXN0ZW5lcignYXV0b3NpemUnLCAoXywgYXV0b3NpemUpID0+IHtcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBhdXRvc2l6ZS50eXBlO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlID09ICdmaXQteCcpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZml0LXgnKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnZml0LXknKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdmaXQteScpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnZml0LXgnKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZml0LXknKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdmaXQnKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2ZpdC14JywgJ2ZpdC15Jyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2ZpdC14JywgJ2ZpdC15Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAob3B0cy50b29sdGlwICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBpZiAoaXNUb29sdGlwSGFuZGxlcihvcHRzLnRvb2x0aXApKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IG9wdHMudG9vbHRpcDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1c2VyIHByb3ZpZGVkIGJvb2xlYW4gdHJ1ZSBvciB0b29sdGlwIG9wdGlvbnNcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gbmV3IEhhbmRsZXIob3B0cy50b29sdGlwID09PSB0cnVlID8ge30gOiBvcHRzLnRvb2x0aXApLmNhbGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2aWV3LnRvb2x0aXAoaGFuZGxlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhvdmVyID0gb3B0cy5ob3ZlcjtcblxuICAgICAgICAgICAgaWYgKGhvdmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaG92ZXIgPSBtb2RlID09PSAndmVnYSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChob3Zlcikge1xuICAgICAgICAgICAgICBfcmVmMiA9IHR5cGVvZiBob3ZlciA9PT0gJ2Jvb2xlYW4nID8ge30gOiBob3ZlciwgaG92ZXJTZXQgPSBfcmVmMi5ob3ZlclNldCwgdXBkYXRlU2V0ID0gX3JlZjIudXBkYXRlU2V0O1xuICAgICAgICAgICAgICB2aWV3LmhvdmVyKGhvdmVyU2V0LCB1cGRhdGVTZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0cykge1xuICAgICAgICAgICAgICBpZiAob3B0cy53aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmlldy53aWR0aChvcHRzLndpZHRoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChvcHRzLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmlldy5oZWlnaHQob3B0cy5oZWlnaHQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG9wdHMucGFkZGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmlldy5wYWRkaW5nKG9wdHMucGFkZGluZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzNjtcbiAgICAgICAgICAgIHJldHVybiB2aWV3LmluaXRpYWxpemUoY29udGFpbmVyLCBvcHRzLmJpbmQpLnJ1bkFzeW5jKCk7XG5cbiAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgICAgaWYgKGFjdGlvbnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHdyYXBwZXIgPSBlbGVtZW50O1xuXG4gICAgICAgICAgICAgIGlmIChvcHRzLmRlZmF1bHRTdHlsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGV0YWlscycpO1xuICAgICAgICAgICAgICAgIGRldGFpbHMudGl0bGUgPSBpMThuLkNMSUNLX1RPX1ZJRVdfQUNUSU9OUztcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZChkZXRhaWxzKTtcbiAgICAgICAgICAgICAgICB3cmFwcGVyID0gZGV0YWlscztcbiAgICAgICAgICAgICAgICBzdW1tYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3VtbWFyeScpO1xuICAgICAgICAgICAgICAgIHN1bW1hcnkuaW5uZXJIVE1MID0gU1ZHX0NJUkNMRVM7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5hcHBlbmQoc3VtbWFyeSk7XG5cbiAgICAgICAgICAgICAgICBkb2N1bWVudENsaWNrSGFuZGxlciA9IGV2ID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICghZGV0YWlscy5jb250YWlucyhldi50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMucmVtb3ZlQXR0cmlidXRlKCdvcGVuJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZG9jdW1lbnRDbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3RybCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZChjdHJsKTtcbiAgICAgICAgICAgICAgY3RybC5jbGFzc0xpc3QuYWRkKCd2ZWdhLWFjdGlvbnMnKTsgLy8gYWRkICdFeHBvcnQnIGFjdGlvblxuXG4gICAgICAgICAgICAgIGlmIChhY3Rpb25zID09PSB0cnVlIHx8IGFjdGlvbnMuZXhwb3J0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXh0ID0gX2FycltfaV07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25zID09PSB0cnVlIHx8IGFjdGlvbnMuZXhwb3J0ID09PSB0cnVlIHx8IGFjdGlvbnMuZXhwb3J0W2V4dF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkxOG5FeHBvcnRBY3Rpb24gPSBpMThuW1wiXCIuY29uY2F0KGV4dC50b1VwcGVyQ2FzZSgpLCBcIl9BQ1RJT05cIildO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb3J0TGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0TGluay50ZXh0ID0gaTE4bkV4cG9ydEFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0TGluay5ocmVmID0gJyMnO1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRMaW5rLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRMaW5rLmRvd25sb2FkID0gXCJcIi5jb25jYXQoZG93bmxvYWRGaWxlTmFtZSwgXCIuXCIpLmNvbmNhdChleHQpOyAvLyBhZGQgbGluayBvbiBtb3VzZWRvd24gc28gdGhhdCBpdCdzIGNvcnJlY3Qgd2hlbiB0aGUgY2xpY2sgaGFwcGVuc1xuXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydExpbmsuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldy50b0ltYWdlVVJMKGV4dCwgb3B0cy5zY2FsZUZhY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHJlZiA9IHVybDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgICAgICAgICAgY3RybC5hcHBlbmQoZXhwb3J0TGluayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfYXJyID0gWydzdmcnLCAncG5nJ107IF9pIDwgX2Fyci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IC8vIGFkZCAnVmlldyBTb3VyY2UnIGFjdGlvblxuXG5cbiAgICAgICAgICAgICAgaWYgKGFjdGlvbnMgPT09IHRydWUgfHwgYWN0aW9ucy5zb3VyY2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmlld1NvdXJjZUxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICAgICAgdmlld1NvdXJjZUxpbmsudGV4dCA9IGkxOG4uU09VUkNFX0FDVElPTjtcbiAgICAgICAgICAgICAgICB2aWV3U291cmNlTGluay5ocmVmID0gJyMnO1xuICAgICAgICAgICAgICAgIHZpZXdTb3VyY2VMaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfb3B0cyRzb3VyY2VIZWFkZXIsIF9vcHRzJHNvdXJjZUZvb3RlcjtcblxuICAgICAgICAgICAgICAgICAgdmlld1NvdXJjZShzdHJpbmdpZnkoc3BlYyksIChfb3B0cyRzb3VyY2VIZWFkZXIgPSBvcHRzLnNvdXJjZUhlYWRlcikgIT09IG51bGwgJiYgX29wdHMkc291cmNlSGVhZGVyICE9PSB2b2lkIDAgPyBfb3B0cyRzb3VyY2VIZWFkZXIgOiAnJywgKF9vcHRzJHNvdXJjZUZvb3RlciA9IG9wdHMuc291cmNlRm9vdGVyKSAhPT0gbnVsbCAmJiBfb3B0cyRzb3VyY2VGb290ZXIgIT09IHZvaWQgMCA/IF9vcHRzJHNvdXJjZUZvb3RlciA6ICcnLCBtb2RlKTtcbiAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdHJsLmFwcGVuZCh2aWV3U291cmNlTGluayk7XG4gICAgICAgICAgICAgIH0gLy8gYWRkICdWaWV3IENvbXBpbGVkJyBhY3Rpb25cblxuXG4gICAgICAgICAgICAgIGlmIChtb2RlID09PSAndmVnYS1saXRlJyAmJiAoYWN0aW9ucyA9PT0gdHJ1ZSB8fCBhY3Rpb25zLmNvbXBpbGVkICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBjb21waWxlTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgICAgICBjb21waWxlTGluay50ZXh0ID0gaTE4bi5DT01QSUxFRF9BQ1RJT047XG4gICAgICAgICAgICAgICAgY29tcGlsZUxpbmsuaHJlZiA9ICcjJztcbiAgICAgICAgICAgICAgICBjb21waWxlTGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX29wdHMkc291cmNlSGVhZGVyMiwgX29wdHMkc291cmNlRm9vdGVyMjtcblxuICAgICAgICAgICAgICAgICAgdmlld1NvdXJjZShzdHJpbmdpZnkodmdTcGVjKSwgKF9vcHRzJHNvdXJjZUhlYWRlcjIgPSBvcHRzLnNvdXJjZUhlYWRlcikgIT09IG51bGwgJiYgX29wdHMkc291cmNlSGVhZGVyMiAhPT0gdm9pZCAwID8gX29wdHMkc291cmNlSGVhZGVyMiA6ICcnLCAoX29wdHMkc291cmNlRm9vdGVyMiA9IG9wdHMuc291cmNlRm9vdGVyKSAhPT0gbnVsbCAmJiBfb3B0cyRzb3VyY2VGb290ZXIyICE9PSB2b2lkIDAgPyBfb3B0cyRzb3VyY2VGb290ZXIyIDogJycsICd2ZWdhJyk7XG4gICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3RybC5hcHBlbmQoY29tcGlsZUxpbmspO1xuICAgICAgICAgICAgICB9IC8vIGFkZCAnT3BlbiBpbiBWZWdhIEVkaXRvcicgYWN0aW9uXG5cblxuICAgICAgICAgICAgICBpZiAoYWN0aW9ucyA9PT0gdHJ1ZSB8fCBhY3Rpb25zLmVkaXRvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3JVcmwgPSAoX29wdHMkZWRpdG9yVXJsID0gb3B0cy5lZGl0b3JVcmwpICE9PSBudWxsICYmIF9vcHRzJGVkaXRvclVybCAhPT0gdm9pZCAwID8gX29wdHMkZWRpdG9yVXJsIDogJ2h0dHBzOi8vdmVnYS5naXRodWIuaW8vZWRpdG9yLyc7XG4gICAgICAgICAgICAgICAgZWRpdG9yTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgICAgICBlZGl0b3JMaW5rLnRleHQgPSBpMThuLkVESVRPUl9BQ1RJT047XG4gICAgICAgICAgICAgICAgZWRpdG9yTGluay5ocmVmID0gJyMnO1xuICAgICAgICAgICAgICAgIGVkaXRvckxpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgcG9zdCh3aW5kb3csIGVkaXRvclVybCwge1xuICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgICAgICAgICAgIHNwZWM6IHN0cmluZ2lmeShzcGVjKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3RybC5hcHBlbmQoZWRpdG9yTGluayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgICBzcGVjLFxuICAgICAgICAgICAgICB2Z1NwZWMsXG4gICAgICAgICAgICAgIGZpbmFsaXplXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCk7XG4gIH0pKTtcbiAgcmV0dXJuIF9lbWJlZDMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZW1iZWQ7XG5leHBvcnQgeyBERUZBVUxUX0FDVElPTlMsIGd1ZXNzTW9kZSwgdmVnYSwgX3ZlZ2FMaXRlIGFzIHZlZ2FMaXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZWdhLWVtYmVkLm1vZHVsZS5qcy5tYXBcbiIsImZ1bmN0aW9uIGUoZSl7Y29uc3RbbixyXT0vc2NoZW1hXFwvKFtcXHctXSspXFwvKFtcXHdcXC5cXC1dKylcXC5qc29uJC9nLmV4ZWMoZSkuc2xpY2UoMSwzKTtyZXR1cm57bGlicmFyeTpuLHZlcnNpb246cn19ZXhwb3J0IGRlZmF1bHQgZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci5tb2R1bGUuanMubWFwXG4iLCJ2YXIgbmFtZSA9IFwidmVnYS10aGVtZXNcIjtcbnZhciB2ZXJzaW9uID0gXCIyLjEwLjBcIjtcbnZhciBkZXNjcmlwdGlvbiA9IFwiVGhlbWVzIGZvciBzdHlsaXplZCBWZWdhIGFuZCBWZWdhLUxpdGUgdmlzdWFsaXphdGlvbnMuXCI7XG52YXIga2V5d29yZHMgPSBbXG5cdFwidmVnYVwiLFxuXHRcInZlZ2EtbGl0ZVwiLFxuXHRcInRoZW1lc1wiLFxuXHRcInN0eWxlXCJcbl07XG52YXIgbGljZW5zZSA9IFwiQlNELTMtQ2xhdXNlXCI7XG52YXIgYXV0aG9yID0ge1xuXHRuYW1lOiBcIlVXIEludGVyYWN0aXZlIERhdGEgTGFiXCIsXG5cdHVybDogXCJodHRwczovL2lkbC5jcy53YXNoaW5ndG9uLmVkdVwiXG59O1xudmFyIGNvbnRyaWJ1dG9ycyA9IFtcblx0e1xuXHRcdG5hbWU6IFwiRW1pbHkgR3VcIixcblx0XHR1cmw6IFwiaHR0cHM6Ly9naXRodWIuY29tL2VtaWx5Z3VcIlxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJBcnZpbmQgU2F0eWFuYXJheWFuXCIsXG5cdFx0dXJsOiBcImh0dHA6Ly9hcnZpbmRzYXR5YS5jb21cIlxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJKZWZmcmV5IEhlZXJcIixcblx0XHR1cmw6IFwiaHR0cHM6Ly9pZGwuY3Mud2FzaGluZ3Rvbi5lZHVcIlxuXHR9LFxuXHR7XG5cdFx0bmFtZTogXCJEb21pbmlrIE1vcml0elwiLFxuXHRcdHVybDogXCJodHRwczovL3d3dy5kb21vcml0ei5kZVwiXG5cdH1cbl07XG52YXIgbWFpbiA9IFwiYnVpbGQvdmVnYS10aGVtZXMuanNcIjtcbnZhciBtb2R1bGUgPSBcImJ1aWxkL3ZlZ2EtdGhlbWVzLm1vZHVsZS5qc1wiO1xudmFyIHVucGtnID0gXCJidWlsZC92ZWdhLXRoZW1lcy5taW4uanNcIjtcbnZhciBqc2RlbGl2ciA9IFwiYnVpbGQvdmVnYS10aGVtZXMubWluLmpzXCI7XG52YXIgdHlwZXMgPSBcImJ1aWxkL3ZlZ2EtdGhlbWVzLm1vZHVsZS5kLnRzXCI7XG52YXIgcmVwb3NpdG9yeSA9IHtcblx0dHlwZTogXCJnaXRcIixcblx0dXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EtdGhlbWVzLmdpdFwiXG59O1xudmFyIGZpbGVzID0gW1xuXHRcInNyY1wiLFxuXHRcImJ1aWxkXCJcbl07XG52YXIgc2NyaXB0cyA9IHtcblx0cHJlYnVpbGQ6IFwieWFybiBjbGVhblwiLFxuXHRidWlsZDogXCJyb2xsdXAgLWNcIixcblx0Y2xlYW46IFwicmltcmFmIGJ1aWxkICYmIHJpbXJhZiBleGFtcGxlcy9idWlsZFwiLFxuXHRcImNvcHk6ZGF0YVwiOiBcInJzeW5jIC1yIG5vZGVfbW9kdWxlcy92ZWdhLWRhdGFzZXRzL2RhdGEvKiBleGFtcGxlcy9kYXRhXCIsXG5cdFwiY29weTpidWlsZFwiOiBcInJzeW5jIC1yIGJ1aWxkLyogZXhhbXBsZXMvYnVpbGRcIixcblx0XCJkZXBsb3k6Z2hcIjogXCJ5YXJuIGJ1aWxkICYmIG1rZGlyIC1wIGV4YW1wbGVzL2J1aWxkICYmIHJzeW5jIC1yIGJ1aWxkLyogZXhhbXBsZXMvYnVpbGQgJiYgZ2gtcGFnZXMgLWQgZXhhbXBsZXNcIixcblx0cHJlcHVibGlzaE9ubHk6IFwieWFybiBjbGVhbiAmJiB5YXJuIGJ1aWxkXCIsXG5cdHByZXZlcnNpb246IFwieWFybiBsaW50XCIsXG5cdHNlcnZlOiBcImJyb3dzZXItc3luYyBzdGFydCAtcyAtZiBidWlsZCBleGFtcGxlcyAtLXNlcnZlU3RhdGljIGV4YW1wbGVzXCIsXG5cdHN0YXJ0OiBcInlhcm4gYnVpbGQgJiYgY29uY3VycmVudGx5IC0ta2lsbC1vdGhlcnMgLW4gU2VydmVyLFJvbGx1cCAneWFybiBzZXJ2ZScgJ3JvbGx1cCAtYyAtdydcIixcblx0cHJlcGFyZTogXCJiZWVtbyBjcmVhdGUtY29uZmlnXCIsXG5cdGVzbGludGJhc2U6IFwiYmVlbW8gZXNsaW50IC5cIixcblx0Zm9ybWF0OiBcInlhcm4gZXNsaW50YmFzZSAtLWZpeFwiLFxuXHRsaW50OiBcInlhcm4gZXNsaW50YmFzZVwiXG59O1xudmFyIGRldkRlcGVuZGVuY2llcyA9IHtcblx0XCJAcm9sbHVwL3BsdWdpbi1qc29uXCI6IFwiXjQuMS4wXCIsXG5cdFwiQHJvbGx1cC9wbHVnaW4tbm9kZS1yZXNvbHZlXCI6IFwiXjExLjIuMFwiLFxuXHRcIkB3ZXNzYmVyZy9yb2xsdXAtcGx1Z2luLXRzXCI6IFwiXjEuMy44XCIsXG5cdFwiYnJvd3Nlci1zeW5jXCI6IFwiXjIuMjYuMTRcIixcblx0Y29uY3VycmVudGx5OiBcIl42LjAuMFwiLFxuXHRcImdoLXBhZ2VzXCI6IFwiXjMuMS4wXCIsXG5cdHJvbGx1cDogXCJeMi4zOS4xXCIsXG5cdFwicm9sbHVwLXBsdWdpbi1idW5kbGUtc2l6ZVwiOiBcIl4xLjAuM1wiLFxuXHRcInJvbGx1cC1wbHVnaW4tdGVyc2VyXCI6IFwiXjcuMC4yXCIsXG5cdHR5cGVzY3JpcHQ6IFwiXjQuMi4yXCIsXG5cdHZlZ2E6IFwiXjUuMTkuMVwiLFxuXHRcInZlZ2EtbGl0ZVwiOiBcIl41LjAuMFwiLFxuXHRcInZlZ2EtbGl0ZS1kZXYtY29uZmlnXCI6IFwiXjAuMTYuMVwiXG59O1xudmFyIHBlZXJEZXBlbmRlbmNpZXMgPSB7XG5cdHZlZ2E6IFwiKlwiLFxuXHRcInZlZ2EtbGl0ZVwiOiBcIipcIlxufTtcbnZhciBwa2cgPSB7XG5cdG5hbWU6IG5hbWUsXG5cdHZlcnNpb246IHZlcnNpb24sXG5cdGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcblx0a2V5d29yZHM6IGtleXdvcmRzLFxuXHRsaWNlbnNlOiBsaWNlbnNlLFxuXHRhdXRob3I6IGF1dGhvcixcblx0Y29udHJpYnV0b3JzOiBjb250cmlidXRvcnMsXG5cdG1haW46IG1haW4sXG5cdG1vZHVsZTogbW9kdWxlLFxuXHR1bnBrZzogdW5wa2csXG5cdGpzZGVsaXZyOiBqc2RlbGl2cixcblx0dHlwZXM6IHR5cGVzLFxuXHRyZXBvc2l0b3J5OiByZXBvc2l0b3J5LFxuXHRmaWxlczogZmlsZXMsXG5cdHNjcmlwdHM6IHNjcmlwdHMsXG5cdGRldkRlcGVuZGVuY2llczogZGV2RGVwZW5kZW5jaWVzLFxuXHRwZWVyRGVwZW5kZW5jaWVzOiBwZWVyRGVwZW5kZW5jaWVzXG59O1xuXG5jb25zdCBsaWdodENvbG9yID0gJyNmZmYnO1xuY29uc3QgbWVkQ29sb3IgPSAnIzg4OCc7XG5jb25zdCBkYXJrVGhlbWUgPSB7XG4gICAgYmFja2dyb3VuZDogJyMzMzMnLFxuICAgIHRpdGxlOiB7XG4gICAgICAgIGNvbG9yOiBsaWdodENvbG9yLFxuICAgICAgICBzdWJ0aXRsZUNvbG9yOiBsaWdodENvbG9yXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgICAnZ3VpZGUtbGFiZWwnOiB7XG4gICAgICAgICAgICBmaWxsOiBsaWdodENvbG9yLFxuICAgICAgICB9LFxuICAgICAgICAnZ3VpZGUtdGl0bGUnOiB7XG4gICAgICAgICAgICBmaWxsOiBsaWdodENvbG9yLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgYXhpczoge1xuICAgICAgICBkb21haW5Db2xvcjogbGlnaHRDb2xvcixcbiAgICAgICAgZ3JpZENvbG9yOiBtZWRDb2xvcixcbiAgICAgICAgdGlja0NvbG9yOiBsaWdodENvbG9yLFxuICAgIH0sXG59O1xuXG5jb25zdCBtYXJrQ29sb3IgPSAnIzQ1NzJhNyc7XG5jb25zdCBleGNlbFRoZW1lID0ge1xuICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBhcmM6IHsgZmlsbDogbWFya0NvbG9yIH0sXG4gICAgYXJlYTogeyBmaWxsOiBtYXJrQ29sb3IgfSxcbiAgICBsaW5lOiB7IHN0cm9rZTogbWFya0NvbG9yLCBzdHJva2VXaWR0aDogMiB9LFxuICAgIHBhdGg6IHsgc3Ryb2tlOiBtYXJrQ29sb3IgfSxcbiAgICByZWN0OiB7IGZpbGw6IG1hcmtDb2xvciB9LFxuICAgIHNoYXBlOiB7IHN0cm9rZTogbWFya0NvbG9yIH0sXG4gICAgc3ltYm9sOiB7IGZpbGw6IG1hcmtDb2xvciwgc3Ryb2tlV2lkdGg6IDEuNSwgc2l6ZTogNTAgfSxcbiAgICBheGlzOiB7XG4gICAgICAgIGJhbmRQb3NpdGlvbjogMC41LFxuICAgICAgICBncmlkOiB0cnVlLFxuICAgICAgICBncmlkQ29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgZ3JpZE9wYWNpdHk6IDEsXG4gICAgICAgIGdyaWRXaWR0aDogMC41LFxuICAgICAgICBsYWJlbFBhZGRpbmc6IDEwLFxuICAgICAgICB0aWNrU2l6ZTogNSxcbiAgICAgICAgdGlja1dpZHRoOiAwLjUsXG4gICAgfSxcbiAgICBheGlzQmFuZDoge1xuICAgICAgICBncmlkOiBmYWxzZSxcbiAgICAgICAgdGlja0V4dHJhOiB0cnVlLFxuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsQmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICBsYWJlbEZvbnRTaXplOiAxMSxcbiAgICAgICAgc3ltYm9sU2l6ZTogNTAsXG4gICAgICAgIHN5bWJvbFR5cGU6ICdzcXVhcmUnLFxuICAgIH0sXG4gICAgcmFuZ2U6IHtcbiAgICAgICAgY2F0ZWdvcnk6IFtcbiAgICAgICAgICAgICcjNDU3MmE3JyxcbiAgICAgICAgICAgICcjYWE0NjQzJyxcbiAgICAgICAgICAgICcjOGFhNDUzJyxcbiAgICAgICAgICAgICcjNzE1OThlJyxcbiAgICAgICAgICAgICcjNDU5OGFlJyxcbiAgICAgICAgICAgICcjZDk4NDQ1JyxcbiAgICAgICAgICAgICcjOTRhYWNlJyxcbiAgICAgICAgICAgICcjZDA5MzkzJyxcbiAgICAgICAgICAgICcjYjljYzk4JyxcbiAgICAgICAgICAgICcjYTk5Y2JjJyxcbiAgICAgICAgXSxcbiAgICB9LFxufTtcblxuY29uc3QgbWFya0NvbG9yJDEgPSAnIzMwYTJkYSc7XG5jb25zdCBheGlzQ29sb3IgPSAnI2NiY2JjYic7XG5jb25zdCBndWlkZUxhYmVsQ29sb3IgPSAnIzk5OSc7XG5jb25zdCBndWlkZVRpdGxlQ29sb3IgPSAnIzMzMyc7XG5jb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSAnI2YwZjBmMCc7XG5jb25zdCBibGFja1RpdGxlID0gJyMzMzMnO1xuY29uc3QgZml2ZVRoaXJ0eUVpZ2h0VGhlbWUgPSB7XG4gICAgYXJjOiB7IGZpbGw6IG1hcmtDb2xvciQxIH0sXG4gICAgYXJlYTogeyBmaWxsOiBtYXJrQ29sb3IkMSB9LFxuICAgIGF4aXM6IHtcbiAgICAgICAgZG9tYWluQ29sb3I6IGF4aXNDb2xvcixcbiAgICAgICAgZ3JpZDogdHJ1ZSxcbiAgICAgICAgZ3JpZENvbG9yOiBheGlzQ29sb3IsXG4gICAgICAgIGdyaWRXaWR0aDogMSxcbiAgICAgICAgbGFiZWxDb2xvcjogZ3VpZGVMYWJlbENvbG9yLFxuICAgICAgICBsYWJlbEZvbnRTaXplOiAxMCxcbiAgICAgICAgdGl0bGVDb2xvcjogZ3VpZGVUaXRsZUNvbG9yLFxuICAgICAgICB0aWNrQ29sb3I6IGF4aXNDb2xvcixcbiAgICAgICAgdGlja1NpemU6IDEwLFxuICAgICAgICB0aXRsZUZvbnRTaXplOiAxNCxcbiAgICAgICAgdGl0bGVQYWRkaW5nOiAxMCxcbiAgICAgICAgbGFiZWxQYWRkaW5nOiA0LFxuICAgIH0sXG4gICAgYXhpc0JhbmQ6IHtcbiAgICAgICAgZ3JpZDogZmFsc2UsXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgZ3JvdXA6IHtcbiAgICAgICAgZmlsbDogYmFja2dyb3VuZENvbG9yLFxuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsQ29sb3I6IGJsYWNrVGl0bGUsXG4gICAgICAgIGxhYmVsRm9udFNpemU6IDExLFxuICAgICAgICBwYWRkaW5nOiAxLFxuICAgICAgICBzeW1ib2xTaXplOiAzMCxcbiAgICAgICAgc3ltYm9sVHlwZTogJ3NxdWFyZScsXG4gICAgICAgIHRpdGxlQ29sb3I6IGJsYWNrVGl0bGUsXG4gICAgICAgIHRpdGxlRm9udFNpemU6IDE0LFxuICAgICAgICB0aXRsZVBhZGRpbmc6IDEwLFxuICAgIH0sXG4gICAgbGluZToge1xuICAgICAgICBzdHJva2U6IG1hcmtDb2xvciQxLFxuICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICB9LFxuICAgIHBhdGg6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkMSwgc3Ryb2tlV2lkdGg6IDAuNSB9LFxuICAgIHJlY3Q6IHsgZmlsbDogbWFya0NvbG9yJDEgfSxcbiAgICByYW5nZToge1xuICAgICAgICBjYXRlZ29yeTogW1xuICAgICAgICAgICAgJyMzMGEyZGEnLFxuICAgICAgICAgICAgJyNmYzRmMzAnLFxuICAgICAgICAgICAgJyNlNWFlMzgnLFxuICAgICAgICAgICAgJyM2ZDkwNGYnLFxuICAgICAgICAgICAgJyM4YjhiOGInLFxuICAgICAgICAgICAgJyNiOTZkYjgnLFxuICAgICAgICAgICAgJyNmZjllMjcnLFxuICAgICAgICAgICAgJyM1NmNjNjAnLFxuICAgICAgICAgICAgJyM1MmQyY2EnLFxuICAgICAgICAgICAgJyM1MjY4OWUnLFxuICAgICAgICAgICAgJyM1NDU0NTQnLFxuICAgICAgICAgICAgJyM5ZmU0ZjgnLFxuICAgICAgICBdLFxuICAgICAgICBkaXZlcmdpbmc6IFsnI2NjMDAyMCcsICcjZTc3ODY2JywgJyNmNmU3ZTEnLCAnI2Q2ZThlZCcsICcjOTFiZmQ5JywgJyMxZDc4YjUnXSxcbiAgICAgICAgaGVhdG1hcDogWycjZDZlOGVkJywgJyNjZWUwZTUnLCAnIzkxYmZkOScsICcjNTQ5Y2M2JywgJyMxZDc4YjUnXSxcbiAgICB9LFxuICAgIHBvaW50OiB7XG4gICAgICAgIGZpbGxlZDogdHJ1ZSxcbiAgICAgICAgc2hhcGU6ICdjaXJjbGUnLFxuICAgIH0sXG4gICAgc2hhcGU6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkMSB9LFxuICAgIGJhcjoge1xuICAgICAgICBiaW5TcGFjaW5nOiAyLFxuICAgICAgICBmaWxsOiBtYXJrQ29sb3IkMSxcbiAgICAgICAgc3Ryb2tlOiBudWxsLFxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgICAgYW5jaG9yOiAnc3RhcnQnLFxuICAgICAgICBmb250U2l6ZTogMjQsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICAgICAgb2Zmc2V0OiAyMCxcbiAgICB9LFxufTtcblxuY29uc3QgbWFya0NvbG9yJDIgPSAnIzAwMCc7XG5jb25zdCBnZ3Bsb3QyVGhlbWUgPSB7XG4gICAgZ3JvdXA6IHtcbiAgICAgICAgZmlsbDogJyNlNWU1ZTUnLFxuICAgIH0sXG4gICAgYXJjOiB7IGZpbGw6IG1hcmtDb2xvciQyIH0sXG4gICAgYXJlYTogeyBmaWxsOiBtYXJrQ29sb3IkMiB9LFxuICAgIGxpbmU6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkMiB9LFxuICAgIHBhdGg6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkMiB9LFxuICAgIHJlY3Q6IHsgZmlsbDogbWFya0NvbG9yJDIgfSxcbiAgICBzaGFwZTogeyBzdHJva2U6IG1hcmtDb2xvciQyIH0sXG4gICAgc3ltYm9sOiB7IGZpbGw6IG1hcmtDb2xvciQyLCBzaXplOiA0MCB9LFxuICAgIGF4aXM6IHtcbiAgICAgICAgZG9tYWluOiBmYWxzZSxcbiAgICAgICAgZ3JpZDogdHJ1ZSxcbiAgICAgICAgZ3JpZENvbG9yOiAnI0ZGRkZGRicsXG4gICAgICAgIGdyaWRPcGFjaXR5OiAxLFxuICAgICAgICBsYWJlbENvbG9yOiAnIzdGN0Y3RicsXG4gICAgICAgIGxhYmVsUGFkZGluZzogNCxcbiAgICAgICAgdGlja0NvbG9yOiAnIzdGN0Y3RicsXG4gICAgICAgIHRpY2tTaXplOiA1LjY3LFxuICAgICAgICB0aXRsZUZvbnRTaXplOiAxNixcbiAgICAgICAgdGl0bGVGb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgbGFiZWxGb250U2l6ZTogMTEsXG4gICAgICAgIHN5bWJvbFNpemU6IDQwLFxuICAgIH0sXG4gICAgcmFuZ2U6IHtcbiAgICAgICAgY2F0ZWdvcnk6IFtcbiAgICAgICAgICAgICcjMDAwMDAwJyxcbiAgICAgICAgICAgICcjN0Y3RjdGJyxcbiAgICAgICAgICAgICcjMUExQTFBJyxcbiAgICAgICAgICAgICcjOTk5OTk5JyxcbiAgICAgICAgICAgICcjMzMzMzMzJyxcbiAgICAgICAgICAgICcjQjBCMEIwJyxcbiAgICAgICAgICAgICcjNEQ0RDREJyxcbiAgICAgICAgICAgICcjQzlDOUM5JyxcbiAgICAgICAgICAgICcjNjY2NjY2JyxcbiAgICAgICAgICAgICcjRENEQ0RDJyxcbiAgICAgICAgXSxcbiAgICB9LFxufTtcblxuY29uc3QgaGVhZGxpbmVGb250U2l6ZSA9IDIyO1xuY29uc3QgaGVhZGxpbmVGb250V2VpZ2h0ID0gJ25vcm1hbCc7XG5jb25zdCBsYWJlbEZvbnQgPSAnQmVudG9uIEdvdGhpYywgc2Fucy1zZXJpZic7XG5jb25zdCBsYWJlbEZvbnRTaXplID0gMTEuNTtcbmNvbnN0IGxhYmVsRm9udFdlaWdodCA9ICdub3JtYWwnO1xuY29uc3QgbWFya0NvbG9yJDMgPSAnIzgyYzZkZic7XG4vLyBjb25zdCBtYXJrSGlnaGxpZ2h0ID0gJyMwMDZkOGYnO1xuLy8gY29uc3QgbWFya0RlbW9jcmF0ID0gJyM1Nzg5YjgnO1xuLy8gY29uc3QgbWFya1JlcHVibGljYW4gPSAnI2Q5NGY1NCc7XG5jb25zdCB0aXRsZUZvbnQgPSAnQmVudG9uIEdvdGhpYyBCb2xkLCBzYW5zLXNlcmlmJztcbmNvbnN0IHRpdGxlRm9udFdlaWdodCA9ICdub3JtYWwnO1xuY29uc3QgdGl0bGVGb250U2l6ZSA9IDEzO1xuY29uc3QgY29sb3JTY2hlbWVzID0ge1xuICAgICdjYXRlZ29yeS02JzogWycjZWM4NDMxJywgJyM4MjllYjEnLCAnI2M4OWQyOScsICcjMzU4MGIxJywgJyNhZGM4MzknLCAnI2FiN2ZiNCddLFxuICAgICdmaXJlLTcnOiBbJyNmYmYyYzcnLCAnI2Y5ZTM5YycsICcjZjhkMzZlJywgJyNmNGJiNmEnLCAnI2U2OGE0ZicsICcjZDE1YTQwJywgJyNhYjQyMzInXSxcbiAgICAnZmlyZWFuZGljZS02JzogWycjZTY4YTRmJywgJyNmNGJiNmEnLCAnI2Y5ZTM5YycsICcjZGFkZmUyJywgJyNhNmI3YzYnLCAnIzg0OWVhZSddLFxuICAgICdpY2UtNyc6IFsnI2VkZWZlZScsICcjZGFkZmUyJywgJyNjNGNjZDInLCAnI2E2YjdjNicsICcjODQ5ZWFlJywgJyM2MDc3ODUnLCAnIzQ3NTI1ZCddLFxufTtcbmNvbnN0IGxhdGltZXNUaGVtZSA9IHtcbiAgICBiYWNrZ3JvdW5kOiAnI2ZmZmZmZicsXG4gICAgdGl0bGU6IHtcbiAgICAgICAgYW5jaG9yOiAnc3RhcnQnLFxuICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICBmb250OiB0aXRsZUZvbnQsXG4gICAgICAgIGZvbnRTaXplOiBoZWFkbGluZUZvbnRTaXplLFxuICAgICAgICBmb250V2VpZ2h0OiBoZWFkbGluZUZvbnRXZWlnaHQsXG4gICAgfSxcbiAgICBhcmM6IHsgZmlsbDogbWFya0NvbG9yJDMgfSxcbiAgICBhcmVhOiB7IGZpbGw6IG1hcmtDb2xvciQzIH0sXG4gICAgbGluZTogeyBzdHJva2U6IG1hcmtDb2xvciQzLCBzdHJva2VXaWR0aDogMiB9LFxuICAgIHBhdGg6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkMyB9LFxuICAgIHJlY3Q6IHsgZmlsbDogbWFya0NvbG9yJDMgfSxcbiAgICBzaGFwZTogeyBzdHJva2U6IG1hcmtDb2xvciQzIH0sXG4gICAgc3ltYm9sOiB7IGZpbGw6IG1hcmtDb2xvciQzLCBzaXplOiAzMCB9LFxuICAgIGF4aXM6IHtcbiAgICAgICAgbGFiZWxGb250LFxuICAgICAgICBsYWJlbEZvbnRTaXplLFxuICAgICAgICBsYWJlbEZvbnRXZWlnaHQsXG4gICAgICAgIHRpdGxlRm9udCxcbiAgICAgICAgdGl0bGVGb250U2l6ZSxcbiAgICAgICAgdGl0bGVGb250V2VpZ2h0LFxuICAgIH0sXG4gICAgYXhpc1g6IHtcbiAgICAgICAgbGFiZWxBbmdsZTogMCxcbiAgICAgICAgbGFiZWxQYWRkaW5nOiA0LFxuICAgICAgICB0aWNrU2l6ZTogMyxcbiAgICB9LFxuICAgIGF4aXNZOiB7XG4gICAgICAgIGxhYmVsQmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgICBtYXhFeHRlbnQ6IDQ1LFxuICAgICAgICBtaW5FeHRlbnQ6IDQ1LFxuICAgICAgICB0aWNrU2l6ZTogMixcbiAgICAgICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgICAgICB0aXRsZUFuZ2xlOiAwLFxuICAgICAgICB0aXRsZVg6IC00NSxcbiAgICAgICAgdGl0bGVZOiAtMTEsXG4gICAgfSxcbiAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxGb250LFxuICAgICAgICBsYWJlbEZvbnRTaXplLFxuICAgICAgICBzeW1ib2xUeXBlOiAnc3F1YXJlJyxcbiAgICAgICAgdGl0bGVGb250LFxuICAgICAgICB0aXRsZUZvbnRTaXplLFxuICAgICAgICB0aXRsZUZvbnRXZWlnaHQsXG4gICAgfSxcbiAgICByYW5nZToge1xuICAgICAgICBjYXRlZ29yeTogY29sb3JTY2hlbWVzWydjYXRlZ29yeS02J10sXG4gICAgICAgIGRpdmVyZ2luZzogY29sb3JTY2hlbWVzWydmaXJlYW5kaWNlLTYnXSxcbiAgICAgICAgaGVhdG1hcDogY29sb3JTY2hlbWVzWydmaXJlLTcnXSxcbiAgICAgICAgb3JkaW5hbDogY29sb3JTY2hlbWVzWydmaXJlLTcnXSxcbiAgICAgICAgcmFtcDogY29sb3JTY2hlbWVzWydmaXJlLTcnXSxcbiAgICB9LFxufTtcblxuY29uc3QgbWFya0NvbG9yJDQgPSAnI2FiNTc4Nyc7XG5jb25zdCBheGlzQ29sb3IkMSA9ICcjOTc5Nzk3JztcbmNvbnN0IHF1YXJ0elRoZW1lID0ge1xuICAgIGJhY2tncm91bmQ6ICcjZjlmOWY5JyxcbiAgICBhcmM6IHsgZmlsbDogbWFya0NvbG9yJDQgfSxcbiAgICBhcmVhOiB7IGZpbGw6IG1hcmtDb2xvciQ0IH0sXG4gICAgbGluZTogeyBzdHJva2U6IG1hcmtDb2xvciQ0IH0sXG4gICAgcGF0aDogeyBzdHJva2U6IG1hcmtDb2xvciQ0IH0sXG4gICAgcmVjdDogeyBmaWxsOiBtYXJrQ29sb3IkNCB9LFxuICAgIHNoYXBlOiB7IHN0cm9rZTogbWFya0NvbG9yJDQgfSxcbiAgICBzeW1ib2w6IHsgZmlsbDogbWFya0NvbG9yJDQsIHNpemU6IDMwIH0sXG4gICAgYXhpczoge1xuICAgICAgICBkb21haW5Db2xvcjogYXhpc0NvbG9yJDEsXG4gICAgICAgIGRvbWFpbldpZHRoOiAwLjUsXG4gICAgICAgIGdyaWRXaWR0aDogMC4yLFxuICAgICAgICBsYWJlbENvbG9yOiBheGlzQ29sb3IkMSxcbiAgICAgICAgdGlja0NvbG9yOiBheGlzQ29sb3IkMSxcbiAgICAgICAgdGlja1dpZHRoOiAwLjIsXG4gICAgICAgIHRpdGxlQ29sb3I6IGF4aXNDb2xvciQxLFxuICAgIH0sXG4gICAgYXhpc0JhbmQ6IHtcbiAgICAgICAgZ3JpZDogZmFsc2UsXG4gICAgfSxcbiAgICBheGlzWDoge1xuICAgICAgICBncmlkOiB0cnVlLFxuICAgICAgICB0aWNrU2l6ZTogMTAsXG4gICAgfSxcbiAgICBheGlzWToge1xuICAgICAgICBkb21haW46IGZhbHNlLFxuICAgICAgICBncmlkOiB0cnVlLFxuICAgICAgICB0aWNrU2l6ZTogMCxcbiAgICB9LFxuICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbEZvbnRTaXplOiAxMSxcbiAgICAgICAgcGFkZGluZzogMSxcbiAgICAgICAgc3ltYm9sU2l6ZTogMzAsXG4gICAgICAgIHN5bWJvbFR5cGU6ICdzcXVhcmUnLFxuICAgIH0sXG4gICAgcmFuZ2U6IHtcbiAgICAgICAgY2F0ZWdvcnk6IFtcbiAgICAgICAgICAgICcjYWI1Nzg3JyxcbiAgICAgICAgICAgICcjNTFiMmU1JyxcbiAgICAgICAgICAgICcjNzAzYzVjJyxcbiAgICAgICAgICAgICcjMTY4ZGQ5JyxcbiAgICAgICAgICAgICcjZDE5MGI2JyxcbiAgICAgICAgICAgICcjMDA2MDlmJyxcbiAgICAgICAgICAgICcjZDM2NWJhJyxcbiAgICAgICAgICAgICcjMTU0ODY2JyxcbiAgICAgICAgICAgICcjNjY2NjY2JyxcbiAgICAgICAgICAgICcjYzRjNGM0JyxcbiAgICAgICAgXSxcbiAgICB9LFxufTtcblxuY29uc3QgbWFya0NvbG9yJDUgPSAnIzNlNWM2OSc7XG5jb25zdCB2b3hUaGVtZSA9IHtcbiAgICBiYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgYXJjOiB7IGZpbGw6IG1hcmtDb2xvciQ1IH0sXG4gICAgYXJlYTogeyBmaWxsOiBtYXJrQ29sb3IkNSB9LFxuICAgIGxpbmU6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkNSB9LFxuICAgIHBhdGg6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkNSB9LFxuICAgIHJlY3Q6IHsgZmlsbDogbWFya0NvbG9yJDUgfSxcbiAgICBzaGFwZTogeyBzdHJva2U6IG1hcmtDb2xvciQ1IH0sXG4gICAgc3ltYm9sOiB7IGZpbGw6IG1hcmtDb2xvciQ1IH0sXG4gICAgYXhpczoge1xuICAgICAgICBkb21haW5XaWR0aDogMC41LFxuICAgICAgICBncmlkOiB0cnVlLFxuICAgICAgICBsYWJlbFBhZGRpbmc6IDIsXG4gICAgICAgIHRpY2tTaXplOiA1LFxuICAgICAgICB0aWNrV2lkdGg6IDAuNSxcbiAgICAgICAgdGl0bGVGb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGF4aXNCYW5kOiB7XG4gICAgICAgIGdyaWQ6IGZhbHNlLFxuICAgIH0sXG4gICAgYXhpc1g6IHtcbiAgICAgICAgZ3JpZFdpZHRoOiAwLjIsXG4gICAgfSxcbiAgICBheGlzWToge1xuICAgICAgICBncmlkRGFzaDogWzNdLFxuICAgICAgICBncmlkV2lkdGg6IDAuNCxcbiAgICB9LFxuICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbEZvbnRTaXplOiAxMSxcbiAgICAgICAgcGFkZGluZzogMSxcbiAgICAgICAgc3ltYm9sVHlwZTogJ3NxdWFyZScsXG4gICAgfSxcbiAgICByYW5nZToge1xuICAgICAgICBjYXRlZ29yeTogWycjM2U1YzY5JywgJyM2NzkzYTYnLCAnIzE4MjQyOScsICcjMDU3MGIwJywgJyMzNjkwYzAnLCAnIzc0YTljZicsICcjYTZiZGRiJywgJyNlMmRkZjInXSxcbiAgICB9LFxufTtcblxuY29uc3QgbWFya0NvbG9yJDYgPSAnIzE2OTZkMic7XG5jb25zdCBheGlzQ29sb3IkMiA9ICcjMDAwMDAwJztcbmNvbnN0IGJhY2tncm91bmRDb2xvciQxID0gJyNGRkZGRkYnO1xuY29uc3QgZm9udCA9ICdMYXRvJztcbmNvbnN0IGxhYmVsRm9udCQxID0gJ0xhdG8nO1xuY29uc3Qgc291cmNlRm9udCA9ICdMYXRvJztcbmNvbnN0IGdyaWRDb2xvciA9ICcjREVEREREJztcbmNvbnN0IHRpdGxlRm9udFNpemUkMSA9IDE4O1xuY29uc3QgY29sb3JTY2hlbWVzJDEgPSB7XG4gICAgJ21haW4tY29sb3JzJzogWycjMTY5NmQyJywgJyNkMmQyZDInLCAnIzAwMDAwMCcsICcjZmRiZjExJywgJyNlYzAwOGInLCAnIzU1Yjc0OCcsICcjNWM1ODU5JywgJyNkYjJiMjcnXSxcbiAgICAnc2hhZGVzLWJsdWUnOiBbJyNDRkU4RjMnLCAnI0EyRDRFQycsICcjNzNCRkUyJywgJyM0NkFCREInLCAnIzE2OTZEMicsICcjMTI3MTlFJywgJyMwQTRDNkEnLCAnIzA2MjYzNSddLFxuICAgICdzaGFkZXMtZ3JheSc6IFsnI0Y1RjVGNScsICcjRUNFQ0VDJywgJyNFM0UzRTMnLCAnI0RDREJEQicsICcjRDJEMkQyJywgJyM5RDlEOUQnLCAnIzY5Njk2OScsICcjMzUzNTM1J10sXG4gICAgJ3NoYWRlcy15ZWxsb3cnOiBbJyNGRkYyQ0YnLCAnI0ZDRTM5RScsICcjRkREODcwJywgJyNGQ0NCNDEnLCAnI0ZEQkYxMScsICcjRTg4RTJEJywgJyNDQTU4MDAnLCAnIzg0MzIxNSddLFxuICAgICdzaGFkZXMtbWFnZW50YSc6IFsnI0Y1Q0JERicsICcjRUI5OUMyJywgJyNFNDZBQTcnLCAnI0U1NDA5NicsICcjRUMwMDhCJywgJyNBRjFGNkInLCAnIzc2MTU0OCcsICcjMzUxMTIzJ10sXG4gICAgJ3NoYWRlcy1ncmVlbic6IFsnI0RDRUREOScsICcjQkNERUI0JywgJyM5OENGOTAnLCAnIzc4QzI2RCcsICcjNTVCNzQ4JywgJyM0MDg5NDEnLCAnIzJDNUMyRCcsICcjMUEyRTE5J10sXG4gICAgJ3NoYWRlcy1ibGFjayc6IFsnI0Q1RDVENCcsICcjQURBQkFDJywgJyM4NDgwODEnLCAnIzVDNTg1OScsICcjMzMyRDJGJywgJyMyNjIyMjMnLCAnIzFBMTcxNycsICcjMEUwQzBEJ10sXG4gICAgJ3NoYWRlcy1yZWQnOiBbJyNGOEQ1RDQnLCAnI0YxQUFBOScsICcjRTk4MDdEJywgJyNFMjU1NTInLCAnI0RCMkIyNycsICcjQTQyMDFEJywgJyM2RTE2MTQnLCAnIzM3MEIwQSddLFxuICAgICdvbmUtZ3JvdXAnOiBbJyMxNjk2ZDInLCAnIzAwMDAwMCddLFxuICAgICd0d28tZ3JvdXBzLWNhdC0xJzogWycjMTY5NmQyJywgJyMwMDAwMDAnXSxcbiAgICAndHdvLWdyb3Vwcy1jYXQtMic6IFsnIzE2OTZkMicsICcjZmRiZjExJ10sXG4gICAgJ3R3by1ncm91cHMtY2F0LTMnOiBbJyMxNjk2ZDInLCAnI2RiMmIyNyddLFxuICAgICd0d28tZ3JvdXBzLXNlcSc6IFsnI2EyZDRlYycsICcjMTY5NmQyJ10sXG4gICAgJ3RocmVlLWdyb3Vwcy1jYXQnOiBbJyMxNjk2ZDInLCAnI2ZkYmYxMScsICcjMDAwMDAwJ10sXG4gICAgJ3RocmVlLWdyb3Vwcy1zZXEnOiBbJyNhMmQ0ZWMnLCAnIzE2OTZkMicsICcjMGE0YzZhJ10sXG4gICAgJ2ZvdXItZ3JvdXBzLWNhdC0xJzogWycjMDAwMDAwJywgJyNkMmQyZDInLCAnI2ZkYmYxMScsICcjMTY5NmQyJ10sXG4gICAgJ2ZvdXItZ3JvdXBzLWNhdC0yJzogWycjMTY5NmQyJywgJyNlYzAwMDhiJywgJyNmZGJmMTEnLCAnIzVjNTg1OSddLFxuICAgICdmb3VyLWdyb3Vwcy1zZXEnOiBbJyNjZmU4ZjMnLCAnIzczYmY0MicsICcjMTY5NmQyJywgJyMwYTRjNmEnXSxcbiAgICAnZml2ZS1ncm91cHMtY2F0LTEnOiBbJyMxNjk2ZDInLCAnI2ZkYmYxMScsICcjZDJkMmQyJywgJyNlYzAwOGInLCAnIzAwMDAwMCddLFxuICAgICdmaXZlLWdyb3Vwcy1jYXQtMic6IFsnIzE2OTZkMicsICcjMGE0YzZhJywgJyNkMmQyZDInLCAnI2ZkYmYxMScsICcjMzMyZDJmJ10sXG4gICAgJ2ZpdmUtZ3JvdXBzLXNlcSc6IFsnI2NmZThmMycsICcjNzNiZjQyJywgJyMxNjk2ZDInLCAnIzBhNGM2YScsICcjMDAwMDAwJ10sXG4gICAgJ3NpeC1ncm91cHMtY2F0LTEnOiBbJyMxNjk2ZDInLCAnI2VjMDA4YicsICcjZmRiZjExJywgJyMwMDAwMDAnLCAnI2QyZDJkMicsICcjNTViNzQ4J10sXG4gICAgJ3NpeC1ncm91cHMtY2F0LTInOiBbJyMxNjk2ZDInLCAnI2QyZDJkMicsICcjZWMwMDhiJywgJyNmZGJmMTEnLCAnIzMzMmQyZicsICcjMGE0YzZhJ10sXG4gICAgJ3NpeC1ncm91cHMtc2VxJzogWycjY2ZlOGYzJywgJyNhMmQ0ZWMnLCAnIzczYmZlMicsICcjNDZhYmRiJywgJyMxNjk2ZDInLCAnIzEyNzE5ZSddLFxuICAgICdkaXZlcmdpbmctY29sb3JzJzogWycjY2E1ODAwJywgJyNmZGJmMTEnLCAnI2ZkZDg3MCcsICcjZmZmMmNmJywgJyNjZmU4ZjMnLCAnIzczYmZlMicsICcjMTY5NmQyJywgJyMwYTRjNmEnXSxcbn07XG5jb25zdCB1cmJhbkluc3RpdHV0ZVRoZW1lID0ge1xuICAgIGJhY2tncm91bmQ6IGJhY2tncm91bmRDb2xvciQxLFxuICAgIHRpdGxlOiB7XG4gICAgICAgIGFuY2hvcjogJ3N0YXJ0JyxcbiAgICAgICAgZm9udFNpemU6IHRpdGxlRm9udFNpemUkMSxcbiAgICAgICAgZm9udDogZm9udCxcbiAgICB9LFxuICAgIGF4aXNYOiB7XG4gICAgICAgIGRvbWFpbjogdHJ1ZSxcbiAgICAgICAgZG9tYWluQ29sb3I6IGF4aXNDb2xvciQyLFxuICAgICAgICBkb21haW5XaWR0aDogMSxcbiAgICAgICAgZ3JpZDogZmFsc2UsXG4gICAgICAgIGxhYmVsRm9udFNpemU6IDEyLFxuICAgICAgICBsYWJlbEZvbnQ6IGxhYmVsRm9udCQxLFxuICAgICAgICBsYWJlbEFuZ2xlOiAwLFxuICAgICAgICB0aWNrQ29sb3I6IGF4aXNDb2xvciQyLFxuICAgICAgICB0aWNrU2l6ZTogNSxcbiAgICAgICAgdGl0bGVGb250U2l6ZTogMTIsXG4gICAgICAgIHRpdGxlUGFkZGluZzogMTAsXG4gICAgICAgIHRpdGxlRm9udDogZm9udCxcbiAgICB9LFxuICAgIGF4aXNZOiB7XG4gICAgICAgIGRvbWFpbjogZmFsc2UsXG4gICAgICAgIGRvbWFpbldpZHRoOiAxLFxuICAgICAgICBncmlkOiB0cnVlLFxuICAgICAgICBncmlkQ29sb3I6IGdyaWRDb2xvcixcbiAgICAgICAgZ3JpZFdpZHRoOiAxLFxuICAgICAgICBsYWJlbEZvbnRTaXplOiAxMixcbiAgICAgICAgbGFiZWxGb250OiBsYWJlbEZvbnQkMSxcbiAgICAgICAgbGFiZWxQYWRkaW5nOiA4LFxuICAgICAgICB0aWNrczogZmFsc2UsXG4gICAgICAgIHRpdGxlRm9udFNpemU6IDEyLFxuICAgICAgICB0aXRsZVBhZGRpbmc6IDEwLFxuICAgICAgICB0aXRsZUZvbnQ6IGZvbnQsXG4gICAgICAgIHRpdGxlQW5nbGU6IDAsXG4gICAgICAgIHRpdGxlWTogLTEwLFxuICAgICAgICB0aXRsZVg6IDE4LFxuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsRm9udFNpemU6IDEyLFxuICAgICAgICBsYWJlbEZvbnQ6IGxhYmVsRm9udCQxLFxuICAgICAgICBzeW1ib2xTaXplOiAxMDAsXG4gICAgICAgIHRpdGxlRm9udFNpemU6IDEyLFxuICAgICAgICB0aXRsZVBhZGRpbmc6IDEwLFxuICAgICAgICB0aXRsZUZvbnQ6IGZvbnQsXG4gICAgICAgIG9yaWVudDogJ3JpZ2h0JyxcbiAgICAgICAgb2Zmc2V0OiAxMCxcbiAgICB9LFxuICAgIHZpZXc6IHtcbiAgICAgICAgc3Ryb2tlOiAndHJhbnNwYXJlbnQnLFxuICAgIH0sXG4gICAgcmFuZ2U6IHtcbiAgICAgICAgY2F0ZWdvcnk6IGNvbG9yU2NoZW1lcyQxWydzaXgtZ3JvdXBzLWNhdC0xJ10sXG4gICAgICAgIGRpdmVyZ2luZzogY29sb3JTY2hlbWVzJDFbJ2RpdmVyZ2luZy1jb2xvcnMnXSxcbiAgICAgICAgaGVhdG1hcDogY29sb3JTY2hlbWVzJDFbJ2RpdmVyZ2luZy1jb2xvcnMnXSxcbiAgICAgICAgb3JkaW5hbDogY29sb3JTY2hlbWVzJDFbJ3NpeC1ncm91cHMtc2VxJ10sXG4gICAgICAgIHJhbXA6IGNvbG9yU2NoZW1lcyQxWydzaGFkZXMtYmx1ZSddLFxuICAgIH0sXG4gICAgYXJlYToge1xuICAgICAgICBmaWxsOiBtYXJrQ29sb3IkNixcbiAgICB9LFxuICAgIHJlY3Q6IHtcbiAgICAgICAgZmlsbDogbWFya0NvbG9yJDYsXG4gICAgfSxcbiAgICBsaW5lOiB7XG4gICAgICAgIGNvbG9yOiBtYXJrQ29sb3IkNixcbiAgICAgICAgc3Ryb2tlOiBtYXJrQ29sb3IkNixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDUsXG4gICAgfSxcbiAgICB0cmFpbDoge1xuICAgICAgICBjb2xvcjogbWFya0NvbG9yJDYsXG4gICAgICAgIHN0cm9rZTogbWFya0NvbG9yJDYsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICBzaXplOiAxLFxuICAgIH0sXG4gICAgcGF0aDoge1xuICAgICAgICBzdHJva2U6IG1hcmtDb2xvciQ2LFxuICAgICAgICBzdHJva2VXaWR0aDogMC41LFxuICAgIH0sXG4gICAgcG9pbnQ6IHtcbiAgICAgICAgZmlsbGVkOiB0cnVlLFxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgICBmb250OiBzb3VyY2VGb250LFxuICAgICAgICBjb2xvcjogbWFya0NvbG9yJDYsXG4gICAgICAgIGZvbnRTaXplOiAxMSxcbiAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICBmb250V2VpZ2h0OiA0MDAsXG4gICAgICAgIHNpemU6IDExLFxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgICAgYmFyOiB7XG4gICAgICAgICAgICBmaWxsOiBtYXJrQ29sb3IkNixcbiAgICAgICAgICAgIHN0cm9rZTogbnVsbCxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGFyYzogeyBmaWxsOiBtYXJrQ29sb3IkNiB9LFxuICAgIHNoYXBlOiB7IHN0cm9rZTogbWFya0NvbG9yJDYgfSxcbiAgICBzeW1ib2w6IHsgZmlsbDogbWFya0NvbG9yJDYsIHNpemU6IDMwIH0sXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vb3Blbi1zb3VyY2UvbGljZW5zZXMvYnNkXG4gKi9cbmNvbnN0IG1hcmtDb2xvciQ3ID0gJyMzMzY2Q0MnO1xuY29uc3QgZ3JpZENvbG9yJDEgPSAnI2NjYyc7XG5jb25zdCBkZWZhdWx0Rm9udCA9ICdBcmlhbCwgc2Fucy1zZXJpZic7XG5jb25zdCBnb29nbGVjaGFydHNUaGVtZSA9IHtcbiAgICBhcmM6IHsgZmlsbDogbWFya0NvbG9yJDcgfSxcbiAgICBhcmVhOiB7IGZpbGw6IG1hcmtDb2xvciQ3IH0sXG4gICAgcGF0aDogeyBzdHJva2U6IG1hcmtDb2xvciQ3IH0sXG4gICAgcmVjdDogeyBmaWxsOiBtYXJrQ29sb3IkNyB9LFxuICAgIHNoYXBlOiB7IHN0cm9rZTogbWFya0NvbG9yJDcgfSxcbiAgICBzeW1ib2w6IHsgc3Ryb2tlOiBtYXJrQ29sb3IkNyB9LFxuICAgIGNpcmNsZTogeyBmaWxsOiBtYXJrQ29sb3IkNyB9LFxuICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBwYWRkaW5nOiB7XG4gICAgICAgIHRvcDogMTAsXG4gICAgICAgIHJpZ2h0OiAxMCxcbiAgICAgICAgYm90dG9tOiAxMCxcbiAgICAgICAgbGVmdDogMTAsXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgICAnZ3VpZGUtbGFiZWwnOiB7XG4gICAgICAgICAgICBmb250OiBkZWZhdWx0Rm9udCxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgfSxcbiAgICAgICAgJ2d1aWRlLXRpdGxlJzoge1xuICAgICAgICAgICAgZm9udDogZGVmYXVsdEZvbnQsXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIH0sXG4gICAgICAgICdncm91cC10aXRsZSc6IHtcbiAgICAgICAgICAgIGZvbnQ6IGRlZmF1bHRGb250LFxuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgICAgZm9udDogZGVmYXVsdEZvbnQsXG4gICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICBkeTogLTMsXG4gICAgICAgIGFuY2hvcjogJ3N0YXJ0JyxcbiAgICB9LFxuICAgIGF4aXM6IHtcbiAgICAgICAgZ3JpZENvbG9yOiBncmlkQ29sb3IkMSxcbiAgICAgICAgdGlja0NvbG9yOiBncmlkQ29sb3IkMSxcbiAgICAgICAgZG9tYWluOiBmYWxzZSxcbiAgICAgICAgZ3JpZDogdHJ1ZSxcbiAgICB9LFxuICAgIHJhbmdlOiB7XG4gICAgICAgIGNhdGVnb3J5OiBbXG4gICAgICAgICAgICAnIzQyODVGNCcsXG4gICAgICAgICAgICAnI0RCNDQzNycsXG4gICAgICAgICAgICAnI0Y0QjQwMCcsXG4gICAgICAgICAgICAnIzBGOUQ1OCcsXG4gICAgICAgICAgICAnI0FCNDdCQycsXG4gICAgICAgICAgICAnIzAwQUNDMScsXG4gICAgICAgICAgICAnI0ZGNzA0MycsXG4gICAgICAgICAgICAnIzlFOUQyNCcsXG4gICAgICAgICAgICAnIzVDNkJDMCcsXG4gICAgICAgICAgICAnI0YwNjI5MicsXG4gICAgICAgICAgICAnIzAwNzk2QicsXG4gICAgICAgICAgICAnI0MyMTg1QicsXG4gICAgICAgIF0sXG4gICAgICAgIGhlYXRtYXA6IFsnI2M2ZGFmYycsICcjNWU5N2Y2JywgJyMyYTU2YzYnXSxcbiAgICB9LFxufTtcblxuY29uc3QgdmVyc2lvbiQxID0gcGtnLnZlcnNpb247XG5cbmV4cG9ydCB7IGRhcmtUaGVtZSBhcyBkYXJrLCBleGNlbFRoZW1lIGFzIGV4Y2VsLCBmaXZlVGhpcnR5RWlnaHRUaGVtZSBhcyBmaXZldGhpcnR5ZWlnaHQsIGdncGxvdDJUaGVtZSBhcyBnZ3Bsb3QyLCBnb29nbGVjaGFydHNUaGVtZSBhcyBnb29nbGVjaGFydHMsIGxhdGltZXNUaGVtZSBhcyBsYXRpbWVzLCBxdWFydHpUaGVtZSBhcyBxdWFydHosIHVyYmFuSW5zdGl0dXRlVGhlbWUgYXMgdXJiYW5pbnN0aXR1dGUsIHZlcnNpb24kMSBhcyB2ZXJzaW9uLCB2b3hUaGVtZSBhcyB2b3ggfTtcbiIsImltcG9ydCB7IGlzQXJyYXksIGlzU3RyaW5nLCBpc09iamVjdCB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5cbnZhciBuYW1lID0gXCJ2ZWdhLXRvb2x0aXBcIjtcbnZhciB2ZXJzaW9uID0gXCIwLjI1LjFcIjtcbnZhciBkZXNjcmlwdGlvbiA9IFwiQSB0b29sdGlwIHBsdWdpbiBmb3IgVmVnYS1MaXRlIGFuZCBWZWdhIHZpc3VhbGl6YXRpb25zLlwiO1xudmFyIGtleXdvcmRzID0gW1xuXHRcInZlZ2EtbGl0ZVwiLFxuXHRcInZlZ2FcIixcblx0XCJ0b29sdGlwXCJcbl07XG52YXIgcmVwb3NpdG9yeSA9IHtcblx0dHlwZTogXCJnaXRcIixcblx0dXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EtdG9vbHRpcC5naXRcIlxufTtcbnZhciBhdXRob3IgPSB7XG5cdG5hbWU6IFwiVVcgSW50ZXJhY3RpdmUgRGF0YSBMYWJcIixcblx0dXJsOiBcImh0dHBzOi8vaWRsLmNzLndhc2hpbmd0b24uZWR1XCJcbn07XG52YXIgY29sbGFib3JhdG9ycyA9IFtcblx0XCJEb21pbmlrIE1vcml0elwiLFxuXHRcIlNpcmEgSG9ycmFkYXJuXCIsXG5cdFwiWmVuaW5nIFF1XCIsXG5cdFwiS2FuaXQgV29uZ3N1cGhhc2F3YXRcIixcblx0XCJZdXJpIEFzdHJha2hhblwiLFxuXHRcIkplZmZyZXkgSGVlclwiXG5dO1xudmFyIGxpY2Vuc2UgPSBcIkJTRC0zLUNsYXVzZVwiO1xudmFyIGJ1Z3MgPSB7XG5cdHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLXRvb2x0aXAvaXNzdWVzXCJcbn07XG52YXIgaG9tZXBhZ2UgPSBcImh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EtdG9vbHRpcCNyZWFkbWVcIjtcbnZhciBtYWluID0gXCJidWlsZC92ZWdhLXRvb2x0aXAuanNcIjtcbnZhciBtb2R1bGUgPSBcImJ1aWxkL3ZlZ2EtdG9vbHRpcC5tb2R1bGUuanNcIjtcbnZhciB1bnBrZyA9IFwiYnVpbGQvdmVnYS10b29sdGlwLm1pbi5qc1wiO1xudmFyIGpzZGVsaXZyID0gXCJidWlsZC92ZWdhLXRvb2x0aXAubWluLmpzXCI7XG52YXIgdHlwZXMgPSBcImJ1aWxkL3ZlZ2EtdG9vbHRpcC5tb2R1bGUuZC50c1wiO1xudmFyIGZpbGVzID0gW1xuXHRcInNyY1wiLFxuXHRcImJ1aWxkXCIsXG5cdFwidHlwZXNcIlxuXTtcbnZhciBzY3JpcHRzID0ge1xuXHRwcmVidWlsZDogXCJ5YXJuIGNsZWFuICYmIHlhcm4gYnVpbGQ6c3R5bGVcIixcblx0YnVpbGQ6IFwicm9sbHVwIC1jXCIsXG5cdFwiYnVpbGQ6c3R5bGVcIjogXCIuL2J1aWxkLXN0eWxlLnNoXCIsXG5cdGNsZWFuOiBcInJpbXJhZiBidWlsZCAmJiByaW1yYWYgc3JjL3N0eWxlLnRzXCIsXG5cdFwiY29weTpkYXRhXCI6IFwicnN5bmMgLXIgbm9kZV9tb2R1bGVzL3ZlZ2EtZGF0YXNldHMvZGF0YS8qIGV4YW1wbGVzL2RhdGFcIixcblx0XCJjb3B5OmJ1aWxkXCI6IFwicnN5bmMgLXIgYnVpbGQvKiBleGFtcGxlcy9idWlsZFwiLFxuXHRcImRlcGxveTpnaFwiOiBcInlhcm4gYnVpbGQgJiYgeWFybiBjb3B5OmJ1aWxkICYmIGdoLXBhZ2VzIC1kIGV4YW1wbGVzICYmIHlhcm4gY2xlYW5cIixcblx0cHJlcHVibGlzaE9ubHk6IFwieWFybiBjbGVhbiAmJiB5YXJuIGJ1aWxkXCIsXG5cdHByZXZlcnNpb246IFwieWFybiBsaW50ICYmIHlhcm4gdGVzdFwiLFxuXHRzZXJ2ZTogXCJicm93c2VyLXN5bmMgc3RhcnQgLXMgLWYgYnVpbGQgZXhhbXBsZXMgLS1zZXJ2ZVN0YXRpYyBleGFtcGxlc1wiLFxuXHRzdGFydDogXCJ5YXJuIGJ1aWxkICYmIGNvbmN1cnJlbnRseSAtLWtpbGwtb3RoZXJzIC1uIFNlcnZlcixSb2xsdXAgJ3lhcm4gc2VydmUnICdyb2xsdXAgLWMgLXcnXCIsXG5cdHByZXRlc3Q6IFwieWFybiBidWlsZDpzdHlsZVwiLFxuXHR0ZXN0OiBcImJlZW1vIGplc3RcIixcblx0XCJ0ZXN0Omluc3BlY3RcIjogXCJub2RlIC0taW5zcGVjdC1icmsgLi9ub2RlX21vZHVsZXMvLmJpbi9qZXN0IC0tcnVuSW5CYW5kXCIsXG5cdHByZXBhcmU6IFwiYmVlbW8gY3JlYXRlLWNvbmZpZyAmJiB5YXJuIGNvcHk6ZGF0YVwiLFxuXHRwcmV0dGllcmJhc2U6IFwiYmVlbW8gcHJldHRpZXIgJyoue2NzcyxzY3NzLGh0bWx9J1wiLFxuXHRlc2xpbnRiYXNlOiBcImJlZW1vIGVzbGludCAuXCIsXG5cdGZvcm1hdDogXCJ5YXJuIGVzbGludGJhc2UgLS1maXggJiYgeWFybiBwcmV0dGllcmJhc2UgLS13cml0ZVwiLFxuXHRsaW50OiBcInlhcm4gZXNsaW50YmFzZSAmJiB5YXJuIHByZXR0aWVyYmFzZSAtLWNoZWNrXCJcbn07XG52YXIgZGV2RGVwZW5kZW5jaWVzID0ge1xuXHRcIkByb2xsdXAvcGx1Z2luLWpzb25cIjogXCJeNC4xLjBcIixcblx0XCJAcm9sbHVwL3BsdWdpbi1ub2RlLXJlc29sdmVcIjogXCJeMTEuMi4wXCIsXG5cdFwiQHdlc3NiZXJnL3JvbGx1cC1wbHVnaW4tdHNcIjogXCJeMS4zLjhcIixcblx0XCJicm93c2VyLXN5bmNcIjogXCJeMi4yNi4xNFwiLFxuXHRjb25jdXJyZW50bHk6IFwiXjYuMC4wXCIsXG5cdFwiZ2gtcGFnZXNcIjogXCJeMy4xLjBcIixcblx0XCJub2RlLXNhc3NcIjogXCJeNS4wLjBcIixcblx0cGF0aDogXCJeMC4xMi43XCIsXG5cdHJvbGx1cDogXCJeMi4zOS4xXCIsXG5cdFwicm9sbHVwLXBsdWdpbi1idW5kbGUtc2l6ZVwiOiBcIl4xLjAuM1wiLFxuXHRcInJvbGx1cC1wbHVnaW4tdGVyc2VyXCI6IFwiXjcuMC4yXCIsXG5cdHR5cGVzY3JpcHQ6IFwifjQuMi4yXCIsXG5cdFwidmVnYS1kYXRhc2V0c1wiOiBcIl4yLjIuMFwiLFxuXHRcInZlZ2EtbGl0ZS1kZXYtY29uZmlnXCI6IFwiXjAuMTYuMVwiLFxuXHRcInZlZ2EtdHlwaW5nc1wiOiBcIl4wLjE5LjJcIlxufTtcbnZhciBkZXBlbmRlbmNpZXMgPSB7XG5cdFwidmVnYS11dGlsXCI6IFwiXjEuMTYuMFwiXG59O1xudmFyIHBrZyA9IHtcblx0bmFtZTogbmFtZSxcblx0dmVyc2lvbjogdmVyc2lvbixcblx0ZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuXHRrZXl3b3Jkczoga2V5d29yZHMsXG5cdHJlcG9zaXRvcnk6IHJlcG9zaXRvcnksXG5cdGF1dGhvcjogYXV0aG9yLFxuXHRjb2xsYWJvcmF0b3JzOiBjb2xsYWJvcmF0b3JzLFxuXHRsaWNlbnNlOiBsaWNlbnNlLFxuXHRidWdzOiBidWdzLFxuXHRob21lcGFnZTogaG9tZXBhZ2UsXG5cdG1haW46IG1haW4sXG5cdG1vZHVsZTogbW9kdWxlLFxuXHR1bnBrZzogdW5wa2csXG5cdGpzZGVsaXZyOiBqc2RlbGl2cixcblx0dHlwZXM6IHR5cGVzLFxuXHRmaWxlczogZmlsZXMsXG5cdHNjcmlwdHM6IHNjcmlwdHMsXG5cdGRldkRlcGVuZGVuY2llczogZGV2RGVwZW5kZW5jaWVzLFxuXHRkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llc1xufTtcblxuLy8gZ2VuZXJhdGVkIHdpdGggYnVpbGQtc3R5bGUuc2hcbnZhciBkZWZhdWx0U3R5bGUgPSBgI3ZnLXRvb2x0aXAtZWxlbWVudCB7XG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgcGFkZGluZzogOHB4O1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIHotaW5kZXg6IDEwMDA7XG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuICBmb250LXNpemU6IDExcHg7XG4gIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgYm94LXNoYWRvdzogMnB4IDJweCA0cHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICAvKiBUaGUgZGVmYXVsdCB0aGVtZSBpcyB0aGUgbGlnaHQgdGhlbWUuICovXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45NSk7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNkOWQ5ZDk7XG4gIGNvbG9yOiBibGFjazsgfVxuICAjdmctdG9vbHRpcC1lbGVtZW50LnZpc2libGUge1xuICAgIHZpc2liaWxpdHk6IHZpc2libGU7IH1cbiAgI3ZnLXRvb2x0aXAtZWxlbWVudCBoMiB7XG4gICAgbWFyZ2luLXRvcDogMDtcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xuICAgIGZvbnQtc2l6ZTogMTNweDsgfVxuICAjdmctdG9vbHRpcC1lbGVtZW50IGltZyB7XG4gICAgbWF4LXdpZHRoOiAyMDBweDtcbiAgICBtYXgtaGVpZ2h0OiAyMDBweDsgfVxuICAjdmctdG9vbHRpcC1lbGVtZW50IHRhYmxlIHtcbiAgICBib3JkZXItc3BhY2luZzogMDsgfVxuICAgICN2Zy10b29sdGlwLWVsZW1lbnQgdGFibGUgdHIge1xuICAgICAgYm9yZGVyOiBub25lOyB9XG4gICAgICAjdmctdG9vbHRpcC1lbGVtZW50IHRhYmxlIHRyIHRkIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICAgIHBhZGRpbmctdG9wOiAycHg7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiAycHg7IH1cbiAgICAgICAgI3ZnLXRvb2x0aXAtZWxlbWVudCB0YWJsZSB0ciB0ZC5rZXkge1xuICAgICAgICAgIGNvbG9yOiAjODA4MDgwO1xuICAgICAgICAgIG1heC13aWR0aDogMTUwcHg7XG4gICAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgICAgICAgcGFkZGluZy1yaWdodDogNHB4OyB9XG4gICAgICAgICN2Zy10b29sdGlwLWVsZW1lbnQgdGFibGUgdHIgdGQudmFsdWUge1xuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgIG1heC13aWR0aDogMzAwcHg7XG4gICAgICAgICAgbWF4LWhlaWdodDogN2VtO1xuICAgICAgICAgIHRleHQtYWxpZ246IGxlZnQ7IH1cbiAgI3ZnLXRvb2x0aXAtZWxlbWVudC5kYXJrLXRoZW1lIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDMyLCAzMiwgMzIsIDAuOSk7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2Y1ZjVmNTtcbiAgICBjb2xvcjogd2hpdGU7IH1cbiAgICAjdmctdG9vbHRpcC1lbGVtZW50LmRhcmstdGhlbWUgdGQua2V5IHtcbiAgICAgIGNvbG9yOiAjYmZiZmJmOyB9XG5gO1xuXG5jb25zdCBFTF9JRCA9ICd2Zy10b29sdGlwLWVsZW1lbnQnO1xuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIC8qKlxuICAgICAqIFggb2Zmc2V0LlxuICAgICAqL1xuICAgIG9mZnNldFg6IDEwLFxuICAgIC8qKlxuICAgICAqIFkgb2Zmc2V0LlxuICAgICAqL1xuICAgIG9mZnNldFk6IDEwLFxuICAgIC8qKlxuICAgICAqIElEIG9mIHRoZSB0b29sdGlwIGVsZW1lbnQuXG4gICAgICovXG4gICAgaWQ6IEVMX0lELFxuICAgIC8qKlxuICAgICAqIElEIG9mIHRoZSB0b29sdGlwIENTUyBzdHlsZS5cbiAgICAgKi9cbiAgICBzdHlsZUlkOiAndmVnYS10b29sdGlwLXN0eWxlJyxcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdGhlbWUuIFlvdSBjYW4gdXNlIHRoZSBDU1MgY2xhc3MgY2FsbGVkIFtUSEVNRV0tdGhlbWUgdG8gc3R5bGUgdGhlIHRvb2x0aXBzLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHR3byBwcmVkZWZpbmVkIHRoZW1lczogXCJsaWdodFwiIChkZWZhdWx0KSBhbmQgXCJkYXJrXCIuXG4gICAgICovXG4gICAgdGhlbWU6ICdsaWdodCcsXG4gICAgLyoqXG4gICAgICogRG8gbm90IHVzZSB0aGUgZGVmYXVsdCBzdHlsZXMgcHJvdmlkZWQgYnkgVmVnYSBUb29sdGlwLiBJZiB5b3UgZW5hYmxlIHRoaXMgb3B0aW9uLCB5b3UgbmVlZCB0byB1c2UgeW91ciBvd24gc3R5bGVzLiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGRpc2FibGUgdGhlIGRlZmF1bHQgc3R5bGUgd2hlbiB1c2luZyBhIGN1c3RvbSB0aGVtZS5cbiAgICAgKi9cbiAgICBkaXNhYmxlRGVmYXVsdFN0eWxlOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBIVE1MIHNhbml0aXplciBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgZGFuZ2Vyb3VzIEhUTUwgdG8gcHJldmVudCBYU1MuXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBhIGZ1bmN0aW9uIGZyb20gc3RyaW5nIHRvIHN0cmluZy4gWW91IG1heSByZXBsYWNlIGl0IHdpdGggYSBmb3JtYXR0ZXIgc3VjaCBhcyBhIG1hcmtkb3duIGZvcm1hdHRlci5cbiAgICAgKi9cbiAgICBzYW5pdGl6ZTogZXNjYXBlSFRNTCxcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGggd2hlbiBwcmludGluZyBvYmplY3RzIGluIHRoZSB0b29sdGlwLlxuICAgICAqL1xuICAgIG1heERlcHRoOiAyLFxufTtcbi8qKlxuICogRXNjYXBlIHNwZWNpYWwgSFRNTCBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRvIGNvbnZlcnQgdG8gc3RyaW5nIGFuZCBIVE1MLWVzY2FwZS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlSFRNTCh2YWx1ZSkge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFN0eWxlKGlkKSB7XG4gICAgLy8gSnVzdCBpbiBjYXNlIHRoaXMgaWQgY29tZXMgZnJvbSBhIHVzZXIsIGVuc3VyZSB0aGVzZSBpcyBubyBzZWN1cml0eSBpc3N1ZXNcbiAgICBpZiAoIS9eW0EtWmEtel0rWy06Llxcd10qJC8udGVzdChpZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEhUTUwgSUQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHlsZS50b1N0cmluZygpLnJlcGxhY2UoRUxfSUQsIGlkKTtcbn1cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG4vKipcbiAqIEZvcm1hdCB0aGUgdmFsdWUgdG8gYmUgc2hvd24gaW4gdGhlIHRvb2x0aXAuXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzaG93IGluIHRoZSB0b29sdGlwLlxuICogQHBhcmFtIHZhbHVlVG9IdG1sIEZ1bmN0aW9uIHRvIGNvbnZlcnQgYSBzaW5nbGUgY2VsbCB2YWx1ZSB0byBhbiBIVE1MIHN0cmluZ1xuICovXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSwgdmFsdWVUb0h0bWwsIG1heERlcHRoKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBgWyR7dmFsdWUubWFwKCh2KSA9PiB2YWx1ZVRvSHRtbChpc1N0cmluZyh2KSA/IHYgOiBzdHJpbmdpZnkodiwgbWF4RGVwdGgpKSkuam9pbignLCAnKX1dYDtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBsZXQgY29udGVudCA9ICcnO1xuICAgICAgICBjb25zdCBfYSA9IHZhbHVlLCB7IHRpdGxlLCBpbWFnZSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInRpdGxlXCIsIFwiaW1hZ2VcIl0pO1xuICAgICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYDxoMj4ke3ZhbHVlVG9IdG1sKHRpdGxlKX08L2gyPmA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IGA8aW1nIHNyYz1cIiR7dmFsdWVUb0h0bWwoaW1hZ2UpfVwiPmA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlc3QpO1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9ICc8dGFibGU+JztcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gcmVzdFtrZXldO1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB1bmRlZmluZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gc3RyaW5naWZ5KHZhbCwgbWF4RGVwdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGA8dHI+PHRkIGNsYXNzPVwia2V5XCI+JHt2YWx1ZVRvSHRtbChrZXkpfTo8L3RkPjx0ZCBjbGFzcz1cInZhbHVlXCI+JHt2YWx1ZVRvSHRtbCh2YWwpfTwvdGQ+PC90cj5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGVudCArPSBgPC90YWJsZT5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50IHx8ICd7fSc7IC8vIHNob3cgZW1wdHkgb2JqZWN0IGlmIHRoZXJlIGFyZSBubyBwcm9wZXJ0aWVzXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVRvSHRtbCh2YWx1ZSk7XG59XG5mdW5jdGlvbiByZXBsYWNlcihtYXhEZXB0aCkge1xuICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zID0gc3RhY2suaW5kZXhPZih0aGlzKSArIDE7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IG1heERlcHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tPYmplY3RdJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG4vKipcbiAqIFN0cmluZ2lmeSBhbnkgSlMgb2JqZWN0IHRvIHZhbGlkIEpTT05cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgbWF4RGVwdGgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlcihtYXhEZXB0aCkpO1xufVxuXG4vKipcbiAqIFBvc2l0aW9uIHRoZSB0b29sdGlwXG4gKlxuICogQHBhcmFtIGV2ZW50IFRoZSBtb3VzZSBldmVudC5cbiAqIEBwYXJhbSB0b29sdGlwQm94XG4gKiBAcGFyYW0gb2Zmc2V0WCBIb3Jpem9udGFsIG9mZnNldC5cbiAqIEBwYXJhbSBvZmZzZXRZIFZlcnRpY2FsIG9mZnNldC5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb24oZXZlbnQsIHRvb2x0aXBCb3gsIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICBsZXQgeCA9IGV2ZW50LmNsaWVudFggKyBvZmZzZXRYO1xuICAgIGlmICh4ICsgdG9vbHRpcEJveC53aWR0aCA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgICAgIHggPSArZXZlbnQuY2xpZW50WCAtIG9mZnNldFggLSB0b29sdGlwQm94LndpZHRoO1xuICAgIH1cbiAgICBsZXQgeSA9IGV2ZW50LmNsaWVudFkgKyBvZmZzZXRZO1xuICAgIGlmICh5ICsgdG9vbHRpcEJveC5oZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgICAgeSA9ICtldmVudC5jbGllbnRZIC0gb2Zmc2V0WSAtIHRvb2x0aXBCb3guaGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4geyB4LCB5IH07XG59XG5cbi8qKlxuICogVGhlIHRvb2x0aXAgaGFuZGxlciBjbGFzcy5cbiAqL1xuY2xhc3MgSGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSB0b29sdGlwIGhhbmRsZXIgYW5kIGluaXRpYWxpemUgdGhlIGVsZW1lbnQgYW5kIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVG9vbHRpcCBPcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBlbGVtZW50SWQgPSB0aGlzLm9wdGlvbnMuaWQ7XG4gICAgICAgIHRoaXMuZWwgPSBudWxsO1xuICAgICAgICAvLyBiaW5kIHRoaXMgdG8gY2FsbFxuICAgICAgICB0aGlzLmNhbGwgPSB0aGlzLnRvb2x0aXBIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIHByZXBlbmQgYSBkZWZhdWx0IHN0eWxlc2hlZXQgZm9yIHRvb2x0aXBzIHRvIHRoZSBoZWFkXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVEZWZhdWx0U3R5bGUgJiYgIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub3B0aW9ucy5zdHlsZUlkKSkge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMub3B0aW9ucy5zdHlsZUlkKTtcbiAgICAgICAgICAgIHN0eWxlLmlubmVySFRNTCA9IGNyZWF0ZURlZmF1bHRTdHlsZShlbGVtZW50SWQpO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICBpZiAoaGVhZC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0b29sdGlwIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdG9vbHRpcEhhbmRsZXIoaGFuZGxlciwgZXZlbnQsIGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGhhbmRsZXIsIGV2ZW50LCBpdGVtLCB2YWx1ZSk7XG4gICAgICAgIC8vIGFwcGVuZCBhIGRpdiBlbGVtZW50IHRoYXQgd2UgdXNlIGFzIGEgdG9vbHRpcCB1bmxlc3MgaXQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub3B0aW9ucy5pZCk7XG4gICAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5vcHRpb25zLmlkKTtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgndmctdG9vbHRpcCcpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b29sdGlwQ29udGFpbmVyID0gZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgIT0gbnVsbCA/IGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IDogZG9jdW1lbnQuYm9keTtcbiAgICAgICAgdG9vbHRpcENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgLy8gaGlkZSB0b29sdGlwIGZvciBudWxsLCB1bmRlZmluZWQsIG9yIGVtcHR5IHN0cmluZyB2YWx1ZXNcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnLCBgJHt0aGlzLm9wdGlvbnMudGhlbWV9LXRoZW1lYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSBmb3JtYXRWYWx1ZSh2YWx1ZSwgdGhpcy5vcHRpb25zLnNhbml0aXplLCB0aGlzLm9wdGlvbnMubWF4RGVwdGgpO1xuICAgICAgICAvLyBtYWtlIHRoZSB0b29sdGlwIHZpc2libGVcbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJywgYCR7dGhpcy5vcHRpb25zLnRoZW1lfS10aGVtZWApO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGNhbGN1bGF0ZVBvc2l0aW9uKGV2ZW50LCB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0aGlzLm9wdGlvbnMub2Zmc2V0WCwgdGhpcy5vcHRpb25zLm9mZnNldFkpO1xuICAgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgdG9wOiAke3l9cHg7IGxlZnQ6ICR7eH1weGApO1xuICAgIH1cbn1cblxuY29uc3QgdmVyc2lvbiQxID0gcGtnLnZlcnNpb247XG4vKipcbiAqIENyZWF0ZSBhIHRvb2x0aXAgaGFuZGxlciBhbmQgcmVnaXN0ZXIgaXQgd2l0aCB0aGUgcHJvdmlkZWQgdmlldy5cbiAqXG4gKiBAcGFyYW0gdmlldyBUaGUgVmVnYSB2aWV3LlxuICogQHBhcmFtIG9wdCBUb29sdGlwIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGluZGV4ICh2aWV3LCBvcHQpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gbmV3IEhhbmRsZXIob3B0KTtcbiAgICB2aWV3LnRvb2x0aXAoaGFuZGxlci5jYWxsKS5ydW4oKTtcbiAgICByZXR1cm4gaGFuZGxlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG5leHBvcnQgeyBERUZBVUxUX09QVElPTlMsIEhhbmRsZXIsIGNhbGN1bGF0ZVBvc2l0aW9uLCBjcmVhdGVEZWZhdWx0U3R5bGUsIGVzY2FwZUhUTUwsIGZvcm1hdFZhbHVlLCByZXBsYWNlciwgc3RyaW5naWZ5LCB2ZXJzaW9uJDEgYXMgdmVyc2lvbiB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==